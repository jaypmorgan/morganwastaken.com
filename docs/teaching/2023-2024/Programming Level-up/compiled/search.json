[
  {
    "objectID": "lecture-8.html",
    "href": "lecture-8.html",
    "title": "All about Git",
    "section": "",
    "text": "If we’re just programming by ourselves we often just make the changes to the program as we need as move on. But what if we’re not the only person making changes? For example, there are thousands of developers contributing to large open-source projects like the Linux kernel, Deep Learning frameworks such as Pytorch or Tensorflow, and programming languages such as Python. How do we manage the changes from all of these thousands of independent developers while keeping track of what’s changed?\nThis is (one of) the role of version control systems, often abbreviated to VCS. A version control system is an additional layer of software over our programming code that allows us to ‘checkpoint’ the program code at a specific point in time. Moreover, it can help ‘merge’ changes from different developers, so that the changes made by one developer does not un-intentionally overwrite the changes made by a different developer.\nGit, developed by Linus Torvalds in 2005, is one such version control system that is the most ubiquitous at the time of writing. It has surpassed many existing version control systems, and while many new ones have been proposed, none have been successful (yet) at unmounting Git from it’s throne as the leader of VCSs.\nIn this lecture, we’ll learn how to setup and use git in our projects."
  },
  {
    "objectID": "lecture-8.html#creating-checking-out-branches",
    "href": "lecture-8.html#creating-checking-out-branches",
    "title": "All about Git",
    "section": "Creating & Checking out Branches",
    "text": "Creating & Checking out Branches\nTo create a new branch use the branch sub-command, specifying the name of the new branch:\nmy-new-project % git branch develop\nmy-new-project % git branch\n  develop\n* main\nHere, we’ve created a new branch develop, and listed all of the existing branches using git branch.\nThe asterisk (*) next to the branch name tells us what branch we’re currently on.\nTo change branches we can checkout a new branch:\nmy-new-project % git checkout develop\nSwitched to branch 'develop'\nmy-new-project % git branch\n* develop\n  main\nOur project now looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n\n\n\n\n\nGit will tell us when it’s changing branches as you see in the above command.\nNow that we’re on the new branch, we can start to make some changes, stage, and commit them:\nmy-new-project % git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   src/main.cpp\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nmy-new-project % git add src/main.cpp  \nmy-new-project % git commit -m 'Add new feature'\n[develop a59f1a7] Add new feature\n 1 file changed, 1 insertion(+)\nNow our project looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit"
  },
  {
    "objectID": "lecture-8.html#merging-branches",
    "href": "lecture-8.html#merging-branches",
    "title": "All about Git",
    "section": "Merging Branches",
    "text": "Merging Branches\nOur ‘feature’ is complete, and we have a working state of the program, so we’ll want to merge this new feature back into the main branch.\nFirst, we’ll checkout the main branch\nmy-new-project % git checkout main\nSwitched to branch 'main'\nAnd now, we’ll merge the develop branch into the main branch using the merge sub-command:\nmy-new-project % git merge develop\nUpdating 1a5d58e..a59f1a7\nFast-forward\n src/main.cpp | 1 +\n 1 file changed, 1 insertion(+)\nOur project now looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit\n    checkout main\n    merge develop"
  },
  {
    "objectID": "lecture-8.html#merge-conflicts",
    "href": "lecture-8.html#merge-conflicts",
    "title": "All about Git",
    "section": "Merge Conflicts",
    "text": "Merge Conflicts\nSometimes, though, the branches cannot automatically be merged together. This can happen when the branches being merged have edited the same piece of text. Which edits does Git keep when merging? It’s a piece of software, not a mind-reader! It can’t know the answer to this question so we have to tell Git what to keep and what to throw away to complete the merging process.\nSo, let’s imagine we’re trying to merge two branches that have edited the same text. I’ve created this scenario by editing the title of the README file in two branches and tried to merge them. At this point this happened:\nmy-new-project % git merge develop\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\nGit is telling me: “I can’t automatically merge these two branches because they’ve edited the same thing. Tell me what to keep and then we can carry on.”\nSo we’ll do just that, if we open up the README.md file mentioned in the merge conflict message, we’ll see:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD \n# Deep Learning \n======= \n# C++ Examples of Deep Learning \n&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop \nEverything between &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and ======= is what’s currently in the commit. While between ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop is the content trying to be merged.\nLet’s say that we prefer what is in the develop branch, then we’ll remove (just by deleting in your text editor of choice) everything from &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD to ======= and then remove &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop so that our file now looks like this:\n# C++ Examples of Deep Learning \nIn essence we’ve extracted the parts of the file we wanted to keep in the process of merging, and removed the parts we didn’t want, in addition to removing the &lt;&lt;&lt;&lt;&lt;, ===== delimiters.\nNow we can save this file and commit the changes, thus completing the merge conflicts.\nmy-new-project % git status\nOn branch main\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n    both modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nmy-new-project % git commit -a -m 'Resolve conflicts'\n[main c8efca4] Resolve conflicts\nOur git history will now look something like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit\n    checkout main\n    merge develop\n    commit\n    checkout develop\n    commit\n    checkout main\n    merge develop"
  },
  {
    "objectID": "lecture-8-reveal.html#creating-checking-out-branches",
    "href": "lecture-8-reveal.html#creating-checking-out-branches",
    "title": "All about Git",
    "section": "Creating & Checking out Branches",
    "text": "Creating & Checking out Branches\nTo create a new branch use the branch sub-command, specifying the name of the new branch:\nmy-new-project % git branch develop\nmy-new-project % git branch\n  develop\n* main\nHere, we’ve created a new branch develop, and listed all of the existing branches using git branch.\nThe asterisk (*) next to the branch name tells us what branch we’re currently on.\nTo change branches we can checkout a new branch:\nmy-new-project % git checkout develop\nSwitched to branch 'develop'\nmy-new-project % git branch\n* develop\n  main\nOur project now looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n\n\n\n\n\nGit will tell us when it’s changing branches as you see in the above command.\nNow that we’re on the new branch, we can start to make some changes, stage, and commit them:\nmy-new-project % git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   src/main.cpp\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nmy-new-project % git add src/main.cpp  \nmy-new-project % git commit -m 'Add new feature'\n[develop a59f1a7] Add new feature\n 1 file changed, 1 insertion(+)\nNow our project looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit"
  },
  {
    "objectID": "lecture-8-reveal.html#merging-branches",
    "href": "lecture-8-reveal.html#merging-branches",
    "title": "All about Git",
    "section": "Merging Branches",
    "text": "Merging Branches\nOur ‘feature’ is complete, and we have a working state of the program, so we’ll want to merge this new feature back into the main branch.\nFirst, we’ll checkout the main branch\nmy-new-project % git checkout main\nSwitched to branch 'main'\nAnd now, we’ll merge the develop branch into the main branch using the merge sub-command:\nmy-new-project % git merge develop\nUpdating 1a5d58e..a59f1a7\nFast-forward\n src/main.cpp | 1 +\n 1 file changed, 1 insertion(+)\nOur project now looks like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit\n    checkout main\n    merge develop"
  },
  {
    "objectID": "lecture-8-reveal.html#merge-conflicts",
    "href": "lecture-8-reveal.html#merge-conflicts",
    "title": "All about Git",
    "section": "Merge Conflicts",
    "text": "Merge Conflicts\nSometimes, though, the branches cannot automatically be merged together. This can happen when the branches being merged have edited the same piece of text. Which edits does Git keep when merging? It’s a piece of software, not a mind-reader! It can’t know the answer to this question so we have to tell Git what to keep and what to throw away to complete the merging process.\nSo, let’s imagine we’re trying to merge two branches that have edited the same text. I’ve created this scenario by editing the title of the README file in two branches and tried to merge them. At this point this happened:\nmy-new-project % git merge develop\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\nGit is telling me: “I can’t automatically merge these two branches because they’ve edited the same thing. Tell me what to keep and then we can carry on.”\nSo we’ll do just that, if we open up the README.md file mentioned in the merge conflict message, we’ll see:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD \n# Deep Learning \n======= \n# C++ Examples of Deep Learning \n&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop \nEverything between &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and ======= is what’s currently in the commit. While between ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop is the content trying to be merged.\nLet’s say that we prefer what is in the develop branch, then we’ll remove (just by deleting in your text editor of choice) everything from &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD to ======= and then remove &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop so that our file now looks like this:\n# C++ Examples of Deep Learning \nIn essence we’ve extracted the parts of the file we wanted to keep in the process of merging, and removed the parts we didn’t want, in addition to removing the &lt;&lt;&lt;&lt;&lt;, ===== delimiters.\nNow we can save this file and commit the changes, thus completing the merge conflicts.\nmy-new-project % git status\nOn branch main\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n    both modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nmy-new-project % git commit -a -m 'Resolve conflicts'\n[main c8efca4] Resolve conflicts\nOur git history will now look something like:\n\n\n\n\ngitGraph\n    commit\n    commit\n    branch develop\n    checkout develop\n    commit\n    checkout main\n    merge develop\n    commit\n    checkout develop\n    commit\n    checkout main\n    merge develop"
  },
  {
    "objectID": "lecture-6.html",
    "href": "lecture-6.html",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "Pandas a library to make the representation and manipulation of tabular data easier in Python.\nA table of data is called a ‘Dataframe’ that consists of named columns and (optionally) named rows.\nhttps://pandas.pydata.org/\n\n\n\n\nTo install pandas, we can either use conda:\nconda install pandas\nor with pip:\npip install pandas\nAfter pandas has been installed. We shall import it into our scripts (using the common convention of aliasing the library as pd):\nimport pandas as pd\n\n\n\nNow that pandas has been successfully imported, we’re ready to create and manipulate our own dataframes. To create a dataframe, we first need to organise our data in appropriate format. Perhaps one of the most simple formats for this data is a dictionary, where each value is a list:\ndata = {\"col1\": [1, 2], \"col2\": [3, 4]}\nWe see that each ‘key’ is the representation of a column of data, and the value of this key is a list of data for this column. To convert this data to a dataframe, we need only to call the DataFrame class:\ndf = pd.DataFrame(data)\ndf (dataframe for short) is now our representation of the dataframe:\n\nWe see that each column is named using the keys in our data dictionary, and the values of the column correspond to the elements in the list. To the left of the dataframe we have a numerical index starting at 0.\nExtracting particular values from this dataframe can be accomplished using the loc and iloc class methods. First let’s look at using loc, and later on we’ll investigate the differences between these two methods.\nLet’s say we want to get all the data for the first row of our dataframe:\ndf.loc[0]\n\nThis returns a ‘Series’, which is just a representation of a vector of data.\n\n\n\nTo access a single value from this series, we can specify the column name:\ndf.loc[0][\"col1\"]  # returns one\nOr, we can more simply add the column name into the loc:\ndf.loc[0, \"col1\"]\nIf we wanted to retrieve a subset of columns, we supply a list of column names:\ndf.loc[0, [\"col1\", \"col2\"]]\nWe can also use the slice notation to access multiple rows:\ndf.loc[0:2, \"col1\"]\nThis retrieves the values in col1.\nOr if we just wanted to get the entire column of data, we could instead do:\ndf[\"col1\"]"
  },
  {
    "objectID": "lecture-6.html#what-is-pandas",
    "href": "lecture-6.html#what-is-pandas",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "Pandas a library to make the representation and manipulation of tabular data easier in Python.\nA table of data is called a ‘Dataframe’ that consists of named columns and (optionally) named rows.\nhttps://pandas.pydata.org/"
  },
  {
    "objectID": "lecture-6.html#installing-and-importing-pandas",
    "href": "lecture-6.html#installing-and-importing-pandas",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "To install pandas, we can either use conda:\nconda install pandas\nor with pip:\npip install pandas\nAfter pandas has been installed. We shall import it into our scripts (using the common convention of aliasing the library as pd):\nimport pandas as pd"
  },
  {
    "objectID": "lecture-6.html#creating-a-dataframe",
    "href": "lecture-6.html#creating-a-dataframe",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "Now that pandas has been successfully imported, we’re ready to create and manipulate our own dataframes. To create a dataframe, we first need to organise our data in appropriate format. Perhaps one of the most simple formats for this data is a dictionary, where each value is a list:\ndata = {\"col1\": [1, 2], \"col2\": [3, 4]}\nWe see that each ‘key’ is the representation of a column of data, and the value of this key is a list of data for this column. To convert this data to a dataframe, we need only to call the DataFrame class:\ndf = pd.DataFrame(data)\ndf (dataframe for short) is now our representation of the dataframe:\n\nWe see that each column is named using the keys in our data dictionary, and the values of the column correspond to the elements in the list. To the left of the dataframe we have a numerical index starting at 0.\nExtracting particular values from this dataframe can be accomplished using the loc and iloc class methods. First let’s look at using loc, and later on we’ll investigate the differences between these two methods.\nLet’s say we want to get all the data for the first row of our dataframe:\ndf.loc[0]\n\nThis returns a ‘Series’, which is just a representation of a vector of data."
  },
  {
    "objectID": "lecture-6.html#access-elements-in-our-dataframe",
    "href": "lecture-6.html#access-elements-in-our-dataframe",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "To access a single value from this series, we can specify the column name:\ndf.loc[0][\"col1\"]  # returns one\nOr, we can more simply add the column name into the loc:\ndf.loc[0, \"col1\"]\nIf we wanted to retrieve a subset of columns, we supply a list of column names:\ndf.loc[0, [\"col1\", \"col2\"]]\nWe can also use the slice notation to access multiple rows:\ndf.loc[0:2, \"col1\"]\nThis retrieves the values in col1.\nOr if we just wanted to get the entire column of data, we could instead do:\ndf[\"col1\"]"
  },
  {
    "objectID": "lecture-6.html#reading-a-csv-file",
    "href": "lecture-6.html#reading-a-csv-file",
    "title": "Introduction to Pandas",
    "section": "Reading a CSV file",
    "text": "Reading a CSV file\nInstead of manually constructing our data and then passing it to a DataFrame, we can use pandas to read directly from a CSV file and return a DataFrame:\nLet’s say we have a CSV file of measurements of Iris flowers called iris.csv. We can read this CSV file using the pd.read_csv method.\ndf = pd.read_csv(\"iris.csv\")"
  },
  {
    "objectID": "lecture-6.html#selecting-a-subset-of-data",
    "href": "lecture-6.html#selecting-a-subset-of-data",
    "title": "Introduction to Pandas",
    "section": "Selecting a subset of data",
    "text": "Selecting a subset of data\nWith this more complex dataset, we can use more fancy methods of indexing. For example, let’s select all the rows where the sepal length is less than 5 cm.\ndf[df[\"sepal length (cm)\"] &lt; 5]\n\nInstead of the 150 rows we had before, this returns just 22. We can also specify only the columns we want with this conditional expression:\ndf[df[\"sepal length (cm)\"] &lt; 5][\"sepal width (cm)\"]"
  },
  {
    "objectID": "lecture-6.html#creating-new-columns",
    "href": "lecture-6.html#creating-new-columns",
    "title": "Introduction to Pandas",
    "section": "Creating new columns",
    "text": "Creating new columns\nWe can add new columns to this dataset by using the assignment operator. In this example, we’re creating a new column called ‘sepal sum’ to be the sum of both the ‘sepal width’ and ‘sepal length’:\ndf[\"sepal sum\"] = df[\"sepal width (cm)\"] + df[\"sepal length (cm)\"]"
  },
  {
    "objectID": "lecture-6.html#shape-of-the-data",
    "href": "lecture-6.html#shape-of-the-data",
    "title": "Introduction to Pandas",
    "section": "Shape of the data",
    "text": "Shape of the data\nWe can also further see that our new column has been added by inspecting the shape of the data.\ndf.shape\n(150, 5)\nThis returns a tuple corresponding to the number of rows (150) and the number of columns (5)."
  },
  {
    "objectID": "lecture-6.html#getting-the-names-of-columns",
    "href": "lecture-6.html#getting-the-names-of-columns",
    "title": "Introduction to Pandas",
    "section": "Getting the names of columns",
    "text": "Getting the names of columns\nTo find out what the names of the columns are we can use the columns attribute:\ndf.columns\nIndex(['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)',\n       'petal width (cm)', 'sepal sum'],\n      dtype='object')\nThis returns an Index that can itself be indexed in the usual way:\ndf.columns[0]\n'sepal length (cm)'"
  },
  {
    "objectID": "lecture-6.html#headtail",
    "href": "lecture-6.html#headtail",
    "title": "Introduction to Pandas",
    "section": "Head/tail",
    "text": "Head/tail\nWe can get the first/last few rows of the data using the .head() or .tail() methods. These take an optional argument specifying the number of rows to view. By default, it will show 10 rows.\ndf.head()  # shows the first 10 rows\ndf.head(5) # shows the first 5 rows\n\ndf.tail()  # shows the last 10 rows\ndf.tail(5) # shows the last 5 rows"
  },
  {
    "objectID": "lecture-6.html#operations-on-data",
    "href": "lecture-6.html#operations-on-data",
    "title": "Introduction to Pandas",
    "section": "Operations on data",
    "text": "Operations on data\nPandas comes with a few standard methods to perform some basic operations. For example, you can calculate the mean of a column:\ndf[\"sepal length (cm)\"].mean()\nAnd you can use the apply() method to apply a function to every element (i.e. map a function to every element):\ndf[\"sepal length (cm)\"].apply(lambda x: x * 2)\nApply takes a function as an argument, and here we’re using an anonymous (unnamed function) using a lambda expression https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions\nThis lambda expression will double its input, and therefore applying this function to every element will double all values in ‘sepal length (cm)’."
  },
  {
    "objectID": "lecture-6.html#apply-operation-to-entire-row",
    "href": "lecture-6.html#apply-operation-to-entire-row",
    "title": "Introduction to Pandas",
    "section": "Apply operation to entire row",
    "text": "Apply operation to entire row\nIn the previous example, we saw the use of .apply, where a function is applied to each individual element in a column. With apply, it’s also possible to apply a function to each row of a dataframe, by specifying axis=1 in the call to apply:\n# some df with value column defined here\n\ndef window_sum(row, window=5):\n    \"\"\"Take a sum of rows within a window\"\"\"\n    curr_index = row.name  # access the row index number using .name\n    row[\"moving_avg\"] = df.loc[curr_index-window:curr_index, \"value\"].sum()\n    return row  # return the updated row\n\nupdated_df = df.apply(moving_avg, axis=1)"
  },
  {
    "objectID": "lecture-6.html#merge",
    "href": "lecture-6.html#merge",
    "title": "Introduction to Pandas",
    "section": "Merge",
    "text": "Merge\nMany pandas dataframes can be combined together using the concat method that requires a list of dataframes as input.\ndata1 = pd.DataFrame({\"col1\": [0, 1], \"col2\": [0, 1]})\ndata2 = pd.DataFrame({\"col1\": [2, 3], \"col2\": [2, 3]})\n\ncombined = pd.concat([data1, data2])"
  },
  {
    "objectID": "lecture-6.html#more-on-indexing",
    "href": "lecture-6.html#more-on-indexing",
    "title": "Introduction to Pandas",
    "section": "More on indexing",
    "text": "More on indexing\n\nNotice how the indexes are repeated. We can also verify this using the .index attribute:\ncombined.index\nInt64Index([0, 1, 0, 1], dtype='int64')\nWe can see two ’0’s and two ’1’s. Normally, this is not a problem, but it does have an effect on when we index our data with loc.\ncombined.loc[1]\n\nNotice how loc has returned two rows because it sees two rows with the index label of 1. If instead we simply meant: give me the second row we should use iloc:\ncombined.iloc[1]\nWhich will give us the desired outcome."
  },
  {
    "objectID": "lecture-6.html#resetting-indexes",
    "href": "lecture-6.html#resetting-indexes",
    "title": "Introduction to Pandas",
    "section": "Resetting indexes",
    "text": "Resetting indexes\nAlternatively we can reset the index labels:\ncombined.reset_index()\n\nThis will compute a new series of indexes for our data, and then using loc again will only return the one row.\nTo save the result of reset_index() we need to overwrite our original data:\ncombined = combined.reset_index()\nOr specify inplace:\ncombined.reset_index(inplace=True)"
  },
  {
    "objectID": "lecture-6.html#categorical-data",
    "href": "lecture-6.html#categorical-data",
    "title": "Introduction to Pandas",
    "section": "Categorical data",
    "text": "Categorical data\nSo far, we’ve only seen numerical data. One of the advantages of using pandas for tabular data is that we can represent various other types of data that makes our manipulation and operations on different data types simpler. For example, we can represent ‘categorical data’ where there is a finite set of values or categories.\ndf = pd.DataFrame({\"col1\": [\"a\", \"b\", \"c\", \"a\"],\n                    \"col2\": [1, 2, 5, 4]})\nRight now, df is simply representing ‘col1’ as strings, but we can change the representation to categorical elements with:\ndf[\"col1\"] = df[\"col1\"].astype(\"category\")\nWith categorical data, we can perform operations on these groups a lot quicker than if we were just to represent them on strings. For instance, lets compute the sum of ‘col2’ for each group.\ndf.groupby(\"col1\").sum()\n\nIf we have lots of data, having ‘col1’ astype('category') will be a lot more computationally efficient than leaving them as strings."
  },
  {
    "objectID": "lecture-6.html#dates-and-times",
    "href": "lecture-6.html#dates-and-times",
    "title": "Introduction to Pandas",
    "section": "Dates and times",
    "text": "Dates and times\nIf you have a column that represents a date or time, you can convert that column to a true datetime representation with pd.to_datetime\ndf = pd.DataFrame({\"col1\": [\"2002/01/30\", \"2010/05/16\"]})\ndf[\"col1\"] = pd.to_datetime(df[\"col1\"])\nIn addition to make indexing by dates a lot faster, it also provides us with some convienant methods to extract particular components from the data. Such as the year:\ndf[\"col1\"].dt.year # or df[\"col1\"].dt.month etc"
  },
  {
    "objectID": "lecture-6-reveal.html#what-is-pandas",
    "href": "lecture-6-reveal.html#what-is-pandas",
    "title": "Introduction to Pandas",
    "section": "What is Pandas?",
    "text": "What is Pandas?\n\n\nPandas a library to make the representation and manipulation of tabular data easier in Python.\nA table of data is called a ‘Dataframe’ that consists of named columns and (optionally) named rows.\nhttps://pandas.pydata.org/"
  },
  {
    "objectID": "lecture-6-reveal.html#installing-and-importing-pandas",
    "href": "lecture-6-reveal.html#installing-and-importing-pandas",
    "title": "Introduction to Pandas",
    "section": "Installing and importing pandas",
    "text": "Installing and importing pandas\nTo install pandas, we can either use conda:\nconda install pandas\nor with pip:\npip install pandas\nAfter pandas has been installed. We shall import it into our scripts (using the common convention of aliasing the library as pd):\nimport pandas as pd"
  },
  {
    "objectID": "lecture-6-reveal.html#creating-a-dataframe",
    "href": "lecture-6-reveal.html#creating-a-dataframe",
    "title": "Introduction to Pandas",
    "section": "Creating a dataframe",
    "text": "Creating a dataframe\nNow that pandas has been successfully imported, we’re ready to create and manipulate our own dataframes. To create a dataframe, we first need to organise our data in appropriate format. Perhaps one of the most simple formats for this data is a dictionary, where each value is a list:\ndata = {\"col1\": [1, 2], \"col2\": [3, 4]}\nWe see that each ‘key’ is the representation of a column of data, and the value of this key is a list of data for this column. To convert this data to a dataframe, we need only to call the DataFrame class:\ndf = pd.DataFrame(data)\ndf (dataframe for short) is now our representation of the dataframe:\n\nWe see that each column is named using the keys in our data dictionary, and the values of the column correspond to the elements in the list. To the left of the dataframe we have a numerical index starting at 0.\nExtracting particular values from this dataframe can be accomplished using the loc and iloc class methods. First let’s look at using loc, and later on we’ll investigate the differences between these two methods.\nLet’s say we want to get all the data for the first row of our dataframe:\ndf.loc[0]\n\nThis returns a ‘Series’, which is just a representation of a vector of data."
  },
  {
    "objectID": "lecture-6-reveal.html#access-elements-in-our-dataframe",
    "href": "lecture-6-reveal.html#access-elements-in-our-dataframe",
    "title": "Introduction to Pandas",
    "section": "Access elements in our dataframe",
    "text": "Access elements in our dataframe\nTo access a single value from this series, we can specify the column name:\ndf.loc[0][\"col1\"]  # returns one\nOr, we can more simply add the column name into the loc:\ndf.loc[0, \"col1\"]\nIf we wanted to retrieve a subset of columns, we supply a list of column names:\ndf.loc[0, [\"col1\", \"col2\"]]\nWe can also use the slice notation to access multiple rows:\ndf.loc[0:2, \"col1\"]\nThis retrieves the values in col1.\nOr if we just wanted to get the entire column of data, we could instead do:\ndf[\"col1\"]"
  },
  {
    "objectID": "lecture-6-reveal.html#reading-a-csv-file",
    "href": "lecture-6-reveal.html#reading-a-csv-file",
    "title": "Introduction to Pandas",
    "section": "Reading a CSV file",
    "text": "Reading a CSV file\nInstead of manually constructing our data and then passing it to a DataFrame, we can use pandas to read directly from a CSV file and return a DataFrame:\nLet’s say we have a CSV file of measurements of Iris flowers called iris.csv. We can read this CSV file using the pd.read_csv method.\ndf = pd.read_csv(\"iris.csv\")"
  },
  {
    "objectID": "lecture-6-reveal.html#selecting-a-subset-of-data",
    "href": "lecture-6-reveal.html#selecting-a-subset-of-data",
    "title": "Introduction to Pandas",
    "section": "Selecting a subset of data",
    "text": "Selecting a subset of data\nWith this more complex dataset, we can use more fancy methods of indexing. For example, let’s select all the rows where the sepal length is less than 5 cm.\ndf[df[\"sepal length (cm)\"] &lt; 5]\n\nInstead of the 150 rows we had before, this returns just 22. We can also specify only the columns we want with this conditional expression:\ndf[df[\"sepal length (cm)\"] &lt; 5][\"sepal width (cm)\"]"
  },
  {
    "objectID": "lecture-6-reveal.html#creating-new-columns",
    "href": "lecture-6-reveal.html#creating-new-columns",
    "title": "Introduction to Pandas",
    "section": "Creating new columns",
    "text": "Creating new columns\nWe can add new columns to this dataset by using the assignment operator. In this example, we’re creating a new column called ‘sepal sum’ to be the sum of both the ‘sepal width’ and ‘sepal length’:\ndf[\"sepal sum\"] = df[\"sepal width (cm)\"] + df[\"sepal length (cm)\"]"
  },
  {
    "objectID": "lecture-6-reveal.html#shape-of-the-data",
    "href": "lecture-6-reveal.html#shape-of-the-data",
    "title": "Introduction to Pandas",
    "section": "Shape of the data",
    "text": "Shape of the data\nWe can also further see that our new column has been added by inspecting the shape of the data.\ndf.shape\n(150, 5)\nThis returns a tuple corresponding to the number of rows (150) and the number of columns (5)."
  },
  {
    "objectID": "lecture-6-reveal.html#getting-the-names-of-columns",
    "href": "lecture-6-reveal.html#getting-the-names-of-columns",
    "title": "Introduction to Pandas",
    "section": "Getting the names of columns",
    "text": "Getting the names of columns\nTo find out what the names of the columns are we can use the columns attribute:\ndf.columns\nIndex(['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)',\n       'petal width (cm)', 'sepal sum'],\n      dtype='object')\nThis returns an Index that can itself be indexed in the usual way:\ndf.columns[0]\n'sepal length (cm)'"
  },
  {
    "objectID": "lecture-6-reveal.html#headtail",
    "href": "lecture-6-reveal.html#headtail",
    "title": "Introduction to Pandas",
    "section": "Head/tail",
    "text": "Head/tail\nWe can get the first/last few rows of the data using the .head() or .tail() methods. These take an optional argument specifying the number of rows to view. By default, it will show 10 rows.\ndf.head()  # shows the first 10 rows\ndf.head(5) # shows the first 5 rows\n\ndf.tail()  # shows the last 10 rows\ndf.tail(5) # shows the last 5 rows"
  },
  {
    "objectID": "lecture-6-reveal.html#operations-on-data",
    "href": "lecture-6-reveal.html#operations-on-data",
    "title": "Introduction to Pandas",
    "section": "Operations on data",
    "text": "Operations on data\nPandas comes with a few standard methods to perform some basic operations. For example, you can calculate the mean of a column:\ndf[\"sepal length (cm)\"].mean()\nAnd you can use the apply() method to apply a function to every element (i.e. map a function to every element):\ndf[\"sepal length (cm)\"].apply(lambda x: x * 2)\nApply takes a function as an argument, and here we’re using an anonymous (unnamed function) using a lambda expression https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions\nThis lambda expression will double its input, and therefore applying this function to every element will double all values in ‘sepal length (cm)’."
  },
  {
    "objectID": "lecture-6-reveal.html#apply-operation-to-entire-row",
    "href": "lecture-6-reveal.html#apply-operation-to-entire-row",
    "title": "Introduction to Pandas",
    "section": "Apply operation to entire row",
    "text": "Apply operation to entire row\nIn the previous example, we saw the use of .apply, where a function is applied to each individual element in a column. With apply, it’s also possible to apply a function to each row of a dataframe, by specifying axis=1 in the call to apply:\n# some df with value column defined here\n\ndef window_sum(row, window=5):\n    \"\"\"Take a sum of rows within a window\"\"\"\n    curr_index = row.name  # access the row index number using .name\n    row[\"moving_avg\"] = df.loc[curr_index-window:curr_index, \"value\"].sum()\n    return row  # return the updated row\n\nupdated_df = df.apply(moving_avg, axis=1)"
  },
  {
    "objectID": "lecture-6-reveal.html#merge",
    "href": "lecture-6-reveal.html#merge",
    "title": "Introduction to Pandas",
    "section": "Merge",
    "text": "Merge\nMany pandas dataframes can be combined together using the concat method that requires a list of dataframes as input.\ndata1 = pd.DataFrame({\"col1\": [0, 1], \"col2\": [0, 1]})\ndata2 = pd.DataFrame({\"col1\": [2, 3], \"col2\": [2, 3]})\n\ncombined = pd.concat([data1, data2])"
  },
  {
    "objectID": "lecture-6-reveal.html#more-on-indexing",
    "href": "lecture-6-reveal.html#more-on-indexing",
    "title": "Introduction to Pandas",
    "section": "More on indexing",
    "text": "More on indexing\n\nNotice how the indexes are repeated. We can also verify this using the .index attribute:\ncombined.index\nInt64Index([0, 1, 0, 1], dtype='int64')\nWe can see two ’0’s and two ’1’s. Normally, this is not a problem, but it does have an effect on when we index our data with loc.\ncombined.loc[1]\n\nNotice how loc has returned two rows because it sees two rows with the index label of 1. If instead we simply meant: give me the second row we should use iloc:\ncombined.iloc[1]\nWhich will give us the desired outcome."
  },
  {
    "objectID": "lecture-6-reveal.html#resetting-indexes",
    "href": "lecture-6-reveal.html#resetting-indexes",
    "title": "Introduction to Pandas",
    "section": "Resetting indexes",
    "text": "Resetting indexes\nAlternatively we can reset the index labels:\ncombined.reset_index()\n\nThis will compute a new series of indexes for our data, and then using loc again will only return the one row.\nTo save the result of reset_index() we need to overwrite our original data:\ncombined = combined.reset_index()\nOr specify inplace:\ncombined.reset_index(inplace=True)"
  },
  {
    "objectID": "lecture-6-reveal.html#categorical-data",
    "href": "lecture-6-reveal.html#categorical-data",
    "title": "Introduction to Pandas",
    "section": "Categorical data",
    "text": "Categorical data\nSo far, we’ve only seen numerical data. One of the advantages of using pandas for tabular data is that we can represent various other types of data that makes our manipulation and operations on different data types simpler. For example, we can represent ‘categorical data’ where there is a finite set of values or categories.\ndf = pd.DataFrame({\"col1\": [\"a\", \"b\", \"c\", \"a\"],\n                    \"col2\": [1, 2, 5, 4]})\nRight now, df is simply representing ‘col1’ as strings, but we can change the representation to categorical elements with:\ndf[\"col1\"] = df[\"col1\"].astype(\"category\")\nWith categorical data, we can perform operations on these groups a lot quicker than if we were just to represent them on strings. For instance, lets compute the sum of ‘col2’ for each group.\ndf.groupby(\"col1\").sum()\n\nIf we have lots of data, having ‘col1’ astype('category') will be a lot more computationally efficient than leaving them as strings."
  },
  {
    "objectID": "lecture-6-reveal.html#dates-and-times",
    "href": "lecture-6-reveal.html#dates-and-times",
    "title": "Introduction to Pandas",
    "section": "Dates and times",
    "text": "Dates and times\nIf you have a column that represents a date or time, you can convert that column to a true datetime representation with pd.to_datetime\ndf = pd.DataFrame({\"col1\": [\"2002/01/30\", \"2010/05/16\"]})\ndf[\"col1\"] = pd.to_datetime(df[\"col1\"])\nIn addition to make indexing by dates a lot faster, it also provides us with some convienant methods to extract particular components from the data. Such as the year:\ndf[\"col1\"].dt.year # or df[\"col1\"].dt.month etc"
  },
  {
    "objectID": "lecture-4.html",
    "href": "lecture-4.html",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "NumPy (https://numpy.org/) is one of the fundamental Python libraries for scientific computing. In essence, its aim is to make vector and array processing in Python much more efficient. Therefore, it would be your go-to for (numerical) data processing.\nNumerical data processing with NumPy can, most often that not, be magnitudes faster than what you can write in Python, even if the operations are the same. This is because NumPy is partly written in C.\nFor example, if we want to compute the matrix multiplication of two arrays:\nA = [[1, 4], [9, 5]]  # 2 dimensional 'matrices' A and B\nB = [[1, 2], [3, 4]]\nC = [[0, 0], [0, 0]]  # our result 'pre-allocated' with zeros\n\nfor i in range(len(A)):\n    for j in range(len(B)):\n        for k in range(len(B)):\n            C[i][j] += A[i][k] * B[k][j]\nThe previous example is quite un-weidly. We have to manually loop through the matrices and apply the computation for each element. This can be very slow in Python. NumPy provides a much cleaner and quicker interface:\nimport numpy as np\nA = np.array([[1, 4], [9, 5]])\nB = np.array([[1, 2], [3, 4]])\nC = A @ B  # or np.matmul(A, B)\nprint(C)\nResults: \n# =&gt; [[13 18]\n# =&gt;  [24 38]]\n\n\n\nBefore we can use NumPy, we must first install it if its not already. NumPy can easily be installed with one of your package managers of choice. For example, if you want to install via conda:\nconda install numpy\nor with pip:\npip install numpy\n\n\n\nAs we’ve seen previously, we use np.array to create a numpy array from a Python data type\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(A)\nResults: \n# =&gt; [[1 2 3]\n# =&gt;  [4 5 6]\n# =&gt;  [7 8 9]]\nWe’ve created a 3x3 matrix of integers. Note that, out-of-the-box, NumPy doesn’t support ragged arrays (matrices that are not rectangular), so this will not work as you expect:\nA = np.array([[1], [1, 2]])\n\n\n\nA numpy array has various attributes that are useful for our numerical computing. Some of these include:\nA = np.array([[1, 4], [9, 5]])\n\nprint(A.shape)  # the shape of the array\nprint(A.size)   # number of elements\nprint(A.ndim)   # number of dimensions\nprint(A.nbytes) # storage used\nprint(A.dtype)  # data type of elements\nResults: \n# =&gt; (2, 2)\n# =&gt; 4\n# =&gt; 2\n# =&gt; 32\n# =&gt; int64\n\n\n\nIn the previous example, the elements in the array we int64. But normally, we will see float64. However, there are many other available data types, where each of the different data types affects how much memory is used to represent the data.\n\nint (8, 16, 32, 64)\nuint (unsigned integers)\nbool\nfloat (8, 16, 32, 64)\ncomplex\n\nhttps://numpy.org/doc/stable/user/basics.types.html https://numpy.org/doc/stable/reference/arrays.dtypes.html\n\n\n\nWhen creating a NumPy array, NumPy will select what it thinks to be the most appropriate data type. However, we can tell NumPy explicitly what the data type should be with the dtype argument.\nA = np.array([[1, 2], [9, 5]], dtype=np.int8)\nprint(A)\nprint(A.dtype)\n\nA = np.array([[1, 2], [9, 5]], dtype=np.float)\nprint(A)\nprint(A.dtype)\nResults: \n# =&gt; [[1 2]\n# =&gt;  [9 5]]\n# =&gt; int8\n# =&gt; [[1. 2.]\n# =&gt;  [9. 5.]]\n# =&gt; float64\n\n\n\nIn some cases, we wish to change the data type of arrays after its creation. For this we use the .astype() method. This method takes a single argument: the data type you wish to change the array to.\nA = np.array([1, 2, 3, 4])\nprint(A.dtype)\nint64\n\n\n\nWe could change it to a float64 array:\nA = A.astype(float)\nprint(A.dtype)\nfloat64\n\n\n\nOr float32:\nA = A.astype(np.float32)\nprint(A.dtype)\nfloat32\n\n\n\nNumPy also provides us with a number of different functions to create arrays. Instead of doing this:\nA = np.array([[0, 0], [0, 0]])\nWe could instead use the np.zeros function, passing a tuple where each element of the tuple describes how many elements should be made in each dimension:\nA = np.zeros((2,)) # 1 dimensional\nA = np.zeros((2, 2))  # 2 dimensional\nA = np.zeros((2, 5, 5))  # 3 dimensional\nAnother commonly used array creation function is the np.random.randn function. This creates an array where elements are sampled from a normal distribution.\nA = np.random.randn(2, 2)\nprint(A)\nResults: \n# =&gt; [[-0.68213848 -0.44274759]\n# =&gt;  [ 0.6748596   0.64244208]]\nNote the interface is a little different than .zeros, where instead of passing a tuple, we pass multiple arguments to the function.\nIt is also convenient to create arrays with ranges of elements.\nA = np.arange(5, 10) # optional step\nprint(A)\nResults: \n# =&gt; [5 6 7 8 9]\nA = np.linspace(5, 10, 20)\nprint(A)\nResults: \n# =&gt; [ 5.          5.26315789  5.52631579  5.78947368  6.05263158  6.31578947\n# =&gt;   6.57894737  6.84210526  7.10526316  7.36842105  7.63157895  7.89473684\n# =&gt;   8.15789474  8.42105263  8.68421053  8.94736842  9.21052632  9.47368421\n# =&gt;   9.73684211 10.        ]\nThere are many more ways to create arrays. Some include:\n\nnp.ones - a matrix of 1’s\nnp.eye - an identity matrix\nnp.diag - create a matrix with supplied elements across the diagonal\nnp.fromfunction - load elements from the return of a function\nnp.fromfile - load elements from a data file\n\nThough, the best resource for understanding is NumPy’s own documentation on the subject: https://numpy.org/doc/stable/user/basics.creation.html"
  },
  {
    "objectID": "lecture-4.html#what-is-numpy",
    "href": "lecture-4.html#what-is-numpy",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "NumPy (https://numpy.org/) is one of the fundamental Python libraries for scientific computing. In essence, its aim is to make vector and array processing in Python much more efficient. Therefore, it would be your go-to for (numerical) data processing.\nNumerical data processing with NumPy can, most often that not, be magnitudes faster than what you can write in Python, even if the operations are the same. This is because NumPy is partly written in C.\nFor example, if we want to compute the matrix multiplication of two arrays:\nA = [[1, 4], [9, 5]]  # 2 dimensional 'matrices' A and B\nB = [[1, 2], [3, 4]]\nC = [[0, 0], [0, 0]]  # our result 'pre-allocated' with zeros\n\nfor i in range(len(A)):\n    for j in range(len(B)):\n        for k in range(len(B)):\n            C[i][j] += A[i][k] * B[k][j]\nThe previous example is quite un-weidly. We have to manually loop through the matrices and apply the computation for each element. This can be very slow in Python. NumPy provides a much cleaner and quicker interface:\nimport numpy as np\nA = np.array([[1, 4], [9, 5]])\nB = np.array([[1, 2], [3, 4]])\nC = A @ B  # or np.matmul(A, B)\nprint(C)\nResults: \n# =&gt; [[13 18]\n# =&gt;  [24 38]]"
  },
  {
    "objectID": "lecture-4.html#install-numpy",
    "href": "lecture-4.html#install-numpy",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "Before we can use NumPy, we must first install it if its not already. NumPy can easily be installed with one of your package managers of choice. For example, if you want to install via conda:\nconda install numpy\nor with pip:\npip install numpy"
  },
  {
    "objectID": "lecture-4.html#creating-a-numpy-array",
    "href": "lecture-4.html#creating-a-numpy-array",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "As we’ve seen previously, we use np.array to create a numpy array from a Python data type\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(A)\nResults: \n# =&gt; [[1 2 3]\n# =&gt;  [4 5 6]\n# =&gt;  [7 8 9]]\nWe’ve created a 3x3 matrix of integers. Note that, out-of-the-box, NumPy doesn’t support ragged arrays (matrices that are not rectangular), so this will not work as you expect:\nA = np.array([[1], [1, 2]])"
  },
  {
    "objectID": "lecture-4.html#basic-attributes",
    "href": "lecture-4.html#basic-attributes",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "A numpy array has various attributes that are useful for our numerical computing. Some of these include:\nA = np.array([[1, 4], [9, 5]])\n\nprint(A.shape)  # the shape of the array\nprint(A.size)   # number of elements\nprint(A.ndim)   # number of dimensions\nprint(A.nbytes) # storage used\nprint(A.dtype)  # data type of elements\nResults: \n# =&gt; (2, 2)\n# =&gt; 4\n# =&gt; 2\n# =&gt; 32\n# =&gt; int64"
  },
  {
    "objectID": "lecture-4.html#different-data-types",
    "href": "lecture-4.html#different-data-types",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "In the previous example, the elements in the array we int64. But normally, we will see float64. However, there are many other available data types, where each of the different data types affects how much memory is used to represent the data.\n\nint (8, 16, 32, 64)\nuint (unsigned integers)\nbool\nfloat (8, 16, 32, 64)\ncomplex\n\nhttps://numpy.org/doc/stable/user/basics.types.html https://numpy.org/doc/stable/reference/arrays.dtypes.html"
  },
  {
    "objectID": "lecture-4.html#creating-arrays-with-different-dtypes",
    "href": "lecture-4.html#creating-arrays-with-different-dtypes",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "When creating a NumPy array, NumPy will select what it thinks to be the most appropriate data type. However, we can tell NumPy explicitly what the data type should be with the dtype argument.\nA = np.array([[1, 2], [9, 5]], dtype=np.int8)\nprint(A)\nprint(A.dtype)\n\nA = np.array([[1, 2], [9, 5]], dtype=np.float)\nprint(A)\nprint(A.dtype)\nResults: \n# =&gt; [[1 2]\n# =&gt;  [9 5]]\n# =&gt; int8\n# =&gt; [[1. 2.]\n# =&gt;  [9. 5.]]\n# =&gt; float64"
  },
  {
    "objectID": "lecture-4.html#changing-dtypes",
    "href": "lecture-4.html#changing-dtypes",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "In some cases, we wish to change the data type of arrays after its creation. For this we use the .astype() method. This method takes a single argument: the data type you wish to change the array to.\nA = np.array([1, 2, 3, 4])\nprint(A.dtype)\nint64"
  },
  {
    "objectID": "lecture-4.html#section",
    "href": "lecture-4.html#section",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "We could change it to a float64 array:\nA = A.astype(float)\nprint(A.dtype)\nfloat64"
  },
  {
    "objectID": "lecture-4.html#section-1",
    "href": "lecture-4.html#section-1",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "Or float32:\nA = A.astype(np.float32)\nprint(A.dtype)\nfloat32"
  },
  {
    "objectID": "lecture-4.html#different-ways-of-creating-arrays",
    "href": "lecture-4.html#different-ways-of-creating-arrays",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "NumPy also provides us with a number of different functions to create arrays. Instead of doing this:\nA = np.array([[0, 0], [0, 0]])\nWe could instead use the np.zeros function, passing a tuple where each element of the tuple describes how many elements should be made in each dimension:\nA = np.zeros((2,)) # 1 dimensional\nA = np.zeros((2, 2))  # 2 dimensional\nA = np.zeros((2, 5, 5))  # 3 dimensional\nAnother commonly used array creation function is the np.random.randn function. This creates an array where elements are sampled from a normal distribution.\nA = np.random.randn(2, 2)\nprint(A)\nResults: \n# =&gt; [[-0.68213848 -0.44274759]\n# =&gt;  [ 0.6748596   0.64244208]]\nNote the interface is a little different than .zeros, where instead of passing a tuple, we pass multiple arguments to the function.\nIt is also convenient to create arrays with ranges of elements.\nA = np.arange(5, 10) # optional step\nprint(A)\nResults: \n# =&gt; [5 6 7 8 9]\nA = np.linspace(5, 10, 20)\nprint(A)\nResults: \n# =&gt; [ 5.          5.26315789  5.52631579  5.78947368  6.05263158  6.31578947\n# =&gt;   6.57894737  6.84210526  7.10526316  7.36842105  7.63157895  7.89473684\n# =&gt;   8.15789474  8.42105263  8.68421053  8.94736842  9.21052632  9.47368421\n# =&gt;   9.73684211 10.        ]\nThere are many more ways to create arrays. Some include:\n\nnp.ones - a matrix of 1’s\nnp.eye - an identity matrix\nnp.diag - create a matrix with supplied elements across the diagonal\nnp.fromfunction - load elements from the return of a function\nnp.fromfile - load elements from a data file\n\nThough, the best resource for understanding is NumPy’s own documentation on the subject: https://numpy.org/doc/stable/user/basics.creation.html"
  },
  {
    "objectID": "lecture-4.html#slicing-numpy-arrays",
    "href": "lecture-4.html#slicing-numpy-arrays",
    "title": "Introduction to Numpy",
    "section": "Slicing NumPy arrays",
    "text": "Slicing NumPy arrays\nIn native Python, when we have a ‘matrix’ like data structure (just a list of lists), and we want to access a particular element from this matrix, we have to do something like:\nA = [[1, 2], [3, 4]]\nprint(A[1][0])\nResults: \n# =&gt; 3\nHowever, in NumPy, we seperate the indexes by comma:\nA = np.array([[1, 2], [3, 4]])\nprint(A[1, 0])\nResults: \n# =&gt; 3\nIf we wanted to get all elements from the 2nd column we would use the : notation. For example:\nA = np.array([[1, 2], [3, 4]])\nprint(A[:, 1])\nResults: \n# =&gt; [2 4]\nLikewise, all elements from the 2nd row:\nprint(A[1, :])\nResults: \n# =&gt; [3 4]\nNote that when we slice an array, we are not copying the elements:\nA = np.array([[1, 2], [3, 4]])\nb = A[:, 1]\n\nb[0] = 10\n\nprint(A)\nResults: \n# =&gt; [[ 1 10]\n# =&gt;  [ 3  4]]\nAny modification you make to the b variable will also affect A. For that we must use .copy()\nA = np.array([[1, 2], [3, 4]])\nb = A[:, 1].copy()\n...\nIf we have a multi-dimensional array, to which we wish to index on the final dimension, one way to achieve this is by doing the following:\nA = np.random.randn(10, 2, 5, 4)  # our array to slice\nA[:, :, :, 1:2]  # slice on the last dimension\nThis can get pretty tedious the more that the number of dimensions increases. But! we have one syntactical shortcut at our disposal: the ellipses ‘…’. Using the ellipses in place of the many ‘:’ slices on each dimension, we’re telling NumPy to just take all elements from the prior dimensions. For example:\nA[..., 1:2]  # same slice on the last dimension"
  },
  {
    "objectID": "lecture-4.html#boolean-indexing",
    "href": "lecture-4.html#boolean-indexing",
    "title": "Introduction to Numpy",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nNumPy arrays can also be composed of boolean elements\nA = np.array([[1, -1], [0, 5]])\nprint(A &gt; 0)\nResults: \n# =&gt; [[ True False]\n# =&gt;  [False  True]]\nAnd we can also use boolean elements to help with indexing:\nvalues_above_zero = A[A &gt; 0]\nprint(values_above_zero)\nResults: \n# =&gt; [1 5]\nTherefore we can apply computations to only part of the array using this indexing feature:\nmask = A &gt; 0\nA[mask] = A[mask] + 10\nprint(A)\nResults: \n# =&gt; [[11 -1]\n# =&gt;  [ 0 15]]"
  },
  {
    "objectID": "lecture-4.html#reshape",
    "href": "lecture-4.html#reshape",
    "title": "Introduction to Numpy",
    "section": "Reshape",
    "text": "Reshape\nAfter an array has been created, we can modify its structure/shape using various functions. The first we shall look at is .reshape. For example, let us create a vector of 4 elements and then reshape it into an array of 2x2 elements. Of course, the new shape of the array must be proportional to the original number of elements: 2x2 elements = 4 elements.\nA = np.arange(1, 5)\n\nmat_A = A.reshape(2, 2)\nprint(mat_A)\nprint(A)  # A is not changed! No need for copy\nResults: \n# =&gt; [[1 2]\n# =&gt;  [3 4]]\n# =&gt; [1 2 3 4]"
  },
  {
    "objectID": "lecture-4.html#flatten",
    "href": "lecture-4.html#flatten",
    "title": "Introduction to Numpy",
    "section": "Flatten",
    "text": "Flatten\nIf we wanted to take a 2d array and reshape it into a vector, we could of course use the .reshape function again. But we could also use .flatten.\nflat_A = mat_A.flatten()\nprint(flat_A)\nResults: \n# =&gt; [1 2 3 4]\nWhen specifying the new dimensionality of the reshaped array, -1 is a shortcut to specify the dimensionality to allow reshaping to occur correctly. For example:\nA = np.arange(1, 5)\nprint(A)\n\nprint(A.reshape(2, -1))\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1 2]\n# =&gt;  [3 4]]\nWe’re telling NumPy to create an array with 2 elements on the 1st dimension, and then however many elements on the second dimension."
  },
  {
    "objectID": "lecture-4.html#add-a-dimension",
    "href": "lecture-4.html#add-a-dimension",
    "title": "Introduction to Numpy",
    "section": "Add a dimension",
    "text": "Add a dimension\nWe can add and remove dimensions using .expand_dims and .squeeze, respectively.\nprint(A)\nprint(np.expand_dims(A, 1))\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1]\n# =&gt;  [2]\n# =&gt;  [3]\n# =&gt;  [4]]\nWe are taking a vector and adding a dimension. Note that we have to use np.expand_dims passing the object we want to expand and not A.expand_dims.\nWe can use an indexing trick with None to do the expansion in just the same way:\nprint(A)\nprint(A[:, None])\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1]\n# =&gt;  [2]\n# =&gt;  [3]\n# =&gt;  [4]]\nWhere None indicates to NumPy where we want to add the new dimension."
  },
  {
    "objectID": "lecture-4.html#remove-a-dimension",
    "href": "lecture-4.html#remove-a-dimension",
    "title": "Introduction to Numpy",
    "section": "Remove a dimension",
    "text": "Remove a dimension\nIf we want to instead remove a dimension, we can use .squeeze()\nprint(A[:, None].squeeze(1))\nResults: \n# =&gt; [1 2 3 4]\nWe are removing the 2nd dimension, but note that the elements must be singletons. So you cannot squeeze a 2x2 array."
  },
  {
    "objectID": "lecture-4.html#matrix-transpose",
    "href": "lecture-4.html#matrix-transpose",
    "title": "Introduction to Numpy",
    "section": "Matrix transpose",
    "text": "Matrix transpose\nAnother useful feature is the matrix transpose:\nprint(mat_A)\n\nprint(mat_A.transpose())\nResults: \n# =&gt; [[1 2]\n# =&gt;  [3 4]]\n# =&gt; [[1 3]\n# =&gt;  [2 4]]\nor even:\n    print(mat_A.T)\nResults: \n# =&gt; [[1 3]\n# =&gt;  [2 4]]"
  },
  {
    "objectID": "lecture-4.html#composing-arrays",
    "href": "lecture-4.html#composing-arrays",
    "title": "Introduction to Numpy",
    "section": "Composing arrays",
    "text": "Composing arrays\nIf we have multiple arrays we want to ‘join’ together, we can use np.hstack for horizontally joining, or np.vstack for vertically joining arrays. Note the dimensions must match in the direction your stacking.\nA = np.array([1, 2, 3])\nB = np.array([4, 5, 6])\n\nprint(np.hstack([A, B]))\n[1 2 3 4 5 6]\nprint(np.vstack([A, B]))\nResults: \n# =&gt; [[1 2 3]\n# =&gt;  [4 5 6]]\nhstack and vstack can be useful when the required output shape is simply defined. However, there is a more general function - np.concatenate - that will be more often useful to us.\nprint(np.concatenate([A, B], axis=0))\n[1 2 3 4 5 6]\nHere we see that we can achieve the same result as np.hstack using concatenate. Notice also that there is a second argument to the concatenate function: the dimension upon which the concatenation will take place.\nhttps://numpy.org/doc/stable/reference/generated/numpy.concatenate.html"
  },
  {
    "objectID": "lecture-4.html#arithmetic-operations-1",
    "href": "lecture-4.html#arithmetic-operations-1",
    "title": "Introduction to Numpy",
    "section": "Arithmetic Operations",
    "text": "Arithmetic Operations\nWe have already seen some basic examples of arithmetic operations in NumPy. But its worth looking at these in detail.\nOne of the best reasons to use NumPy is that the computations are vectorized and can be broadcast. We’ll see examples of what these mean.\nA = np.array([1, 2, 3])\nB = np.array([[1, 2, 3],\n                [4, 5, 6]])\n\nprint(A * B)\nResults: \n# =&gt; [[ 1  4  9]\n# =&gt;  [ 4 10 18]]\nWe can perform vector and matrix arithmetic using Python’s infix operators like +, *, etc.\nWhen we perform arithmetic operations, NumPy will convert the data into arrays for us. While this can help, its not best practice for vectors and matrices, for scalars it will be fine.\nA = [1, 2, 3]\n\nprint(A * B)\nResults: \n# =&gt; [[ 1  4  9]\n# =&gt;  [ 4 10 18]]"
  },
  {
    "objectID": "lecture-4.html#broadcasting",
    "href": "lecture-4.html#broadcasting",
    "title": "Introduction to Numpy",
    "section": "Broadcasting",
    "text": "Broadcasting\nWhen we are working with singletons or scalar values, NumPy will automatically perform the broadcasting for us. So for example, if we want to double each element of an array:\nprint(B * 2)\nResults: \n# =&gt; [[ 2  4  6]\n# =&gt;  [ 8 10 12]]\nNumPy will automatically broadcast the scalar 2 to every element of the shape and size of B."
  },
  {
    "objectID": "lecture-4.html#comparison-with-functions",
    "href": "lecture-4.html#comparison-with-functions",
    "title": "Introduction to Numpy",
    "section": "Comparison with Functions",
    "text": "Comparison with Functions\nNumPy provides, in many cases, both infix and function operations.\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nInfix\n\n\nFunction\n\n\n\n\n\n\nAddition\n\n\n+\n\n\nnp.add\n\n\n\n\nSubtraction\n\n\n-\n\n\nnp.subtract\n\n\n\n\nMultiplication\n\n\n*\n\n\nnp.multiply\n\n\n\n\nDivision\n\n\n/\n\n\nnp.divide\n\n\n\n\nMatrix Multiplication\n\n\n@\n\n\nnp.matmul\n\n\n\n\nPower\n\n\n**\n\n\nnp.power\n\n\n\n\nCos/Tan/Sin\n\n\n \n\n\nnp.cos, np.tan, np.sin\n\n\n\n\nSquare root\n\n\n \n\n\nnp.sqrt\n\n\n\n\nExponential, Logarithm\n\n\n \n\n\nnp.exp, np.log\n\n\n\n\n\nhttps://numpy.org/doc/stable/reference/routines.math.html"
  },
  {
    "objectID": "lecture-4.html#more-complex-operations",
    "href": "lecture-4.html#more-complex-operations",
    "title": "Introduction to Numpy",
    "section": "More complex operations",
    "text": "More complex operations\nThere are a number of different operations one can perform on a matrix. Such as the dot product of two matrices:\nA = np.array([1, 2])\nB = np.array([[1, 2], [3, 4]])\nprint(np.dot(A, B))\nResults: \n# =&gt; [ 7 10]\nThe inner product:\nprint(np.inner(A, B))\nResults: \n# =&gt; [ 5 11]\nOne mystical function is the einsum function. This function can effectively replace other functions like dot and inner but it takes some understanding on how it works. einsum is the application of Einstein Summation, a succinct method of describing the multiplication between matrices. Lets first look at an example of the outer product:\nprint(np.einsum('i,ij-&gt;j', A, B))\nResults: \n# =&gt; [ 7 10]\nOr the inner product:\nprint(np.einsum('j,ij-&gt;i', A, B))\nResults: \n# =&gt; [ 5 11]\nIn einsum we are giving a letter for each dimension of each array we pass to the function.\nSo with: 'i,ij-&gt;j' for the inner product of matrices A and B, we are saying that the first dimension of A (its only dimension) is labelled i, while for B the dimensions are labelled as i and j respectively. The labels that exist in both sequences are summed over.\nEinsum can take a little time to fully understand and appreciate, but it can be a very powerful function with a very succinct syntax.\nhttps://www.youtube.com/watch?v=CLrTj7D2fLM - Khan Academy - Einstein Summation Convention"
  },
  {
    "objectID": "lecture-4.html#vectorizing-a-function",
    "href": "lecture-4.html#vectorizing-a-function",
    "title": "Introduction to Numpy",
    "section": "Vectorizing a function",
    "text": "Vectorizing a function\nLets say you have some function that computes the square of a number:\ndef my_square(x):\n    return x**2\n\nprint(my_square(4))\nResults: \n# =&gt; 16\nAs the function is simple, it takes one argument and returns one argument, we can pass a NumPy array and will get the correct result.\nA = np.arange(1, 10)\nprint(my_square(A))\nResults: \n# =&gt; [ 1  4  9 16 25 36 49 64 81]\nHowever, if the function is more complicated, it will not work.\ndef myfunc(a, b):\n    \"Return a-b if a&gt;b, otherwise return a+b\"\n    if a &gt; b:\n        return a - b\n    else:\n        return a + b\n\nprint(myfunc(A, 2))\nResults: \n# =&gt; Traceback (most recent call last):\n# =&gt;   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n# =&gt;   File \"/tmp/pyqVNaN0\", line 3, in &lt;module&gt;\n# =&gt;   File \"/tmp/babel-jHhWMz/python-nKlyRH\", line 8, in &lt;module&gt;\n# =&gt;     print(myfunc(A, 2))\n# =&gt;   File \"/tmp/babel-jHhWMz/python-nKlyRH\", line 3, in myfunc\n# =&gt;     if a &gt; b:\n# =&gt; ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nTo allow us to use this function over an array, we can use the np.vectorize function to create a new function, which applies myfunc over each element.\nvfunc = np.vectorize(myfunc)\nprint(vfunc(A, 2))\nResults: \n# =&gt; [3 4 1 2 3 4 5 6 7]\nHere we pass the function we want to vectorize myfunc to the np.vectorize function. The return of this function is another function!"
  },
  {
    "objectID": "lecture-4-reveal.html#what-is-numpy",
    "href": "lecture-4-reveal.html#what-is-numpy",
    "title": "Introduction to Numpy",
    "section": "What is NumPy?",
    "text": "What is NumPy?\nNumPy (https://numpy.org/) is one of the fundamental Python libraries for scientific computing. In essence, its aim is to make vector and array processing in Python much more efficient. Therefore, it would be your go-to for (numerical) data processing.\nNumerical data processing with NumPy can, most often that not, be magnitudes faster than what you can write in Python, even if the operations are the same. This is because NumPy is partly written in C.\nFor example, if we want to compute the matrix multiplication of two arrays:\nA = [[1, 4], [9, 5]]  # 2 dimensional 'matrices' A and B\nB = [[1, 2], [3, 4]]\nC = [[0, 0], [0, 0]]  # our result 'pre-allocated' with zeros\n\nfor i in range(len(A)):\n    for j in range(len(B)):\n        for k in range(len(B)):\n            C[i][j] += A[i][k] * B[k][j]\nThe previous example is quite un-weidly. We have to manually loop through the matrices and apply the computation for each element. This can be very slow in Python. NumPy provides a much cleaner and quicker interface:\nimport numpy as np\nA = np.array([[1, 4], [9, 5]])\nB = np.array([[1, 2], [3, 4]])\nC = A @ B  # or np.matmul(A, B)\nprint(C)\nResults: \n# =&gt; [[13 18]\n# =&gt;  [24 38]]"
  },
  {
    "objectID": "lecture-4-reveal.html#install-numpy",
    "href": "lecture-4-reveal.html#install-numpy",
    "title": "Introduction to Numpy",
    "section": "Install NumPy",
    "text": "Install NumPy\nBefore we can use NumPy, we must first install it if its not already. NumPy can easily be installed with one of your package managers of choice. For example, if you want to install via conda:\nconda install numpy\nor with pip:\npip install numpy"
  },
  {
    "objectID": "lecture-4-reveal.html#creating-a-numpy-array",
    "href": "lecture-4-reveal.html#creating-a-numpy-array",
    "title": "Introduction to Numpy",
    "section": "Creating a numpy array",
    "text": "Creating a numpy array\nAs we’ve seen previously, we use np.array to create a numpy array from a Python data type\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(A)\nResults: \n# =&gt; [[1 2 3]\n# =&gt;  [4 5 6]\n# =&gt;  [7 8 9]]\nWe’ve created a 3x3 matrix of integers. Note that, out-of-the-box, NumPy doesn’t support ragged arrays (matrices that are not rectangular), so this will not work as you expect:\nA = np.array([[1], [1, 2]])"
  },
  {
    "objectID": "lecture-4-reveal.html#basic-attributes",
    "href": "lecture-4-reveal.html#basic-attributes",
    "title": "Introduction to Numpy",
    "section": "Basic attributes",
    "text": "Basic attributes\nA numpy array has various attributes that are useful for our numerical computing. Some of these include:\nA = np.array([[1, 4], [9, 5]])\n\nprint(A.shape)  # the shape of the array\nprint(A.size)   # number of elements\nprint(A.ndim)   # number of dimensions\nprint(A.nbytes) # storage used\nprint(A.dtype)  # data type of elements\nResults: \n# =&gt; (2, 2)\n# =&gt; 4\n# =&gt; 2\n# =&gt; 32\n# =&gt; int64"
  },
  {
    "objectID": "lecture-4-reveal.html#different-data-types",
    "href": "lecture-4-reveal.html#different-data-types",
    "title": "Introduction to Numpy",
    "section": "Different data types",
    "text": "Different data types\nIn the previous example, the elements in the array we int64. But normally, we will see float64. However, there are many other available data types, where each of the different data types affects how much memory is used to represent the data.\n\nint (8, 16, 32, 64)\nuint (unsigned integers)\nbool\nfloat (8, 16, 32, 64)\ncomplex\n\nhttps://numpy.org/doc/stable/user/basics.types.html https://numpy.org/doc/stable/reference/arrays.dtypes.html"
  },
  {
    "objectID": "lecture-4-reveal.html#creating-arrays-with-different-dtypes",
    "href": "lecture-4-reveal.html#creating-arrays-with-different-dtypes",
    "title": "Introduction to Numpy",
    "section": "Creating arrays with different dtypes",
    "text": "Creating arrays with different dtypes\nWhen creating a NumPy array, NumPy will select what it thinks to be the most appropriate data type. However, we can tell NumPy explicitly what the data type should be with the dtype argument.\nA = np.array([[1, 2], [9, 5]], dtype=np.int8)\nprint(A)\nprint(A.dtype)\n\nA = np.array([[1, 2], [9, 5]], dtype=np.float)\nprint(A)\nprint(A.dtype)\nResults: \n# =&gt; [[1 2]\n# =&gt;  [9 5]]\n# =&gt; int8\n# =&gt; [[1. 2.]\n# =&gt;  [9. 5.]]\n# =&gt; float64"
  },
  {
    "objectID": "lecture-4-reveal.html#changing-dtypes",
    "href": "lecture-4-reveal.html#changing-dtypes",
    "title": "Introduction to Numpy",
    "section": "Changing dtypes",
    "text": "Changing dtypes\nIn some cases, we wish to change the data type of arrays after its creation. For this we use the .astype() method. This method takes a single argument: the data type you wish to change the array to.\nA = np.array([1, 2, 3, 4])\nprint(A.dtype)\nint64"
  },
  {
    "objectID": "lecture-4-reveal.html#section",
    "href": "lecture-4-reveal.html#section",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "We could change it to a float64 array:\nA = A.astype(float)\nprint(A.dtype)\nfloat64"
  },
  {
    "objectID": "lecture-4-reveal.html#section-1",
    "href": "lecture-4-reveal.html#section-1",
    "title": "Introduction to Numpy",
    "section": "",
    "text": "Or float32:\nA = A.astype(np.float32)\nprint(A.dtype)\nfloat32"
  },
  {
    "objectID": "lecture-4-reveal.html#different-ways-of-creating-arrays",
    "href": "lecture-4-reveal.html#different-ways-of-creating-arrays",
    "title": "Introduction to Numpy",
    "section": "Different ways of creating arrays",
    "text": "Different ways of creating arrays\nNumPy also provides us with a number of different functions to create arrays. Instead of doing this:\nA = np.array([[0, 0], [0, 0]])\nWe could instead use the np.zeros function, passing a tuple where each element of the tuple describes how many elements should be made in each dimension:\nA = np.zeros((2,)) # 1 dimensional\nA = np.zeros((2, 2))  # 2 dimensional\nA = np.zeros((2, 5, 5))  # 3 dimensional\nAnother commonly used array creation function is the np.random.randn function. This creates an array where elements are sampled from a normal distribution.\nA = np.random.randn(2, 2)\nprint(A)\nResults: \n# =&gt; [[-0.68213848 -0.44274759]\n# =&gt;  [ 0.6748596   0.64244208]]\nNote the interface is a little different than .zeros, where instead of passing a tuple, we pass multiple arguments to the function.\nIt is also convenient to create arrays with ranges of elements.\nA = np.arange(5, 10) # optional step\nprint(A)\nResults: \n# =&gt; [5 6 7 8 9]\nA = np.linspace(5, 10, 20)\nprint(A)\nResults: \n# =&gt; [ 5.          5.26315789  5.52631579  5.78947368  6.05263158  6.31578947\n# =&gt;   6.57894737  6.84210526  7.10526316  7.36842105  7.63157895  7.89473684\n# =&gt;   8.15789474  8.42105263  8.68421053  8.94736842  9.21052632  9.47368421\n# =&gt;   9.73684211 10.        ]\nThere are many more ways to create arrays. Some include:\n\nnp.ones - a matrix of 1’s\nnp.eye - an identity matrix\nnp.diag - create a matrix with supplied elements across the diagonal\nnp.fromfunction - load elements from the return of a function\nnp.fromfile - load elements from a data file\n\nThough, the best resource for understanding is NumPy’s own documentation on the subject: https://numpy.org/doc/stable/user/basics.creation.html"
  },
  {
    "objectID": "lecture-4-reveal.html#slicing-numpy-arrays",
    "href": "lecture-4-reveal.html#slicing-numpy-arrays",
    "title": "Introduction to Numpy",
    "section": "Slicing NumPy arrays",
    "text": "Slicing NumPy arrays\nIn native Python, when we have a ‘matrix’ like data structure (just a list of lists), and we want to access a particular element from this matrix, we have to do something like:\nA = [[1, 2], [3, 4]]\nprint(A[1][0])\nResults: \n# =&gt; 3\nHowever, in NumPy, we seperate the indexes by comma:\nA = np.array([[1, 2], [3, 4]])\nprint(A[1, 0])\nResults: \n# =&gt; 3\nIf we wanted to get all elements from the 2nd column we would use the : notation. For example:\nA = np.array([[1, 2], [3, 4]])\nprint(A[:, 1])\nResults: \n# =&gt; [2 4]\nLikewise, all elements from the 2nd row:\nprint(A[1, :])\nResults: \n# =&gt; [3 4]\nNote that when we slice an array, we are not copying the elements:\nA = np.array([[1, 2], [3, 4]])\nb = A[:, 1]\n\nb[0] = 10\n\nprint(A)\nResults: \n# =&gt; [[ 1 10]\n# =&gt;  [ 3  4]]\nAny modification you make to the b variable will also affect A. For that we must use .copy()\nA = np.array([[1, 2], [3, 4]])\nb = A[:, 1].copy()\n...\nIf we have a multi-dimensional array, to which we wish to index on the final dimension, one way to achieve this is by doing the following:\nA = np.random.randn(10, 2, 5, 4)  # our array to slice\nA[:, :, :, 1:2]  # slice on the last dimension\nThis can get pretty tedious the more that the number of dimensions increases. But! we have one syntactical shortcut at our disposal: the ellipses ‘…’. Using the ellipses in place of the many ‘:’ slices on each dimension, we’re telling NumPy to just take all elements from the prior dimensions. For example:\nA[..., 1:2]  # same slice on the last dimension"
  },
  {
    "objectID": "lecture-4-reveal.html#boolean-indexing",
    "href": "lecture-4-reveal.html#boolean-indexing",
    "title": "Introduction to Numpy",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nNumPy arrays can also be composed of boolean elements\nA = np.array([[1, -1], [0, 5]])\nprint(A &gt; 0)\nResults: \n# =&gt; [[ True False]\n# =&gt;  [False  True]]\nAnd we can also use boolean elements to help with indexing:\nvalues_above_zero = A[A &gt; 0]\nprint(values_above_zero)\nResults: \n# =&gt; [1 5]\nTherefore we can apply computations to only part of the array using this indexing feature:\nmask = A &gt; 0\nA[mask] = A[mask] + 10\nprint(A)\nResults: \n# =&gt; [[11 -1]\n# =&gt;  [ 0 15]]"
  },
  {
    "objectID": "lecture-4-reveal.html#reshape",
    "href": "lecture-4-reveal.html#reshape",
    "title": "Introduction to Numpy",
    "section": "Reshape",
    "text": "Reshape\nAfter an array has been created, we can modify its structure/shape using various functions. The first we shall look at is .reshape. For example, let us create a vector of 4 elements and then reshape it into an array of 2x2 elements. Of course, the new shape of the array must be proportional to the original number of elements: 2x2 elements = 4 elements.\nA = np.arange(1, 5)\n\nmat_A = A.reshape(2, 2)\nprint(mat_A)\nprint(A)  # A is not changed! No need for copy\nResults: \n# =&gt; [[1 2]\n# =&gt;  [3 4]]\n# =&gt; [1 2 3 4]"
  },
  {
    "objectID": "lecture-4-reveal.html#flatten",
    "href": "lecture-4-reveal.html#flatten",
    "title": "Introduction to Numpy",
    "section": "Flatten",
    "text": "Flatten\nIf we wanted to take a 2d array and reshape it into a vector, we could of course use the .reshape function again. But we could also use .flatten.\nflat_A = mat_A.flatten()\nprint(flat_A)\nResults: \n# =&gt; [1 2 3 4]\nWhen specifying the new dimensionality of the reshaped array, -1 is a shortcut to specify the dimensionality to allow reshaping to occur correctly. For example:\nA = np.arange(1, 5)\nprint(A)\n\nprint(A.reshape(2, -1))\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1 2]\n# =&gt;  [3 4]]\nWe’re telling NumPy to create an array with 2 elements on the 1st dimension, and then however many elements on the second dimension."
  },
  {
    "objectID": "lecture-4-reveal.html#add-a-dimension",
    "href": "lecture-4-reveal.html#add-a-dimension",
    "title": "Introduction to Numpy",
    "section": "Add a dimension",
    "text": "Add a dimension\nWe can add and remove dimensions using .expand_dims and .squeeze, respectively.\nprint(A)\nprint(np.expand_dims(A, 1))\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1]\n# =&gt;  [2]\n# =&gt;  [3]\n# =&gt;  [4]]\nWe are taking a vector and adding a dimension. Note that we have to use np.expand_dims passing the object we want to expand and not A.expand_dims.\nWe can use an indexing trick with None to do the expansion in just the same way:\nprint(A)\nprint(A[:, None])\nResults: \n# =&gt; [1 2 3 4]\n# =&gt; [[1]\n# =&gt;  [2]\n# =&gt;  [3]\n# =&gt;  [4]]\nWhere None indicates to NumPy where we want to add the new dimension."
  },
  {
    "objectID": "lecture-4-reveal.html#remove-a-dimension",
    "href": "lecture-4-reveal.html#remove-a-dimension",
    "title": "Introduction to Numpy",
    "section": "Remove a dimension",
    "text": "Remove a dimension\nIf we want to instead remove a dimension, we can use .squeeze()\nprint(A[:, None].squeeze(1))\nResults: \n# =&gt; [1 2 3 4]\nWe are removing the 2nd dimension, but note that the elements must be singletons. So you cannot squeeze a 2x2 array."
  },
  {
    "objectID": "lecture-4-reveal.html#matrix-transpose",
    "href": "lecture-4-reveal.html#matrix-transpose",
    "title": "Introduction to Numpy",
    "section": "Matrix transpose",
    "text": "Matrix transpose\nAnother useful feature is the matrix transpose:\nprint(mat_A)\n\nprint(mat_A.transpose())\nResults: \n# =&gt; [[1 2]\n# =&gt;  [3 4]]\n# =&gt; [[1 3]\n# =&gt;  [2 4]]\nor even:\n    print(mat_A.T)\nResults: \n# =&gt; [[1 3]\n# =&gt;  [2 4]]"
  },
  {
    "objectID": "lecture-4-reveal.html#composing-arrays",
    "href": "lecture-4-reveal.html#composing-arrays",
    "title": "Introduction to Numpy",
    "section": "Composing arrays",
    "text": "Composing arrays\nIf we have multiple arrays we want to ‘join’ together, we can use np.hstack for horizontally joining, or np.vstack for vertically joining arrays. Note the dimensions must match in the direction your stacking.\nA = np.array([1, 2, 3])\nB = np.array([4, 5, 6])\n\nprint(np.hstack([A, B]))\n[1 2 3 4 5 6]\nprint(np.vstack([A, B]))\nResults: \n# =&gt; [[1 2 3]\n# =&gt;  [4 5 6]]\nhstack and vstack can be useful when the required output shape is simply defined. However, there is a more general function - np.concatenate - that will be more often useful to us.\nprint(np.concatenate([A, B], axis=0))\n[1 2 3 4 5 6]\nHere we see that we can achieve the same result as np.hstack using concatenate. Notice also that there is a second argument to the concatenate function: the dimension upon which the concatenation will take place.\nhttps://numpy.org/doc/stable/reference/generated/numpy.concatenate.html"
  },
  {
    "objectID": "lecture-4-reveal.html#arithmetic-operations-1",
    "href": "lecture-4-reveal.html#arithmetic-operations-1",
    "title": "Introduction to Numpy",
    "section": "Arithmetic Operations",
    "text": "Arithmetic Operations\nWe have already seen some basic examples of arithmetic operations in NumPy. But its worth looking at these in detail.\nOne of the best reasons to use NumPy is that the computations are vectorized and can be broadcast. We’ll see examples of what these mean.\nA = np.array([1, 2, 3])\nB = np.array([[1, 2, 3],\n                [4, 5, 6]])\n\nprint(A * B)\nResults: \n# =&gt; [[ 1  4  9]\n# =&gt;  [ 4 10 18]]\nWe can perform vector and matrix arithmetic using Python’s infix operators like +, *, etc.\nWhen we perform arithmetic operations, NumPy will convert the data into arrays for us. While this can help, its not best practice for vectors and matrices, for scalars it will be fine.\nA = [1, 2, 3]\n\nprint(A * B)\nResults: \n# =&gt; [[ 1  4  9]\n# =&gt;  [ 4 10 18]]"
  },
  {
    "objectID": "lecture-4-reveal.html#broadcasting",
    "href": "lecture-4-reveal.html#broadcasting",
    "title": "Introduction to Numpy",
    "section": "Broadcasting",
    "text": "Broadcasting\nWhen we are working with singletons or scalar values, NumPy will automatically perform the broadcasting for us. So for example, if we want to double each element of an array:\nprint(B * 2)\nResults: \n# =&gt; [[ 2  4  6]\n# =&gt;  [ 8 10 12]]\nNumPy will automatically broadcast the scalar 2 to every element of the shape and size of B."
  },
  {
    "objectID": "lecture-4-reveal.html#comparison-with-functions",
    "href": "lecture-4-reveal.html#comparison-with-functions",
    "title": "Introduction to Numpy",
    "section": "Comparison with Functions",
    "text": "Comparison with Functions\nNumPy provides, in many cases, both infix and function operations.\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nInfix\n\n\nFunction\n\n\n\n\n\n\nAddition\n\n\n+\n\n\nnp.add\n\n\n\n\nSubtraction\n\n\n-\n\n\nnp.subtract\n\n\n\n\nMultiplication\n\n\n*\n\n\nnp.multiply\n\n\n\n\nDivision\n\n\n/\n\n\nnp.divide\n\n\n\n\nMatrix Multiplication\n\n\n@\n\n\nnp.matmul\n\n\n\n\nPower\n\n\n**\n\n\nnp.power\n\n\n\n\nCos/Tan/Sin\n\n\n \n\n\nnp.cos, np.tan, np.sin\n\n\n\n\nSquare root\n\n\n \n\n\nnp.sqrt\n\n\n\n\nExponential, Logarithm\n\n\n \n\n\nnp.exp, np.log\n\n\n\n\n\nhttps://numpy.org/doc/stable/reference/routines.math.html"
  },
  {
    "objectID": "lecture-4-reveal.html#more-complex-operations",
    "href": "lecture-4-reveal.html#more-complex-operations",
    "title": "Introduction to Numpy",
    "section": "More complex operations",
    "text": "More complex operations\nThere are a number of different operations one can perform on a matrix. Such as the dot product of two matrices:\nA = np.array([1, 2])\nB = np.array([[1, 2], [3, 4]])\nprint(np.dot(A, B))\nResults: \n# =&gt; [ 7 10]\nThe inner product:\nprint(np.inner(A, B))\nResults: \n# =&gt; [ 5 11]\nOne mystical function is the einsum function. This function can effectively replace other functions like dot and inner but it takes some understanding on how it works. einsum is the application of Einstein Summation, a succinct method of describing the multiplication between matrices. Lets first look at an example of the outer product:\nprint(np.einsum('i,ij-&gt;j', A, B))\nResults: \n# =&gt; [ 7 10]\nOr the inner product:\nprint(np.einsum('j,ij-&gt;i', A, B))\nResults: \n# =&gt; [ 5 11]\nIn einsum we are giving a letter for each dimension of each array we pass to the function.\nSo with: 'i,ij-&gt;j' for the inner product of matrices A and B, we are saying that the first dimension of A (its only dimension) is labelled i, while for B the dimensions are labelled as i and j respectively. The labels that exist in both sequences are summed over.\nEinsum can take a little time to fully understand and appreciate, but it can be a very powerful function with a very succinct syntax.\nhttps://www.youtube.com/watch?v=CLrTj7D2fLM - Khan Academy - Einstein Summation Convention"
  },
  {
    "objectID": "lecture-4-reveal.html#vectorizing-a-function",
    "href": "lecture-4-reveal.html#vectorizing-a-function",
    "title": "Introduction to Numpy",
    "section": "Vectorizing a function",
    "text": "Vectorizing a function\nLets say you have some function that computes the square of a number:\ndef my_square(x):\n    return x**2\n\nprint(my_square(4))\nResults: \n# =&gt; 16\nAs the function is simple, it takes one argument and returns one argument, we can pass a NumPy array and will get the correct result.\nA = np.arange(1, 10)\nprint(my_square(A))\nResults: \n# =&gt; [ 1  4  9 16 25 36 49 64 81]\nHowever, if the function is more complicated, it will not work.\ndef myfunc(a, b):\n    \"Return a-b if a&gt;b, otherwise return a+b\"\n    if a &gt; b:\n        return a - b\n    else:\n        return a + b\n\nprint(myfunc(A, 2))\nResults: \n# =&gt; Traceback (most recent call last):\n# =&gt;   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n# =&gt;   File \"/tmp/pyqVNaN0\", line 3, in &lt;module&gt;\n# =&gt;   File \"/tmp/babel-jHhWMz/python-nKlyRH\", line 8, in &lt;module&gt;\n# =&gt;     print(myfunc(A, 2))\n# =&gt;   File \"/tmp/babel-jHhWMz/python-nKlyRH\", line 3, in myfunc\n# =&gt;     if a &gt; b:\n# =&gt; ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nTo allow us to use this function over an array, we can use the np.vectorize function to create a new function, which applies myfunc over each element.\nvfunc = np.vectorize(myfunc)\nprint(vfunc(A, 2))\nResults: \n# =&gt; [3 4 1 2 3 4 5 6 7]\nHere we pass the function we want to vectorize myfunc to the np.vectorize function. The return of this function is another function!"
  },
  {
    "objectID": "lecture-2.html",
    "href": "lecture-2.html",
    "title": "Errors & Object Oriented Programming",
    "section": "",
    "text": "When programming, its good to be defensive and handle errors gracefully. For example, if you’re creating a program, that as part of its process, reads from a file, its possible that this file may not exist at the point the program tries to read it. If it doesn’t exist, the program will crash giving an error such as: FileNotfoundError.\nPerhaps this file is non-essential to the operation of the program, and we can continue without the file. In these cases, we will want to appropriately catch the error to prevent it from stopping Python.\n\n\nTry-catches are keywords that introduce a scope where the statements are executed, and if an error (of a certain type IndexError in this example) occurs, different statements could be executed.\nIn this example, we are trying to access an element in a list using an index larger than the length of the list. This will produce an IndexError. Instead of exiting Python with an error, however, we can catch the error, and print a string.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError:\n        print(\"Couldn't access element\")\nResults: \n# =&gt; Couldn't access element\n\n\n\nIf we wanted to include the original error message in the print statement, we can use the form:\n    except &lt;error&gt; as &lt;variable&gt;\nThis provides us with an variable containing the original error that we can use later on in the try-catch form.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError as e:\n        print(f\"Couldn't access elements at index beacuse: {e}\")\nResults: \n# =&gt; Couldn't access elements at index beacuse: list index out of range\n\n\n\nThere are numerous types of errors that could occur in a Python. Here are just some of the most common.\n\nIndexError – Raised when a sequence subscript is out of range.\nValueError – Raised when an operation or function receives an argument that has the right type but an inappropriate value\nAssertionError – Raised when an assert statement fails.\nFileNotFoundError – Raised when a file or directory is requested but doesn’t exist.\n\nThe full list of exceptions in Python 3 can be found at: https://docs.python.org/3/library/exceptions.html\n\n\n\nOne of the previous errors (AssertionError) occurs when an assert statement fails. Assert is a keyword provided to test some condition and raise an error if the condition is false. It typically requires less code than an if-statement that raises an error, so they might be useful for checking the inputs to functions, for example:\n    def my_divide(a, b):\n        assert b != 0\n        return a / b\n    \n    my_divide(1, 2)\n    my_divide(1, 0)\nHere we are checking that the divisor is not a 0, in which case division is not defined."
  },
  {
    "objectID": "lecture-2.html#try-catch",
    "href": "lecture-2.html#try-catch",
    "title": "Errors & Object Oriented Programming",
    "section": "",
    "text": "Try-catches are keywords that introduce a scope where the statements are executed, and if an error (of a certain type IndexError in this example) occurs, different statements could be executed.\nIn this example, we are trying to access an element in a list using an index larger than the length of the list. This will produce an IndexError. Instead of exiting Python with an error, however, we can catch the error, and print a string.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError:\n        print(\"Couldn't access element\")\nResults: \n# =&gt; Couldn't access element"
  },
  {
    "objectID": "lecture-2.html#capturing-messages",
    "href": "lecture-2.html#capturing-messages",
    "title": "Errors & Object Oriented Programming",
    "section": "",
    "text": "If we wanted to include the original error message in the print statement, we can use the form:\n    except &lt;error&gt; as &lt;variable&gt;\nThis provides us with an variable containing the original error that we can use later on in the try-catch form.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError as e:\n        print(f\"Couldn't access elements at index beacuse: {e}\")\nResults: \n# =&gt; Couldn't access elements at index beacuse: list index out of range"
  },
  {
    "objectID": "lecture-2.html#types-of-exceptions",
    "href": "lecture-2.html#types-of-exceptions",
    "title": "Errors & Object Oriented Programming",
    "section": "",
    "text": "There are numerous types of errors that could occur in a Python. Here are just some of the most common.\n\nIndexError – Raised when a sequence subscript is out of range.\nValueError – Raised when an operation or function receives an argument that has the right type but an inappropriate value\nAssertionError – Raised when an assert statement fails.\nFileNotFoundError – Raised when a file or directory is requested but doesn’t exist.\n\nThe full list of exceptions in Python 3 can be found at: https://docs.python.org/3/library/exceptions.html"
  },
  {
    "objectID": "lecture-2.html#assertions",
    "href": "lecture-2.html#assertions",
    "title": "Errors & Object Oriented Programming",
    "section": "",
    "text": "One of the previous errors (AssertionError) occurs when an assert statement fails. Assert is a keyword provided to test some condition and raise an error if the condition is false. It typically requires less code than an if-statement that raises an error, so they might be useful for checking the inputs to functions, for example:\n    def my_divide(a, b):\n        assert b != 0\n        return a / b\n    \n    my_divide(1, 2)\n    my_divide(1, 0)\nHere we are checking that the divisor is not a 0, in which case division is not defined."
  },
  {
    "objectID": "lecture-2.html#introduction-to-classes",
    "href": "lecture-2.html#introduction-to-classes",
    "title": "Errors & Object Oriented Programming",
    "section": "Introduction to classes",
    "text": "Introduction to classes\nA class is some representation (can be abstract) of an object. Classes can be used to create some kind of structure that can be manipulated and changed, just like the ways you’ve seen with lists, dictionaries, etc.\nClasses allow us to perform Object-oriented Programming (OOP), where we represent concepts by classes.\nBut to properly understand how classes work, and why we would want to use them, we should take a look at some examples."
  },
  {
    "objectID": "lecture-2.html#basic-syntax",
    "href": "lecture-2.html#basic-syntax",
    "title": "Errors & Object Oriented Programming",
    "section": "Basic syntax",
    "text": "Basic syntax\nWe’re going to start off with the very basic syntax, and build up some more complex classes.\nTo create a class, we use the class keyword, and give our new class a name. This introduces a new scope in Python, the scope of the class.\nTypically, the first thing we shall see in the class is the __init__ function.\n    class &lt;name_of_class&gt;:\n        def __init__(self, args*):\n            &lt;body&gt;"
  },
  {
    "objectID": "lecture-2.html#init-method",
    "href": "lecture-2.html#init-method",
    "title": "Errors & Object Oriented Programming",
    "section": "Init method",
    "text": "Init method\nThe __init__ function is a function that gets called automatically as soon as a class is made. This init function can take many arguments, but must always start with a self.\nIn this example, we are creating a class that represents an x, y coordinate. We’ve called this class Coordinate, and we’ve defined our init function to take an x and y values when the class is being created.\nNote its more typical to use titlecase when specifying the class name. So when reading code its easy to see when you’re creating a class versus calling a function. You should use this style.\n    class Coordinate:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y"
  },
  {
    "objectID": "lecture-2.html#instantiating",
    "href": "lecture-2.html#instantiating",
    "title": "Errors & Object Oriented Programming",
    "section": "Instantiating",
    "text": "Instantiating\nTo create an instance of this class, call the name of the class as you would a function, and pass any parameters you’ve defined in the init function.\nIn this example, we are creating a new vector using Vector(...) and we’re passing the x and y coordinate.\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    \n    point_1 = Vector(5, 2)"
  },
  {
    "objectID": "lecture-2.html#class-variables",
    "href": "lecture-2.html#class-variables",
    "title": "Errors & Object Oriented Programming",
    "section": "Class variables",
    "text": "Class variables\nIn the previous example, we’ve been creating a class variables by using self.&lt;variable_name&gt;. This is telling Python this class should have a variable of this name.\nIt allows then to reference the variable when working with the class.\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n            self.length = self.x + self.y\n    \n    point_1 = Vector(5, 2)\n    print(point_1.x)\n    print(point_1.y)\n    print(point_1.length)\nResults: \n# =&gt; 5\n# =&gt; 2\n# =&gt; 7"
  },
  {
    "objectID": "lecture-2.html#class-methods",
    "href": "lecture-2.html#class-methods",
    "title": "Errors & Object Oriented Programming",
    "section": "Class Methods",
    "text": "Class Methods\nA class can have many methods associated with it. To create a new method, we create a function within the scope of the class, remember that the first parameter of the function should be self.\nEven in these functions, we can refer to our self.x and self.y within this new function.\nYou’ll notice that to call this function, we using the .length() method similar to how we’ve worked with strings/lists/etc. This is because in Python, everything is an object!\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def length(self):\n            return self.x + self.y\n    \n    \n    my_point = Vector(2, 5)\n    print(my_point.length())\nResults: \n# =&gt; 7"
  },
  {
    "objectID": "lecture-2.html#dunder-methods",
    "href": "lecture-2.html#dunder-methods",
    "title": "Errors & Object Oriented Programming",
    "section": "dunder-methods",
    "text": "dunder-methods\nWhile we could, for example, create a function called .print(), sometimes we would like to use the in built functions like print(). When creating a class, there is a set of dunder-methods (double-under to reference the two ‘__’ characters either side of the function name).\nOne of these dunder-methods is __repr__, which allows us to specify how the object looks when its printed.\n    class OldVector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    print(OldVector(2, 5))\n    \n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def __repr__(self):\n            return f\"Vector({self.x}, {self.y})\"\n    \n    print(Vector(2, 5))\nResults: \n# =&gt; &lt;__main__.OldVector object at 0x7f658721e250&gt;\n# =&gt; Vector(2, 5)\nThere are many more dunder-methods you should know when creating classes. We shall go through:\n\n__len__ – specify how the length of the class should be computed.\n__getitem__ – how to index over the class\n__call__ – how to use the class like a function\n__iter__ – what to do when iteration starts\n__next__ – what to do at the next step of the iteration"
  },
  {
    "objectID": "lecture-2.html#len__",
    "href": "lecture-2.html#len__",
    "title": "Errors & Object Oriented Programming",
    "section": "__len__",
    "text": "__len__\nThe __len__ function allows us to specify how the len() function acts on the class. Take this hypothetical dataset. We create a __len__ function that returns the length of the unique elements in the dataset.\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __len__(self):\n            \"\"\"Return the length of unique elements\"\"\"\n            return len(set(self.data))\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(len(data))\nResults: \n# =&gt; 4"
  },
  {
    "objectID": "lecture-2.html#getitem__",
    "href": "lecture-2.html#getitem__",
    "title": "Errors & Object Oriented Programming",
    "section": "__getitem__",
    "text": "__getitem__\nNext __getitem__ allows us to index over a class. This new function must include self and a variable to pass the index. Here I’ve used idx. In this function I am simply indexing on the on the classes self.data.\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __getitem__(self, idx):\n            return self.data[idx]\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(data[2])\nResults: \n# =&gt; 3"
  },
  {
    "objectID": "lecture-2.html#call__",
    "href": "lecture-2.html#call__",
    "title": "Errors & Object Oriented Programming",
    "section": "__call__",
    "text": "__call__\nIn a small number of cases, it is nice to use the class just like a function. This is what __call__ allows us to do. In this function we specify what should happen when class is ‘called’ like a function. In this simple example, we are creating a function that prints the type of food being used as a parameter to the function.\n    class Jaguar:\n        def __call__(self, food):\n            print(f\"The jaguar eats the {food}.\")\n    \n    food = \"apple\"\n    animal = Jaguar()\n    \n    animal(food)\nResults: \n# =&gt; The jaguar eats the apple."
  },
  {
    "objectID": "lecture-2.html#iter__-and-__next__",
    "href": "lecture-2.html#iter__-and-__next__",
    "title": "Errors & Object Oriented Programming",
    "section": "__iter__ and __next__",
    "text": "__iter__ and __next__\n__iter__ and __next__ allow us to make our class iterable, i.e. we can use it in a for loop for example.\nThe __iter__ function should define what happens when we start the iteration, and __next__ defines what happens at every step of the iteration.\nLet’s take a look at an example where we have an iterable set of prime numbers.\n    class Primes:\n        def __init__(self):\n            self.primes = [2, 3, 5, 7, 11]\n    \n        def __iter__(self):\n            self.idx = 0\n            return self\n    \n        def __len__(self):\n            return len(self.primes)\n    \n        def __next__(self):\n            if self.idx &lt; len(self):\n                item = self.primes[self.idx]\n                self.idx += 1\n                return item\n            else:\n                raise StopIteration\nAnd now we can iterate over this class\n    prime_numbers = Primes()\n    \n    for prime_number in prime_numbers:\n        print(prime_number)\nResults: \n# =&gt; 2\n# =&gt; 3\n# =&gt; 5\n# =&gt; 7\n# =&gt; 11"
  },
  {
    "objectID": "lecture-2.html#inheritance",
    "href": "lecture-2.html#inheritance",
    "title": "Errors & Object Oriented Programming",
    "section": "Inheritance",
    "text": "Inheritance\nOne special thing about OOP is that its normally designed to provide inheritance – this is true in Python. Inheritance is where you have a base class, and other classes inherit from this base class. This means that the class that inherits from the base class has access to the same methods and class variables. In some cases, it can override some of these features.\nLet’s take a look an example.\n    class Animal:\n        def growl(self):\n            print(\"The animal growls\")\n    \n        def walk(self):\n            raise NotImplementError\nHere we have created a simple class called Animal, that has two functions, one of which will raise an error if its called.\nWe can inherit from this Animal class by placing our base class in () after the new class name.\nHere we are creating two classes, Tiger and Duck. Both of these new classes inherit from Animal. Also, both of these classes are overriding the walk functions. But they are not creating a growl method themselves.\n    class Tiger(Animal):\n        def walk(self):\n            print(\"The Tiger walks through the jungle\")\n    \n    class Duck(Animal):\n        def walk(self):\n            print(\"The Duck walks through the jungle\")\nLook at what happens when we create instances of these classes, and call the functions. First we see that the correct method has been called. I.e. for the duck class, the correct walk method was called.\n    first_animal = Tiger()\n    second_animal = Duck()\n    \n    first_animal.walk()\n    second_animal.walk()\nResults: \n# =&gt; The Tiger walks through the jungle\n# =&gt; The Duck walks through the jungle\nBut what happens if we call the .growl() method?\n    first_animal.growl()\n    second_animal.growl()\nResults: \n# =&gt; The animal growls\n# =&gt; The animal growls\nWe see that it still works. Even though both Duck and Tiger didn’t create a .growl() method, it inherited it from the base class Animal. This works for class methods and class variables."
  },
  {
    "objectID": "lecture-2.html#adding-data",
    "href": "lecture-2.html#adding-data",
    "title": "Errors & Object Oriented Programming",
    "section": "Adding data",
    "text": "Adding data\nWe will want to include a function to add data to our database.\nCreate a class method called add, that takes three arguments (in addition to self of course), the title, the author, and the release date.\nThis add function adds the new book entry to the end of data. Populate this database with the following information.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1879"
  },
  {
    "objectID": "lecture-2.html#locating-a-book",
    "href": "lecture-2.html#locating-a-book",
    "title": "Errors & Object Oriented Programming",
    "section": "Locating a book",
    "text": "Locating a book\nCreate a class method called locate by title that takes the title of the book to look up, and returns the dictionary of all books that have this title. Unlike last time, we don’t need to pass the data as an argument, as its contained within the class."
  },
  {
    "objectID": "lecture-2.html#updating-our-database",
    "href": "lecture-2.html#updating-our-database",
    "title": "Errors & Object Oriented Programming",
    "section": "Updating our database",
    "text": "Updating our database\nCreate a class method called update that takes 4 arguments:, 1) the key of the value we want to update 2) the value we want to update it to 3) the key we want to check to find out if we have the correct book and 4) the value of the key to check if we have the correct book.\n    db.update(key=\"release_date\", value=1979, where_key=\"title\",\n              where_value=\"Hitchhikers Guide to the Galaxy\")\nUse this to fix the release data of the Hitchhiker’s book."
  },
  {
    "objectID": "lecture-2.html#printed-representation",
    "href": "lecture-2.html#printed-representation",
    "title": "Errors & Object Oriented Programming",
    "section": "Printed representation",
    "text": "Printed representation\nUsing the __str__ dunder-method (this is similar to __repr__ as we saw before), create a function that prints out a formatted representation of the entire database as a string. Some of the output should look like:\nLibrary System\n--------------\n\nEntry 1:\n- Name: Moby Dick\n- Author: Herman Melville\n- Release Date: 1851\n..."
  },
  {
    "objectID": "lecture-2.html#extending-our-oop-usage",
    "href": "lecture-2.html#extending-our-oop-usage",
    "title": "Errors & Object Oriented Programming",
    "section": "Extending our OOP usage",
    "text": "Extending our OOP usage\nSo far we’ve used a list of dictionaries. One issue with this is that there is no constraints on the keys we can use. This will certainly create problems if certain keys are missing.\nInstead of using dictionaries. We can create another class called Book that will take three arguments when it is initialised: name, author, and release_date. The init function should initialise three class variables to save this information.\nModify the database to, instead of working with a list of dictionaries, work with a list of Book objects."
  },
  {
    "objectID": "lecture-2.html#printed-representation-challenge.",
    "href": "lecture-2.html#printed-representation-challenge.",
    "title": "Errors & Object Oriented Programming",
    "section": "Printed representation – challenge.",
    "text": "Printed representation – challenge.\nImprove upon the printed representation of the last exercise but instead of bulleted lists, use formatted tables using f-string formatting (https://zetcode.com/python/fstring/).\nThe output should look like this:\nLibrary System\n--------------\n\n| Name           | Author           | Release Data |\n|----------------|------------------|--------------|\n| Moby Dick      | Herman Melville  |         1851 |\n...\nNotice how Release date is right justified, while Name and Author are left justified."
  },
  {
    "objectID": "lecture-2-reveal.html#try-catch",
    "href": "lecture-2-reveal.html#try-catch",
    "title": "Errors & Object Oriented Programming",
    "section": "Try-catch",
    "text": "Try-catch\nTry-catches are keywords that introduce a scope where the statements are executed, and if an error (of a certain type IndexError in this example) occurs, different statements could be executed.\nIn this example, we are trying to access an element in a list using an index larger than the length of the list. This will produce an IndexError. Instead of exiting Python with an error, however, we can catch the error, and print a string.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError:\n        print(\"Couldn't access element\")\nResults: \n# =&gt; Couldn't access element"
  },
  {
    "objectID": "lecture-2-reveal.html#capturing-messages",
    "href": "lecture-2-reveal.html#capturing-messages",
    "title": "Errors & Object Oriented Programming",
    "section": "Capturing messages",
    "text": "Capturing messages\nIf we wanted to include the original error message in the print statement, we can use the form:\n    except &lt;error&gt; as &lt;variable&gt;\nThis provides us with an variable containing the original error that we can use later on in the try-catch form.\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError as e:\n        print(f\"Couldn't access elements at index beacuse: {e}\")\nResults: \n# =&gt; Couldn't access elements at index beacuse: list index out of range"
  },
  {
    "objectID": "lecture-2-reveal.html#types-of-exceptions",
    "href": "lecture-2-reveal.html#types-of-exceptions",
    "title": "Errors & Object Oriented Programming",
    "section": "Types of exceptions",
    "text": "Types of exceptions\nThere are numerous types of errors that could occur in a Python. Here are just some of the most common.\n\nIndexError – Raised when a sequence subscript is out of range.\nValueError – Raised when an operation or function receives an argument that has the right type but an inappropriate value\nAssertionError – Raised when an assert statement fails.\nFileNotFoundError – Raised when a file or directory is requested but doesn’t exist.\n\nThe full list of exceptions in Python 3 can be found at: https://docs.python.org/3/library/exceptions.html"
  },
  {
    "objectID": "lecture-2-reveal.html#assertions",
    "href": "lecture-2-reveal.html#assertions",
    "title": "Errors & Object Oriented Programming",
    "section": "Assertions",
    "text": "Assertions\nOne of the previous errors (AssertionError) occurs when an assert statement fails. Assert is a keyword provided to test some condition and raise an error if the condition is false. It typically requires less code than an if-statement that raises an error, so they might be useful for checking the inputs to functions, for example:\n    def my_divide(a, b):\n        assert b != 0\n        return a / b\n    \n    my_divide(1, 2)\n    my_divide(1, 0)\nHere we are checking that the divisor is not a 0, in which case division is not defined."
  },
  {
    "objectID": "lecture-2-reveal.html#introduction-to-classes",
    "href": "lecture-2-reveal.html#introduction-to-classes",
    "title": "Errors & Object Oriented Programming",
    "section": "Introduction to classes",
    "text": "Introduction to classes\nA class is some representation (can be abstract) of an object. Classes can be used to create some kind of structure that can be manipulated and changed, just like the ways you’ve seen with lists, dictionaries, etc.\nClasses allow us to perform Object-oriented Programming (OOP), where we represent concepts by classes.\nBut to properly understand how classes work, and why we would want to use them, we should take a look at some examples."
  },
  {
    "objectID": "lecture-2-reveal.html#basic-syntax",
    "href": "lecture-2-reveal.html#basic-syntax",
    "title": "Errors & Object Oriented Programming",
    "section": "Basic syntax",
    "text": "Basic syntax\nWe’re going to start off with the very basic syntax, and build up some more complex classes.\nTo create a class, we use the class keyword, and give our new class a name. This introduces a new scope in Python, the scope of the class.\nTypically, the first thing we shall see in the class is the __init__ function.\n    class &lt;name_of_class&gt;:\n        def __init__(self, args*):\n            &lt;body&gt;"
  },
  {
    "objectID": "lecture-2-reveal.html#init-method",
    "href": "lecture-2-reveal.html#init-method",
    "title": "Errors & Object Oriented Programming",
    "section": "Init method",
    "text": "Init method\nThe __init__ function is a function that gets called automatically as soon as a class is made. This init function can take many arguments, but must always start with a self.\nIn this example, we are creating a class that represents an x, y coordinate. We’ve called this class Coordinate, and we’ve defined our init function to take an x and y values when the class is being created.\nNote its more typical to use titlecase when specifying the class name. So when reading code its easy to see when you’re creating a class versus calling a function. You should use this style.\n    class Coordinate:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y"
  },
  {
    "objectID": "lecture-2-reveal.html#instantiating",
    "href": "lecture-2-reveal.html#instantiating",
    "title": "Errors & Object Oriented Programming",
    "section": "Instantiating",
    "text": "Instantiating\nTo create an instance of this class, call the name of the class as you would a function, and pass any parameters you’ve defined in the init function.\nIn this example, we are creating a new vector using Vector(...) and we’re passing the x and y coordinate.\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    \n    point_1 = Vector(5, 2)"
  },
  {
    "objectID": "lecture-2-reveal.html#class-variables",
    "href": "lecture-2-reveal.html#class-variables",
    "title": "Errors & Object Oriented Programming",
    "section": "Class variables",
    "text": "Class variables\nIn the previous example, we’ve been creating a class variables by using self.&lt;variable_name&gt;. This is telling Python this class should have a variable of this name.\nIt allows then to reference the variable when working with the class.\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n            self.length = self.x + self.y\n    \n    point_1 = Vector(5, 2)\n    print(point_1.x)\n    print(point_1.y)\n    print(point_1.length)\nResults: \n# =&gt; 5\n# =&gt; 2\n# =&gt; 7"
  },
  {
    "objectID": "lecture-2-reveal.html#class-methods",
    "href": "lecture-2-reveal.html#class-methods",
    "title": "Errors & Object Oriented Programming",
    "section": "Class Methods",
    "text": "Class Methods\nA class can have many methods associated with it. To create a new method, we create a function within the scope of the class, remember that the first parameter of the function should be self.\nEven in these functions, we can refer to our self.x and self.y within this new function.\nYou’ll notice that to call this function, we using the .length() method similar to how we’ve worked with strings/lists/etc. This is because in Python, everything is an object!\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def length(self):\n            return self.x + self.y\n    \n    \n    my_point = Vector(2, 5)\n    print(my_point.length())\nResults: \n# =&gt; 7"
  },
  {
    "objectID": "lecture-2-reveal.html#dunder-methods",
    "href": "lecture-2-reveal.html#dunder-methods",
    "title": "Errors & Object Oriented Programming",
    "section": "dunder-methods",
    "text": "dunder-methods\nWhile we could, for example, create a function called .print(), sometimes we would like to use the in built functions like print(). When creating a class, there is a set of dunder-methods (double-under to reference the two ‘__’ characters either side of the function name).\nOne of these dunder-methods is __repr__, which allows us to specify how the object looks when its printed.\n    class OldVector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    print(OldVector(2, 5))\n    \n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def __repr__(self):\n            return f\"Vector({self.x}, {self.y})\"\n    \n    print(Vector(2, 5))\nResults: \n# =&gt; &lt;__main__.OldVector object at 0x7f658721e250&gt;\n# =&gt; Vector(2, 5)\nThere are many more dunder-methods you should know when creating classes. We shall go through:\n\n__len__ – specify how the length of the class should be computed.\n__getitem__ – how to index over the class\n__call__ – how to use the class like a function\n__iter__ – what to do when iteration starts\n__next__ – what to do at the next step of the iteration"
  },
  {
    "objectID": "lecture-2-reveal.html#len__",
    "href": "lecture-2-reveal.html#len__",
    "title": "Errors & Object Oriented Programming",
    "section": "__len__",
    "text": "__len__\nThe __len__ function allows us to specify how the len() function acts on the class. Take this hypothetical dataset. We create a __len__ function that returns the length of the unique elements in the dataset.\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __len__(self):\n            \"\"\"Return the length of unique elements\"\"\"\n            return len(set(self.data))\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(len(data))\nResults: \n# =&gt; 4"
  },
  {
    "objectID": "lecture-2-reveal.html#getitem__",
    "href": "lecture-2-reveal.html#getitem__",
    "title": "Errors & Object Oriented Programming",
    "section": "__getitem__",
    "text": "__getitem__\nNext __getitem__ allows us to index over a class. This new function must include self and a variable to pass the index. Here I’ve used idx. In this function I am simply indexing on the on the classes self.data.\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __getitem__(self, idx):\n            return self.data[idx]\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(data[2])\nResults: \n# =&gt; 3"
  },
  {
    "objectID": "lecture-2-reveal.html#call__",
    "href": "lecture-2-reveal.html#call__",
    "title": "Errors & Object Oriented Programming",
    "section": "__call__",
    "text": "__call__\nIn a small number of cases, it is nice to use the class just like a function. This is what __call__ allows us to do. In this function we specify what should happen when class is ‘called’ like a function. In this simple example, we are creating a function that prints the type of food being used as a parameter to the function.\n    class Jaguar:\n        def __call__(self, food):\n            print(f\"The jaguar eats the {food}.\")\n    \n    food = \"apple\"\n    animal = Jaguar()\n    \n    animal(food)\nResults: \n# =&gt; The jaguar eats the apple."
  },
  {
    "objectID": "lecture-2-reveal.html#iter__-and-__next__",
    "href": "lecture-2-reveal.html#iter__-and-__next__",
    "title": "Errors & Object Oriented Programming",
    "section": "__iter__ and __next__",
    "text": "__iter__ and __next__\n__iter__ and __next__ allow us to make our class iterable, i.e. we can use it in a for loop for example.\nThe __iter__ function should define what happens when we start the iteration, and __next__ defines what happens at every step of the iteration.\nLet’s take a look at an example where we have an iterable set of prime numbers.\n    class Primes:\n        def __init__(self):\n            self.primes = [2, 3, 5, 7, 11]\n    \n        def __iter__(self):\n            self.idx = 0\n            return self\n    \n        def __len__(self):\n            return len(self.primes)\n    \n        def __next__(self):\n            if self.idx &lt; len(self):\n                item = self.primes[self.idx]\n                self.idx += 1\n                return item\n            else:\n                raise StopIteration\nAnd now we can iterate over this class\n    prime_numbers = Primes()\n    \n    for prime_number in prime_numbers:\n        print(prime_number)\nResults: \n# =&gt; 2\n# =&gt; 3\n# =&gt; 5\n# =&gt; 7\n# =&gt; 11"
  },
  {
    "objectID": "lecture-2-reveal.html#inheritance",
    "href": "lecture-2-reveal.html#inheritance",
    "title": "Errors & Object Oriented Programming",
    "section": "Inheritance",
    "text": "Inheritance\nOne special thing about OOP is that its normally designed to provide inheritance – this is true in Python. Inheritance is where you have a base class, and other classes inherit from this base class. This means that the class that inherits from the base class has access to the same methods and class variables. In some cases, it can override some of these features.\nLet’s take a look an example.\n    class Animal:\n        def growl(self):\n            print(\"The animal growls\")\n    \n        def walk(self):\n            raise NotImplementError\nHere we have created a simple class called Animal, that has two functions, one of which will raise an error if its called.\nWe can inherit from this Animal class by placing our base class in () after the new class name.\nHere we are creating two classes, Tiger and Duck. Both of these new classes inherit from Animal. Also, both of these classes are overriding the walk functions. But they are not creating a growl method themselves.\n    class Tiger(Animal):\n        def walk(self):\n            print(\"The Tiger walks through the jungle\")\n    \n    class Duck(Animal):\n        def walk(self):\n            print(\"The Duck walks through the jungle\")\nLook at what happens when we create instances of these classes, and call the functions. First we see that the correct method has been called. I.e. for the duck class, the correct walk method was called.\n    first_animal = Tiger()\n    second_animal = Duck()\n    \n    first_animal.walk()\n    second_animal.walk()\nResults: \n# =&gt; The Tiger walks through the jungle\n# =&gt; The Duck walks through the jungle\nBut what happens if we call the .growl() method?\n    first_animal.growl()\n    second_animal.growl()\nResults: \n# =&gt; The animal growls\n# =&gt; The animal growls\nWe see that it still works. Even though both Duck and Tiger didn’t create a .growl() method, it inherited it from the base class Animal. This works for class methods and class variables."
  },
  {
    "objectID": "lecture-2-reveal.html#adding-data",
    "href": "lecture-2-reveal.html#adding-data",
    "title": "Errors & Object Oriented Programming",
    "section": "Adding data",
    "text": "Adding data\nWe will want to include a function to add data to our database.\nCreate a class method called add, that takes three arguments (in addition to self of course), the title, the author, and the release date.\nThis add function adds the new book entry to the end of data. Populate this database with the following information.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1879"
  },
  {
    "objectID": "lecture-2-reveal.html#locating-a-book",
    "href": "lecture-2-reveal.html#locating-a-book",
    "title": "Errors & Object Oriented Programming",
    "section": "Locating a book",
    "text": "Locating a book\nCreate a class method called locate by title that takes the title of the book to look up, and returns the dictionary of all books that have this title. Unlike last time, we don’t need to pass the data as an argument, as its contained within the class."
  },
  {
    "objectID": "lecture-2-reveal.html#updating-our-database",
    "href": "lecture-2-reveal.html#updating-our-database",
    "title": "Errors & Object Oriented Programming",
    "section": "Updating our database",
    "text": "Updating our database\nCreate a class method called update that takes 4 arguments:, 1) the key of the value we want to update 2) the value we want to update it to 3) the key we want to check to find out if we have the correct book and 4) the value of the key to check if we have the correct book.\n    db.update(key=\"release_date\", value=1979, where_key=\"title\",\n              where_value=\"Hitchhikers Guide to the Galaxy\")\nUse this to fix the release data of the Hitchhiker’s book."
  },
  {
    "objectID": "lecture-2-reveal.html#printed-representation",
    "href": "lecture-2-reveal.html#printed-representation",
    "title": "Errors & Object Oriented Programming",
    "section": "Printed representation",
    "text": "Printed representation\nUsing the __str__ dunder-method (this is similar to __repr__ as we saw before), create a function that prints out a formatted representation of the entire database as a string. Some of the output should look like:\nLibrary System\n--------------\n\nEntry 1:\n- Name: Moby Dick\n- Author: Herman Melville\n- Release Date: 1851\n..."
  },
  {
    "objectID": "lecture-2-reveal.html#extending-our-oop-usage",
    "href": "lecture-2-reveal.html#extending-our-oop-usage",
    "title": "Errors & Object Oriented Programming",
    "section": "Extending our OOP usage",
    "text": "Extending our OOP usage\nSo far we’ve used a list of dictionaries. One issue with this is that there is no constraints on the keys we can use. This will certainly create problems if certain keys are missing.\nInstead of using dictionaries. We can create another class called Book that will take three arguments when it is initialised: name, author, and release_date. The init function should initialise three class variables to save this information.\nModify the database to, instead of working with a list of dictionaries, work with a list of Book objects."
  },
  {
    "objectID": "lecture-2-reveal.html#printed-representation-challenge.",
    "href": "lecture-2-reveal.html#printed-representation-challenge.",
    "title": "Errors & Object Oriented Programming",
    "section": "Printed representation – challenge.",
    "text": "Printed representation – challenge.\nImprove upon the printed representation of the last exercise but instead of bulleted lists, use formatted tables using f-string formatting (https://zetcode.com/python/fstring/).\nThe output should look like this:\nLibrary System\n--------------\n\n| Name           | Author           | Release Data |\n|----------------|------------------|--------------|\n| Moby Dick      | Herman Melville  |         1851 |\n...\nNotice how Release date is right justified, while Name and Author are left justified."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming Level-up",
    "section": "",
    "text": "Welcome to the Programming Level-up Course. In this series of lectures, we will cover everything we need to be able to program in a Linux-based environment, and use the high performance computers (also called cluster/supercomputers) to run experiments.\n\n\nYou can find my personal page over at: https://pageperso.lis-lab.fr/jay.morgan/\nAs we progress through the lectures, I will also make the course publicly available. These lectures will be hosted at: https://pageperso.lis-lab.fr/jay.morgan/teaching.html in a variety of formats (i.e. PDF, HTML).\nIf you have any questions please email me directly. My email address is jay.morgan@univ-tln.fr. Other modes of contact can be found on my personal website listed above.\n\n\n\nThis course aims to deliver everything you need. If you attend each lecture, you will know what you need for the following lectures. Despite this design, however, I have included a list of additional resources below. These resources are optional, but they will take you beyond what you’re taught in these sessions and enable you to become a Programming Master!\nThere is nothing like a good book to learn from. They are usually rich in content, but also provide reasonable enough depth to the subject matter to not only learn how things work, but also why they work the way they do.\n\nThink Python: An Introduction to Software Design - Livre d’Allen B. Downey\nNumerical Python: Scientific Computing and Data Science Applications with Numpy, SciPy and Matplotlib - Livre de Robert Johansson.\nClassic Shell Scripting - Livre de Arnold Robbins, Nelson H F Beebe\n\n\n\n\nThe course will cover a broad spectrum of skills used when programming for scientific research. This includes the programming and scripting itself (in our case, Python programming), managing the environment in which we work (i.e. working in a Linux-based environment and managing our projects with version control), and interacting with the supercomputers to perform intensive computations.\n\n\n\nAll of my lectures are available online, including the source code that was used in the lectures, and the source code used to generate the slides themselves. You can find this source code here:\nMirrors:\n\nhttps://git.sr.ht/~jaymorgan/teaching\nhttps://gitlab.com/jaymorgan/teaching.git\nhttps://github.com/jaypmorgan/teaching.git"
  },
  {
    "objectID": "index.html#contact-information",
    "href": "index.html#contact-information",
    "title": "Programming Level-up",
    "section": "",
    "text": "You can find my personal page over at: https://pageperso.lis-lab.fr/jay.morgan/\nAs we progress through the lectures, I will also make the course publicly available. These lectures will be hosted at: https://pageperso.lis-lab.fr/jay.morgan/teaching.html in a variety of formats (i.e. PDF, HTML).\nIf you have any questions please email me directly. My email address is jay.morgan@univ-tln.fr. Other modes of contact can be found on my personal website listed above."
  },
  {
    "objectID": "index.html#resources",
    "href": "index.html#resources",
    "title": "Programming Level-up",
    "section": "",
    "text": "This course aims to deliver everything you need. If you attend each lecture, you will know what you need for the following lectures. Despite this design, however, I have included a list of additional resources below. These resources are optional, but they will take you beyond what you’re taught in these sessions and enable you to become a Programming Master!\nThere is nothing like a good book to learn from. They are usually rich in content, but also provide reasonable enough depth to the subject matter to not only learn how things work, but also why they work the way they do.\n\nThink Python: An Introduction to Software Design - Livre d’Allen B. Downey\nNumerical Python: Scientific Computing and Data Science Applications with Numpy, SciPy and Matplotlib - Livre de Robert Johansson.\nClassic Shell Scripting - Livre de Arnold Robbins, Nelson H F Beebe"
  },
  {
    "objectID": "index.html#what-will-be-taught",
    "href": "index.html#what-will-be-taught",
    "title": "Programming Level-up",
    "section": "",
    "text": "The course will cover a broad spectrum of skills used when programming for scientific research. This includes the programming and scripting itself (in our case, Python programming), managing the environment in which we work (i.e. working in a Linux-based environment and managing our projects with version control), and interacting with the supercomputers to perform intensive computations."
  },
  {
    "objectID": "index.html#source-code",
    "href": "index.html#source-code",
    "title": "Programming Level-up",
    "section": "",
    "text": "All of my lectures are available online, including the source code that was used in the lectures, and the source code used to generate the slides themselves. You can find this source code here:\nMirrors:\n\nhttps://git.sr.ht/~jaymorgan/teaching\nhttps://gitlab.com/jaymorgan/teaching.git\nhttps://github.com/jaypmorgan/teaching.git"
  },
  {
    "objectID": "0.course-introduction.html",
    "href": "0.course-introduction.html",
    "title": "Course Introduction",
    "section": "",
    "text": "Welcome to the Progamming Level-up course. In this series of lectures, we’ll be delving into the broad world of programming for research!"
  },
  {
    "objectID": "0.course-introduction.html#what-why",
    "href": "0.course-introduction.html#what-why",
    "title": "Course Introduction",
    "section": "What…? Why…?",
    "text": "What…? Why…?\n\nProgramming is much more than the act of programming a small script. Even if you’ve programmed before, doing so for a research project requires a lot of rigour to ensure the results you’re reporting are correct, and reproducible.\nThere is so much surrounding the act of programming that it can get a little overwhelming. Things from setting up a programming environment to managing multiple experiments on the supercomputers can involve many languages and understanding of technologies.\nThis course is designed to take you from not being able to program at all to being able to do it comfortably for your research and work."
  },
  {
    "objectID": "0.course-introduction.html#what-is-this-course-going-to-teach-me",
    "href": "0.course-introduction.html#what-is-this-course-going-to-teach-me",
    "title": "Course Introduction",
    "section": "What is this course going to teach me?",
    "text": "What is this course going to teach me?\n\nProgramming with the Python Programming Language.\n\nBasic syntax.\nIntroduction to the basics of object oriented programming (OOP).\nNumerical computing with numpy/pandas/scipy.\n\nDoing your programming in a Linux-based Environment (GNU/Linux) and being comfortable with the organisation of this Linux environment.\n\nSetting up a research (reproducible) environment.\nExecuting experiments.\n\nInteracting with the Super-computers/clusters.\n\nInteraction with SLURM (management of jobs).\n\nTaking the results from a program you’ve created, be able to visualise them and include them in reports/papers.\n\nLaTeX/Markdown.\nPlotting."
  },
  {
    "objectID": "0.course-introduction.html#how-the-course-will-be-delivered",
    "href": "0.course-introduction.html#how-the-course-will-be-delivered",
    "title": "Course Introduction",
    "section": "How the course will be delivered",
    "text": "How the course will be delivered\n\n2/3 hour sessions over the next 2 months.\nThroughout the lecture, there will be small exercises to try out what we’ve learnt. We will go through the answers to these exercises.\nAt the end of the lecture we will have a larger exercise that will become more challenging. These exercises are not marked, but again, just an opportunity to try out what you’ve learnt. The best way to learn how to program is to program."
  },
  {
    "objectID": "0.course-introduction.html#rough-timeline",
    "href": "0.course-introduction.html#rough-timeline",
    "title": "Course Introduction",
    "section": "Rough timeline",
    "text": "Rough timeline\n\n\n\n\n\n\n\n\n\n\nLecture\n\n\nTopic\n\n\nDescription\n\n\n\n\n\n\n1\n\n\nIntroduction\n\n\n\nCourse introduction\n\n\n\n\n\n \n\n\n \n\n\n\nBasic Python programming\n\n\n\n\n\n2\n\n\nPython classes\n\n\n\nIntroduction to OOP\n\n\n\n\n\n3\n\n\nProject management\n\n\n\nCreating/importing modules\n\n\n\n\n\n \n\n\n \n\n\n\nAnaconda/pip\n\n\n\n\n\n4\n\n\nProgramming environments\n\n\n\nPyCharm\n\n\n\n\n\n \n\n\n \n\n\n\nJupyter notebooks\n\n\n\n\n\n5\n\n\nNumerical computing\n\n\n\nNumpy\n\n\n\n\n\n \n\n\n \n\n\n\nScipy\n\n\n\n\n\n6\n\n\nNumerical computing\n\n\n\nPandas\n\n\n\n\n\n \n\n\n \n\n\n\nVisualisations\n\n\n\n\n\n7\n\n\nBasics of GNU/Linux\n\n\n\nUsing the terminal\n\n\n\n\n\n8\n\n\nBash scripting\n\n\n\nBash scripting\n\n\n\n\n\n9\n\n\nHigh performance computing\n\n\n\nSLURM\n\n\n\n\n\n \n\n\n \n\n\n\nSingularity\n\n\n\n\n\n10\n\n\nReporting\n\n\n\nLaTeX\n\n\n\n\n\n \n\n\n \n\n\n\nMarkdown"
  },
  {
    "objectID": "0.course-introduction.html#where-to-find-me",
    "href": "0.course-introduction.html#where-to-find-me",
    "title": "Course Introduction",
    "section": "Where to find me",
    "text": "Where to find me\nMy name is Dr Jay Paul Morgan. I am a researcher work on Deep Learning in Astrophysics.\n\nEmail: jay.morgan@univ-tln.fr\nLecture slides and other contact on my website: https://pageperso.lis-lab.fr/jay.morgan/"
  },
  {
    "objectID": "0.course-introduction.html#setting-up-a-proxy-in-linux-environment-variables",
    "href": "0.course-introduction.html#setting-up-a-proxy-in-linux-environment-variables",
    "title": "Course Introduction",
    "section": "Setting up a proxy in Linux – environment variables",
    "text": "Setting up a proxy in Linux – environment variables\nEnvironment variables are variables that are set in the Linux environment and are used to configure some high-level details in Linux.\nThe command to create/set an environment is:\nexport VARIABLE_NAME=''\nExporting a variable in this way will mean VARIABLE_NAME will be accessible while you’re logged in. Every time you log in you will have to set this variable again."
  },
  {
    "objectID": "0.course-introduction.html#univ-tln-specific-details",
    "href": "0.course-introduction.html#univ-tln-specific-details",
    "title": "Course Introduction",
    "section": "UNIV-TLN specific details",
    "text": "UNIV-TLN specific details\nIn the université de Toulon, you’re required to use the university’s proxy server to access the internet. Therefore, in Linux at least, you will have to tell the system where the proxy server is with an environment variable.\nexport HTTP_PROXY='&lt;username&gt;:&lt;password&gt;@proxy.univ-tln.fr:3128'\nexport HTTPS_PROXY='&lt;username&gt;:&lt;password&gt;@proxy.univ-tln.fr:3128'\nexport FTP_PROXY='&lt;username&gt;:&lt;password&gt;@proxy.univ-tln.fr:3128'\nNOTE: Watch out for special characters in your password! They will have to be URL encoded."
  },
  {
    "objectID": "0.course-introduction.html#setting-up-a-proxy-in-the-.bashrc",
    "href": "0.course-introduction.html#setting-up-a-proxy-in-the-.bashrc",
    "title": "Course Introduction",
    "section": "Setting up a proxy in the .bashrc",
    "text": "Setting up a proxy in the .bashrc\nIf you don’t wish to set the variable every time log in, you should enter the same commands into a .bashrc in your home directory.\nexport HTTP_PROXY='...'\nexport HTTPS_PROXY='...'\nexport FTP_PROXY='...'\nWhen you log in, the .bashrc file will be run and these variables will be set for you."
  },
  {
    "objectID": "lecture-1-reveal.html#a-first-program",
    "href": "lecture-1-reveal.html#a-first-program",
    "title": "Python Introduction",
    "section": "A first program",
    "text": "A first program\nWe’re going to start with the ‘Hello, World’ program that prints Hello, World! to the screen. In python this is as simple as writing:\n    print(\"Hello, World!\")   # this prints: Hello, World!\nResults: \n# =&gt; Hello, World!\nNOTE anything following a # is a comment and is completely ignored by the computer. It is there for you to document your code for others, and most importantly, for yourself."
  },
  {
    "objectID": "lecture-1-reveal.html#running-this-program",
    "href": "lecture-1-reveal.html#running-this-program",
    "title": "Python Introduction",
    "section": "Running this program",
    "text": "Running this program\nBefore we can run this program, we need to save it somewhere. For this, will create a new file, insert this text, and save it as &lt;filename&gt;.py, where &lt;filename&gt; is what we want to call the script. This name doesn’t matter for its execution.\nOnce we have created the script, we can run it from the command line. We will get into the command line in a later lecture, but right now all you need to know is:\n    python3 &lt;filename&gt;.py"
  },
  {
    "objectID": "lecture-1-reveal.html#an-alternative-method-of-running-python",
    "href": "lecture-1-reveal.html#an-alternative-method-of-running-python",
    "title": "Python Introduction",
    "section": "An alternative method of running python",
    "text": "An alternative method of running python\nYou may notice that if you don’t give python a filename to run, you will enter something called the REPL.\n    Python 3.9.5 (default, Jun  4 2021, 12:28:51) \n    [GCC 7.5.0] :: Anaconda, Inc. on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    &gt;&gt;&gt; \nREPL stands for READ, EXECUTE, PRINT, LOOP."
  },
  {
    "objectID": "lecture-1-reveal.html#variables",
    "href": "lecture-1-reveal.html#variables",
    "title": "Python Introduction",
    "section": "Variables",
    "text": "Variables\nA variable is a symbol associated with a value. This value can differ widely, and we will take a look at different types of values/data later.\nNeverthless, variables are useful for referring to values and storing to the results of a computation.\n    x = 1\n    y = 2\n    z = x + y\n    print(z)   # prints: 3\n    \n    # variables can be /overwritten/\n    z = \"hello, world\"\n    print(z)   # prints: hello, world\nResults: \n# =&gt; 3\n# =&gt; hello, world"
  },
  {
    "objectID": "lecture-1-reveal.html#primitive-data-types",
    "href": "lecture-1-reveal.html#primitive-data-types",
    "title": "Python Introduction",
    "section": "Primitive data types",
    "text": "Primitive data types\nPrimitive data types are the most fundamental parts of programming, they cannot be broken down.\n    \"Hello\" # string\n    1       # integer\n    1.0     # float\n    True    # Boolean (or bool for short)\nWe can get the type of some data by using the type(...) function. For example,\n    print(type(5))\n    print(type(5.0))\n    \n    x = \"all cats meow\"\n    \n    print(type(x))\nResults: \n# =&gt; &lt;class 'int'&gt;\n# =&gt; &lt;class 'float'&gt;\n# =&gt; &lt;class 'str'&gt;"
  },
  {
    "objectID": "lecture-1-reveal.html#basic-math-with-primitives",
    "href": "lecture-1-reveal.html#basic-math-with-primitives",
    "title": "Python Introduction",
    "section": "Basic Math with primitives",
    "text": "Basic Math with primitives\nUsing these primitive data types, we can do some basic math operations!\n    print(1 + 2)    # Addtion\n    print(1 - 2)    # Subtraction\n    print(1 * 2)    # Multiplication\n    print(1 / 2)    # Division\n    print(2 ** 2)   # Exponent\n    print(3 % 2)    # Modulo operator\nResults: \n# =&gt; 3\n# =&gt; -1\n# =&gt; 2\n# =&gt; 0.5\n# =&gt; 4\n# =&gt; 1\nSometimes types get converted to the same type:\n    print(1.0 + 2)  # float + integer = float\nResults: \n# =&gt; 3.0\nEven more interesting is with Booleans!\n    True + True\nResults: \n# =&gt; 2"
  },
  {
    "objectID": "lecture-1-reveal.html#bodmas-in-python",
    "href": "lecture-1-reveal.html#bodmas-in-python",
    "title": "Python Introduction",
    "section": "BODMAS in Python",
    "text": "BODMAS in Python\nLike in mathematics, certain math operator take precedence over others.\n\nB - Brackets\nO - Orders (roots, exponents)\nD - division\nM - multiplication\nA - addition\nS - subtraction.\n\nTo make the context clear as to what operations to perform first, use brackets.\n    (5 / 5) + 1\n    5 / (5 + 1)\nResults: \n# =&gt; 2.0\n# =&gt; 0.8333333333333334"
  },
  {
    "objectID": "lecture-1-reveal.html#basic-math-quick-exercise",
    "href": "lecture-1-reveal.html#basic-math-quick-exercise",
    "title": "Python Introduction",
    "section": "Basic Math – Quick exercise",
    "text": "Basic Math – Quick exercise\nWrite the following equation in python:\n\\((5 + 2) \\times (\\frac{10}{2} + 10)^2\\)\nRemember to use parentheses ( ) to ensure that operations take precedence over others.\nYour answer should come out as: 1575.0"
  },
  {
    "objectID": "lecture-1-reveal.html#formatting-strings",
    "href": "lecture-1-reveal.html#formatting-strings",
    "title": "Python Introduction",
    "section": "Formatting strings",
    "text": "Formatting strings\nIn many previous examples when we’ve printed strings, we’ve done something like:\n    age = 35\n    \n    print(\"The value of age is\", age)\nResults: \n# =&gt; The value of age is 35\nWhile this works in this small context, it can get pretty cumbersome if we have many variables we want to print, and we also want to change how they are displayed when they are printed.\nWe’re going to take a look now at much better ways of printing."
  },
  {
    "objectID": "lecture-1-reveal.html#better-ways-of-printing-strings--",
    "href": "lecture-1-reveal.html#better-ways-of-printing-strings--",
    "title": "Python Introduction",
    "section": "Better ways of printing strings - %",
    "text": "Better ways of printing strings - %\nThe first method is using %. When we print, we first construct a string with special delimiters, such as %s that denotes a string, and %d that denotes a number. This is telling Python where we want the values to be placed in the string.\nOnce we’ve created the string, we need to specify the data, which we do with % (...). Like, for example:\n    age = 35\n    name = \"John\"\n    \n    print(\"%d years old\" % age)  # no tuple for one variable\n    print(\"%s is %d years old\" % (name, age)) \nResults: \n# =&gt; 35 years old\n# =&gt; John is 35 years old\nHere we are specifying the a string %s and number %d, and then giving the variables that correspond with that data type.\nThe special delimiters correspond with a data type. Here are some of the most common:\n\n%s – For strings\n%d – For numbers\n%f – For floating point numbers.\n\nThere are others such as %x that prints the hexadecimal representation, but these are less common. You can find the full list at: https://docs.python.org/3/library/stdtypes.html#old-string-formatting\nWhen using these delimiters, we can add modifiers to how they format and display the value. Take a very common example, where we have a floating point value, and, when printing it, we only want to print to 3 decimal places. To accomplish this, we again use %f but add a .3 to between the % and f. In this example, we are printing π to 3 decimal places.\n    print(\"Pi to 3 digits is: %.3f\" % 3.1415926535)\nResults: \n# =&gt; Pi to 3 digits is: 3.142\nIn the previous example, we used .3 to specify 3 decimal places. If we put a number before the decimal, like 10.3 we are telling Python make this float occupy 10 spaces and this float should have 3 decimal places printed. When it gets printed, you will notice that it shifts to the right, it gets padded by space. If we use a negative number in front of the decimal place, we are telling python to shift it to the left.\n    print(\"Pi to 3 digits is: %10.3f\" % 3.1415926535)\n    print(\"Pi to 3 digits is: %-10.3f\" % 3.1415926535)\nResults: \n# =&gt; Pi to 3 digits is:      3.142\n# =&gt; Pi to 3 digits is: 3.142\nThe final method of formatting strings is a newcomer within the language, it is the so-called f-string. Where a f character is prefixed to the beginning of the string you’re creating. f-string’s allow you to use Python syntax within the string (again delimited by {}.\nTake this for example where we are referencing the variables name and age directly.\n    name = \"Jane\"\n    age = 35\n\n    print(f\"{name} is {age} years old\")\nResults: \n# =&gt; Jane is 35 years old\nf-string’s allow you to execute Python code within the string. Here we are accessing the value from the dictionary by specifying the key within the string itself! It certainly makes it a lot easier, especially if we only need to access the values for the string itself.\n    contact_info = {\"name\": \"Jane\", \"age\": 35}\n    \n    print(f\"{contact_info['name']} is {contact_info['age']} years old\")\nResults: \n# =&gt; Jane is 35 years old\nhttps://pyformat.info/\nWe can still format the values when using f-string. The method is similar to those using the %f specifiers.\n    pi = 3.1415926535\n    print(f\"Pi is {pi:.3f} to 3 decimal places\")\nResults: \n# =&gt; Pi is 3.142 to 3 decimal places\nMany more examples can be found at: https://zetcode.com/python/fstring/"
  },
  {
    "objectID": "lecture-1-reveal.html#splitting-strings",
    "href": "lecture-1-reveal.html#splitting-strings",
    "title": "Python Introduction",
    "section": "Splitting strings",
    "text": "Splitting strings\nApart from formatting, there are plenty more operations we can perform on strings. We are going to highlight some of the most common here.\nThe first we’re going to look at is splitting a string by a delimiter character using the .split() method. If we don’t pass any argument to the .split() method, then by default, it will split by spaces. However, we can change this by specifying the delimiter.\n    my_string = \"This is a sentence, where each word is separated by a space\"\n    \n    print(my_string.split())\n    print(my_string.split(\",\"))\nResults: \n# =&gt; ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n# =&gt; ['This is a sentence', ' where each word is separated by a space']"
  },
  {
    "objectID": "lecture-1-reveal.html#joining-strings-together",
    "href": "lecture-1-reveal.html#joining-strings-together",
    "title": "Python Introduction",
    "section": "Joining strings together",
    "text": "Joining strings together\nAs .split() splits a single string into a list, .join() joins a list of strings into a single string. To use .join(), we first create a string of the delimiter we want to use to join the list of strings by. In this example we’re going to use \"-\". Then we call the .join() method, passing the list as an argument.\nThe result is a single string using the delimiter to separate the items of the list.\n    x = ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    \n    print(\"-\".join(x))\nResults: \n# =&gt; This-is-a-sentence,-where-each-word-is-separated-by-a-space"
  },
  {
    "objectID": "lecture-1-reveal.html#changing-cases",
    "href": "lecture-1-reveal.html#changing-cases",
    "title": "Python Introduction",
    "section": "Changing cases",
    "text": "Changing cases\nOther common operations on strings involve change the case. For example:\n\nMake the entire string uppercase or lowercase\nMaking the string title case (every where starts with a capital letter).\nStripping the string by removing any empty spaces either side of the string.\n\nNote we can chain many methods together by doing .method_1().method_2(), but only if they return string. If they return None, then chaining will not work.\n    x = \"    this String Can change case\"\n    \n    print(x.upper())\n    print(x.lower())\n    print(x.title())\n    print(x.strip())\n    print(x.strip().title())\nResults: \n# =&gt;     THIS STRING CAN CHANGE CASE\n# =&gt;     this string can change case\n# =&gt;     This String Can Change Case\n# =&gt; this String Can change case\n# =&gt; This String Can Change Case"
  },
  {
    "objectID": "lecture-1-reveal.html#replacing-parts-of-a-string",
    "href": "lecture-1-reveal.html#replacing-parts-of-a-string",
    "title": "Python Introduction",
    "section": "Replacing parts of a string",
    "text": "Replacing parts of a string\nTo replace a substring, we use the .replace() method. The first argument is the old string you want to replace. The second argument is what you want to replace it with.\n    x = \"This is a string that contains some text\"\n    \n    print(x.replace(\"contains some\", \"definitely contains some\"))\nResults: \n# =&gt; This is a string that definitely contains some text"
  },
  {
    "objectID": "lecture-1-reveal.html#container-data-typesdata-structures",
    "href": "lecture-1-reveal.html#container-data-typesdata-structures",
    "title": "Python Introduction",
    "section": "Container data types/Data structures",
    "text": "Container data types/Data structures\nContainer data types or data structures, as the name suggests, are used to contain other things. Types of containers are:\n\nLists\nDictionaries\nTuples\nSets\n\n    [1, \"hello\", 2]                 # list\n    {\"my-key\": 2, \"your-key\": 1}    # dictionary (or dict)\n    (1, 2)                          # tuple\n    set(1, 2)                       # set\nWe’ll take a look at each of these different container types and explore why we might want to use each of them."
  },
  {
    "objectID": "lecture-1-reveal.html#an-aside-on-terminology",
    "href": "lecture-1-reveal.html#an-aside-on-terminology",
    "title": "Python Introduction",
    "section": "An aside on Terminology",
    "text": "An aside on Terminology\nTo make our explanations clearer and reduce confusion, each of the different symbols have unique names.\nI will use this terminology consistently throughout the course, and it is common to see the same use outside the course.\n\n[ ] brackets (square brackets).\n{ } braces (curly braces).\n( ) parentheses."
  },
  {
    "objectID": "lecture-1-reveal.html#lists",
    "href": "lecture-1-reveal.html#lists",
    "title": "Python Introduction",
    "section": "Lists",
    "text": "Lists\nA hetreogenious container. This means that it can store any type of data.\n    x = [1, \"hello\", 2]\nElements can be accessed using indexing [ ] notation. For example:\n    print(x[0])    # this will get the first element (i.e. 1)\n    print(x[1])    # the second element (i.e. \"hello\")\n    print(x[2])    # the third element (i.e. 2)\nResults: \n# =&gt; 1\n# =&gt; hello\n# =&gt; 2\nnotice how the first element is the 0-th item in the list/ we say that python is 0-indexed."
  },
  {
    "objectID": "lecture-1-reveal.html#slices",
    "href": "lecture-1-reveal.html#slices",
    "title": "Python Introduction",
    "section": "Slices",
    "text": "Slices\nIf we wanted to access an element from a data structure, such as a list, we would use the [ ] accessor, specifying the index of the element we wish to retrieve (remember that indexes start at zero!). But what if we ranted to access many elements at once? Well to accomplish that, we have a slice or a range of indexes (not to be confused with the range function). A slice is defined as:\nstart_index:end_index\nwhere the end_index is non inclusive – it doesn’t get included in the result. Here is an example where we have a list of 6 numbers from 0 to 5, and we slice the list from index 0 to 3. Notice how the 3rd index is not included.\n    x = [0, 1, 2, 3, 4, 5]\n    print(x[0:3])\nResults: \n# =&gt; [0, 1, 2]"
  },
  {
    "objectID": "lecture-1-reveal.html#ranges",
    "href": "lecture-1-reveal.html#ranges",
    "title": "Python Introduction",
    "section": "Ranges",
    "text": "Ranges\nWhen we use start_index:end_index, the slice increments by 1 from start_index to end_index. If we wanted to increment by a different amount we can use the slicing form:\nstart_index:end_index:step\nHere is an example where we step the indexes by 2:\n    x = list(range(100))\n    print(x[10:15:2])\nResults: \n# =&gt; [10, 12, 14]"
  },
  {
    "objectID": "lecture-1-reveal.html#reverse",
    "href": "lecture-1-reveal.html#reverse",
    "title": "Python Introduction",
    "section": "Reverse",
    "text": "Reverse\nOne strange fact about the step is that if we specify a negative number for the step, Python will work backwards, and effectively reverse the list.\n    x = list(range(5))\n    \n    print(x[::-1])\nResults: \n# =&gt; [4, 3, 2, 1, 0]\nIn a previous example, I created a slice like 0:3. This was a little wasteful as we can write slightly less code. If we write :end_index, Python assumes and creates a slice from the first index (0) to the end_index. If we write start_index:, Python assumes and creates a slice from start_index to the end of the list.\n    x = list(range(100))\n    \n    print(x[:10])\n    print(x[90:])\nResults: \n# =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n# =&gt; [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]"
  },
  {
    "objectID": "lecture-1-reveal.html#indexing-backwards",
    "href": "lecture-1-reveal.html#indexing-backwards",
    "title": "Python Introduction",
    "section": "Indexing backwards",
    "text": "Indexing backwards\nFinally, we also work backwards from the end of list. If we use a negative number, such as -1, we are telling Python, take the elements from the end of the list. -1 is the final index, and numbers lower than -1 work further backwards through the list.\n    x = list(range(100))\n    \n    print(x[-1])\n    print(x[-2])\nResults: \n# =&gt; 99\n# =&gt; 98\nSlicing with negative indexes, also works. Here we are creating a slice from the end of the list - 10, to the last (but not including) index.\n    x = list(range(100))\n    \n    print(x[-10:-1])\nResults: \n# =&gt; [90, 91, 92, 93, 94, 95, 96, 97, 98]"
  },
  {
    "objectID": "lecture-1-reveal.html#adding-data-to-a-list",
    "href": "lecture-1-reveal.html#adding-data-to-a-list",
    "title": "Python Introduction",
    "section": "Adding data to a list",
    "text": "Adding data to a list\nIf we want to add items to the end of the list, we use the append function:\n    my_list = []\n    \n    my_list.append(\"all\")\n    my_list.append(\"dogs\")\n    my_list.append(\"bark\")\n    \n    print(my_list)\nResults: \n# =&gt; ['all', 'dogs', 'bark']"
  },
  {
    "objectID": "lecture-1-reveal.html#dictionaries",
    "href": "lecture-1-reveal.html#dictionaries",
    "title": "Python Introduction",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries are a little different from lists as each ‘element’ consists of a key-pair value. Let’s have a look at some examples where the dictionaries contains one element:\n    my_dictionary = {\"key\": \"value\"}\n    my_other_dict = {\"age\": 25}\nTo access the value, we get it using [key] notation:\n    my_other_dict[\"age\"]\nResults: \n# =&gt; 25\nNOTE keys are unique, i.e:\n    my_dictionary = {\"age\": 25, \"age\": 15}\n    my_dictionary[\"age\"]\nResults: \n# =&gt; 15\nThe key in the dictionary doesn’t necessarily need to be a string. For example, in this case, we have created two key-pair elements, where the keys to both are tuples of numbers.\n    my_dictionary = {(1, 2): \"square\", (3, 4): \"circle\"}\n    \n    print(my_dictionary[(1, 2)])\nResults: \n# =&gt; square\nadding data\nIf we want to add data to a dictionary, we simply perform the accessor method with a key that is not in the dictionary:\n    my_dict = {}\n    \n    my_dict[\"name\"] = \"James\"\n    my_dict[\"age\"] = 35\n    \n    print(my_dict)\nResults: \n# =&gt; {'name': 'James', 'age': 35}\nQuick Exercise\n\nCreate a dictionary for the following address, and assign it a variable name called address:\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\nnumber\n\n\n22\n\n\n\n\nstreet\n\n\nBakers Street\n\n\n\n\ncity\n\n\nLondon\n\n\n\n\n\n\nPrint out the address’s street name using the [ ] accessor with the correct key."
  },
  {
    "objectID": "lecture-1-reveal.html#tuples",
    "href": "lecture-1-reveal.html#tuples",
    "title": "Python Introduction",
    "section": "Tuples",
    "text": "Tuples\n    my_tuple = (1, 56, -2)\nLike lists, elements of the tuple can be accessed by their position in the list, starting with the 0-th element:\n    print(my_tuple[0])  # =&gt; 1\n    print(my_tuple[1])  # =&gt; 56\n    print(my_tuple[2])  # =&gt; -2\nResults: \n# =&gt; 1\n# =&gt; 56\n# =&gt; -2\nUnlike lists, tuples cannot be changed after they’ve been created. We say they are immutable. So this will not work:\n    my_tuple[2] = \"dogs\"  # creates an Error\nResults: \n# =&gt; Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/tmp/pyKdIIcx\", line 18, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment"
  },
  {
    "objectID": "lecture-1-reveal.html#sets",
    "href": "lecture-1-reveal.html#sets",
    "title": "Python Introduction",
    "section": "Sets",
    "text": "Sets\nSets in Python are like tuples, but contain only unique elements.\nYou can use the set( ) function (more on functions later!), supplying a list, to create a set:\n    my_set = set([1, 2, 2, 2, 3, 4])\n    my_set\nResults: \n# =&gt; {1, 2, 3, 4}\nNotice how there is only one ‘2’ in the resulting set, duplicate elements are removed.\nadding data\nIf we want to add data to a set, we use the .add() method. The element used as an argument to this function will only be added to the set if it is not already in the set.\n    my_set = set([])\n    \n    my_set.add(1)\n    my_set.add(2)\n    my_set.add(1)\n    \n    print(my_set)\nResults: \n# =&gt; {1, 2}"
  },
  {
    "objectID": "lecture-1-reveal.html#if-statement",
    "href": "lecture-1-reveal.html#if-statement",
    "title": "Python Introduction",
    "section": "If statement",
    "text": "If statement\nIf statements allow for branching paths of execution. In other words, we can execute some statements if some conditions holds (or does not hold).\nThe structure of a simple if statement is:\nif &lt;condition&gt;:\n    &lt;body&gt;\n    x = 2\n    y = \"stop\"\n    \n    if x &lt; 5:\n        print(\"X is less than five\")\n    if y == \"go\":\n        print(\"All systems go!!\")\nResults: \n# =&gt; X is less than five\nIn the previous example, the first print statement was only executed if the x &lt; 5 evaluates to True, but in python, we can add another branch if the condition evaluates to False. This branch is denoted by the else keyword.\n    x = 10\n    \n    if x &lt; 5:\n        print(\"X is less than five\")\n    else:\n        print(\"X is greater than or equal to five\")\nResults: \n# =&gt; X is greater than or equal to five"
  },
  {
    "objectID": "lecture-1-reveal.html#does-it-contain-a-substring",
    "href": "lecture-1-reveal.html#does-it-contain-a-substring",
    "title": "Python Introduction",
    "section": "does it contain a substring?",
    "text": "does it contain a substring?\nWe can check if a string exists within another string using the in keyword. This returns a Boolean value, so we can use it as a condition to an if statement.\n    x = \"This is a string that contains some text\"\n    \n    if \"text\" in x:\n        print(\"It exists\")\nResults: \n# =&gt; It exists"
  },
  {
    "objectID": "lecture-1-reveal.html#if-statement-quick-exercise",
    "href": "lecture-1-reveal.html#if-statement-quick-exercise",
    "title": "Python Introduction",
    "section": "If statement – Quick Exercise",
    "text": "If statement – Quick Exercise\n\nCreate a variable called age and assign the value of this variable 35.\nCreate and if statement that prints the square of age if the value of age is more than 24.\nThis if statement should have an else condition, that prints age divided by 2.\nWhat is the printed value?"
  },
  {
    "objectID": "lecture-1-reveal.html#multiple-paths",
    "href": "lecture-1-reveal.html#multiple-paths",
    "title": "Python Introduction",
    "section": "Multiple paths",
    "text": "Multiple paths\nIf we wanted to add multiple potential paths, we can add more using the elif &lt;condition&gt; keywords.\nNote: The conditions are checked from top to bottom, only executing the else if none evaluate to True. The first condition that evaluates to True is executed, the rest are skipped.\nx = 15\n\nif x &lt; 5:\n    print(\"X is less than five\")\nelif x &gt; 10:\n    print(\"X is greater than ten\")\nelse:\n    print(\"X is between five and ten\")\n\nResults: \n# =&gt; X is greater than ten"
  },
  {
    "objectID": "lecture-1-reveal.html#inline-if-statements",
    "href": "lecture-1-reveal.html#inline-if-statements",
    "title": "Python Introduction",
    "section": "Inline if-statements",
    "text": "Inline if-statements\nSometimes, we might want to conditionally set a variable a value. For this, we can use an inline if statement. The form of an inline if statement is:\n&lt;value-if-true&gt; if &lt;condition&gt; else &lt;value-if-false&gt;\nx = 10\n\ny = 5 if x &gt; 5 else 2\n\nprint(x + y)\n\nResults: \n# =&gt; 15"
  },
  {
    "objectID": "lecture-1-reveal.html#boolean-logic",
    "href": "lecture-1-reveal.html#boolean-logic",
    "title": "Python Introduction",
    "section": "Boolean Logic",
    "text": "Boolean Logic\nAs we’ve seen, if statements are checking for conditions to evaluate to True or False. In python we use various comparison operators to check for conditions that evaluate to Booleans.\nComparison operators\n\n&lt; less than\n&lt;= less than or equal to\n&gt; greater than\n&gt;= greater than or equal to\n== is equal to\nnot negation\n\nIf we want to check for multiple conditions, we can use conjunctives or disjunctive operators to combine the Boolean formulas.\nConjunctives/Disjunctives\n\nand all boolean expressions must evaluate to true\nor only one expression needs to be true\n\nNot\nUsing not you can invert the Boolean result of the expression.\nprint(not True)\n\nResults: \n# =&gt; False\n\nx = 10\n\nif not x == 11:\n    print(\"X is not 11\")\n\nResults: \n# =&gt; X is not 11\nAnd\nLet’s take an example using the and keyword. and here is checking that x is above or equal to 10 and y is exactly 5. If either of the conditions is False, python will execute the else path (if there is one, of course!).\nx = 10\ny = 5\n\nif x &gt;= 10 and y == 5:\n    z = x + y\nelse:\n    z = x * y\n\nprint(z)\n\nResults: \n# =&gt; 15\nOr\nHere we see the use of the or keyword. If any of the conditions evaluates to True then the whole condition evaluates to True.\nx = 10\ny = 5\n\nif x &lt; 5 or y == 5:\n    print(\"We got here!\")\nelse:\n    print(\"We got here instead...\")\n\nResults: \n# =&gt; We got here!\nNote: or is short-circuiting. This means that if tests the conditions left-to-right, and when it finds something that is True it stops evaluating the rest of the conditions.\nx = 10\n\nif x &lt; 20 or print(\"We got to this condition\"):\n    print(\"The value of x is\", x) \n\nResults: \n# =&gt; The value of x is 10\nCombining And and Or\nIf your Boolean logic refers to a single variable, you can combine the logic without the and and or. But its not always common.\nFor example,\nx = 7\n\nif x &lt; 10 and x &gt; 4:\n    print(\"X is between 5 and 10\")\nCan be the same as:\nx = 7\n\nif 5 &lt; x &lt; 10:\n    print(\"X is between 5 and 10\")\n\nResults: \n# =&gt; X is between 5 and 10"
  },
  {
    "objectID": "lecture-1-reveal.html#for-loop",
    "href": "lecture-1-reveal.html#for-loop",
    "title": "Python Introduction",
    "section": "For loop",
    "text": "For loop\nLooping or iteration allows us to perform a series of actions multiple times. We are going to start with the more useful for loop in python. The syntax of a for loop is:\nfor &lt;variable_name&gt; in &lt;iterable&gt;:\n    &lt;body&gt;\n\nfor i in range(3):\n    print(i)\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2"
  },
  {
    "objectID": "lecture-1-reveal.html#break",
    "href": "lecture-1-reveal.html#break",
    "title": "Python Introduction",
    "section": "break",
    "text": "break\nThe previous example loops over the body a fix number of times. But what if we wanted to stop looping early? Well, we can use the break keyword. This keyword will exit the body of the loop.\nfor i in range(10):\n    if i &gt; 5:\n        break\n    print(i)\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2\n# =&gt; 3\n# =&gt; 4\n# =&gt; 5"
  },
  {
    "objectID": "lecture-1-reveal.html#continue",
    "href": "lecture-1-reveal.html#continue",
    "title": "Python Introduction",
    "section": "continue",
    "text": "continue\nA different keyword you might want to use is continue. Continue allows you to move/skip onto the next iteration without executing the entire body of the for loop.\nfor i in range(10):\n    if i % 2 == 0:\n        continue\n    print(i)\n\nResults: \n# =&gt; 1\n# =&gt; 3\n# =&gt; 5\n# =&gt; 7\n# =&gt; 9"
  },
  {
    "objectID": "lecture-1-reveal.html#ranges-1",
    "href": "lecture-1-reveal.html#ranges-1",
    "title": "Python Introduction",
    "section": "ranges",
    "text": "ranges\nInstead of using continue like in the previous slide, the range function provides us with some options:\nrange(start, stop, step)\nIn this example, we are starting our iteration at 10, ending at 15, but stepping the counter 2 steps.\nfor i in range(10, 15, 2):\n    print(i)\n\nResults: \n# =&gt; 10\n# =&gt; 12\n# =&gt; 14"
  },
  {
    "objectID": "lecture-1-reveal.html#loop-over-collections",
    "href": "lecture-1-reveal.html#loop-over-collections",
    "title": "Python Introduction",
    "section": "Loop over collections",
    "text": "Loop over collections\nFor loops allow us to iterate over a collection, taking one element at a time. Take for example, a list, and for every item in the list we print its square.\nmy_list = [1, 5, 2, 3, 5.5]\n\nfor el in my_list:\n    print(el**2)\n\nResults: \n# =&gt; 1\n# =&gt; 25\n# =&gt; 4\n# =&gt; 9\n# =&gt; 30.25\nThis kind of looping can work for tuples and sets, but as we have seen, dictionaries are a little different. Every ‘element’ in a dictionary consists of a key and a value. Therefore when we iterate over items in a dictionary, we can assign the key and value to different variables in the loop.\nNote the use of the .items() after the dictionary. We will explore this later.\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor el_key, el_val in my_dict.items():\n    print(\"Key is:\", el_key, \" value is: \", el_val)\n\nResults: \n# =&gt; Key is: name  and the value is:  jane\n# =&gt; Key is: age  and the value is:  35\n# =&gt; Key is: location  and the value is:  France\nWe could also loop over the keys in the dictionary using the .keys() method instead of .items().\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor the_key in my_dict.keys():\n    print(the_key)\n\nResults: \n# =&gt; name\n# =&gt; age\n# =&gt; loc\nOr, the values using .values().\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor the_value in my_dict.values():\n    print(the_value)\n\nResults: \n# =&gt; jane\n# =&gt; 35\n# =&gt; France"
  },
  {
    "objectID": "lecture-1-reveal.html#list-comprehensions",
    "href": "lecture-1-reveal.html#list-comprehensions",
    "title": "Python Introduction",
    "section": "List comprehensions",
    "text": "List comprehensions\nWe have seen previously how for loops work. Knowing the syntax of a for loop and wanting to populate a list with some data, we might be tempted to write:\nx = []\nfor i in range(3):\n    x.append(i)\n\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2]\nWhile this is perfectly valid Python code, Python itself provides ‘List comprehensions’ to make this process easier.\nx = [i for i in range(3)]\nThe syntax of a list comprehensions is:\n[ &lt;variable&gt; for &lt;variable&gt; in &lt;iterable&gt; ]\nWe can also perform similar actions with a dictionary\n[ &lt;key&gt;, &lt;value&gt; for &lt;key&gt;, &lt;value&gt; in &lt;dictionary.items()&gt; ]\nusing if’s\nPerhaps we only want to optionally perform an action within the list comprehension? Python allows us to do this with the inline if statement we’ve seen in the previous lecture.\nx = [i if i &lt; 5 else -1 for i in range(7)]\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2, 3, 4, -1, -1]\nWe add the inline &lt;var&gt; if &lt;condition&gt; else &lt;other-var&gt; before the for loop part of the comprehension.\nThere is another type of if statement in a list comprehension, this occurs when we don’t have an else.\nx = [i for i in range(7) if i &lt; 3]\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2]\nIn this example, we’re only ‘adding’ to the list if the condition (\\(i &lt; 3\\)) is true, else the element is not included in the resulting list.\nmultiple for’s\nIf we like, we can also use nested for loops by simply adding another for loop into the comprehension.\nx = [(i, j) for i in range(2) for j in range(2)]\n\nprint(x)\n\nResults: \n# =&gt; [(0, 0), (0, 1), (1, 0), (1, 1)]\nIn this example, we’re creating a tuple for each element, effectively each combination of 1 and 0."
  },
  {
    "objectID": "lecture-1-reveal.html#list-comprehensions-with-dictionary",
    "href": "lecture-1-reveal.html#list-comprehensions-with-dictionary",
    "title": "Python Introduction",
    "section": "List comprehensions with dictionary",
    "text": "List comprehensions with dictionary\nPython doesn’t restrict us to list comprehensions, but we can do a similar operation to create a dictionary.\nx = [2, 5, 6]\ny = {idx: val for idx, val in enumerate(x)}\nprint(y)\n\nResults: \n# =&gt; {0: 2, 1: 5, 2: 6}\nHere, every item in x has been associated with its numerical index as a key thanks to the enumerate function that returns both the index and value at iteration in the for loop."
  },
  {
    "objectID": "lecture-1-reveal.html#for-loop-quick-exercise",
    "href": "lecture-1-reveal.html#for-loop-quick-exercise",
    "title": "Python Introduction",
    "section": "For loop – Quick Exercise",
    "text": "For loop – Quick Exercise\n\nCreate a list of elements:\n\n2\n“NA”\n24\n5\n\nUse a for loop to iterate over this list.\nIn the body of the for loop, compute \\(2x + 1\\), where \\(x\\) is the current element of the list.\nStore the result of this computation in a new variable \\(y\\), and then print y.\n\nNote You cannot compute \\(2x + 1\\) of “NA”, therefore you will to use an if statement to skip onto the next iteration if it encounters this. Hint try: type(...) =!= str"
  },
  {
    "objectID": "lecture-1-reveal.html#while-loop",
    "href": "lecture-1-reveal.html#while-loop",
    "title": "Python Introduction",
    "section": "While loop",
    "text": "While loop\nA while loop is another looping concept like for but it can loop for an arbitrary amount of times. A while loop looks to see if the condition is True, and if it is, it will execute the body.\nThe syntax of the while loop is:\nwhile &lt;condition&gt;:\n    &lt;body&gt;\n\ni = 0\n\nwhile i &lt; 3:\n    print(i)\n    i = i + 1\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2\n\nx = 0\ny = 1\nHere is another example:\nwhile x + y &lt; 10:\n    print(\"X is,\", x, \"and y is\", y)\n    x = x + 1\n    y = y * 2\n\nprint(\"X ended as\", x, \", while y is\", y)\n\nResults: \n# =&gt; X is, 0 and y is 1\n# =&gt; X is, 1 and y is 2\n# =&gt; X is, 2 and y is 4\n# =&gt; X ended as 3 , while y is 8"
  },
  {
    "objectID": "lecture-1-reveal.html#example-usage-of-a-function",
    "href": "lecture-1-reveal.html#example-usage-of-a-function",
    "title": "Python Introduction",
    "section": "Example usage of a function",
    "text": "Example usage of a function\nLet’s make a function that takes two numbers and adds them together:\ndef my_addition(a, b):\n    result = a + b\n    return result\n\nx = 2\ny = 3\nz = my_addition(2, 3)  # return 5 and stores in z\nprint(z)\n\nResults: \n# =&gt; 5"
  },
  {
    "objectID": "lecture-1-reveal.html#quick-exercise-1",
    "href": "lecture-1-reveal.html#quick-exercise-1",
    "title": "Python Introduction",
    "section": "Quick exercise",
    "text": "Quick exercise\n\nCreate a function called my_square. This function should take one argument (you can call this argument what you like).\nThe body of the function should compute and return the square of the argument.\nCall this function with 5.556.\nStore the result of calling this function, and print it.\nWhat is the result?"
  },
  {
    "objectID": "lecture-1-reveal.html#re-usability-with-functions",
    "href": "lecture-1-reveal.html#re-usability-with-functions",
    "title": "Python Introduction",
    "section": "Re-usability with Functions",
    "text": "Re-usability with Functions\nFunctions are better illustrated through some examples, so let’s see some!\nname_1 = \"john\"\nname_2 = \"mary\"\nname_3 = \"michael\"\n\nprint(\"Hello \" + name_1 + \", how are you?\")\nprint(\"Hello \" + name_2 + \", how are you?\")\nprint(\"Hello \" + name_3 + \", how are you?\")\nThe above is pretty wasteful. Why? Because we are performing the exact same operation multiple times, with only the variable changed.\nBy abstracting the actions we want to perform into a function, we can ultimately reduce the amount of code we write. Be a lazy programmer!\nname_1 = \"john\"\nname_2 = \"mary\"\nname_3 = \"michael\"\n\ndef say_hello(name):\n    print(\"Hello \" + name + \", how are you?\")\n\nsay_hello(name_1)\nsay_hello(name_2)\nsay_hello(name_3)\nIn this example, we’ve used the function as defined with the def pattern to write the print statement once. Then, we’ve called the function with each variable as its argument."
  },
  {
    "objectID": "lecture-1-reveal.html#named-parameters",
    "href": "lecture-1-reveal.html#named-parameters",
    "title": "Python Introduction",
    "section": "Named parameters",
    "text": "Named parameters\nWe’ve seen in previous examples that, when we create a function, we give each of the arguments (if there are any) a name.\nWhen calling this function, we can specify these same names such as:\ndef say_hello(name):\n    print(\"Hello,\", name)\n\nsay_hello(\"Micheal\")\nsay_hello(name=\"Micheal\")\n\nResults: \n# =&gt; Hello, Micheal\n# =&gt; Hello, Micheal\nBy specifying the name of the parameter we’re using with the called function, we can change the order\ndef say_greeting(greeting, name):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(name=\"John\", greeting=\"Hi\")\n\nResults: \n# =&gt; Hi John I hope you're having a good day"
  },
  {
    "objectID": "lecture-1-reveal.html#optionaldefaultpositional-arguments",
    "href": "lecture-1-reveal.html#optionaldefaultpositional-arguments",
    "title": "Python Introduction",
    "section": "Optional/Default/Positional arguments",
    "text": "Optional/Default/Positional arguments\nWhen we call a function with arguments without naming them, we are supplying them by position.\ndef say_greeting(greeting, name):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(#first position, #section position)\nThe first position gets mapped to variable name of greeting inside the body of the say_greeting function, while the second position gets mapped to name.\nSometimes when creating a function we may want to use default arguments, these are arguments that are used if the call to the function does not specify what their value should be. For example.\ndef say_greeting(name, greeting=\"Hello\"):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(\"John\")\nsay_greeting(\"John\", \"Hi\")  # supply greeting as positional argument\n\nResults: \n# =&gt; Hello John I hope you're having a good day\n# =&gt; Hi John I hope you're having a good day\nNote if you supply a default argument in the function definition, all arguments after this default argument must also supply a default argument.\nSo, this won’t work:\ndef say_greeting(name=\"Jane\", greeting):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(\"John\", \"Hi\")"
  },
  {
    "objectID": "lecture-1-reveal.html#recap-on-arguments",
    "href": "lecture-1-reveal.html#recap-on-arguments",
    "title": "Python Introduction",
    "section": "Recap on arguments",
    "text": "Recap on arguments\n# defining the function\n\ndef say_greeting(name, greeting)  # no default arguments\ndef say_greeting(name, greeting=\"Hello\")  # greeting is a default argument\ndef say_greeting(name=\"Jane\", greeting=\"Hello\")  # both arguments have a default\n\n# calling the functions\n\nsay_greeting(\"John\", \"Hi\")  # both arguments are provided by position\nsay_greeting(name=\"John\", greeting=\"Hi\")  # arguments are supplied by name\nsay_greeting(greeting=\"Hi\", name=\"John\")  # the position of named arguments do not matter"
  },
  {
    "objectID": "lecture-1-reveal.html#function-doc-strings",
    "href": "lecture-1-reveal.html#function-doc-strings",
    "title": "Python Introduction",
    "section": "Function doc-strings",
    "text": "Function doc-strings\nTo make it clear for a human to quickly understand what a function is doing, you can add an optional doc-string. This is a string that is added directly after the initial definition of the function:\ndef my_function(x, y):\n    \"\"\"I am a docstring!!!\"\"\"\n    return x + y\nSome common use cases for docstrings are explaining what the parameters are that it expects, and what it returns.\nIf your explanation is a little longer than a line, a multiline docstring can be created as long as you’re using \"\"\" three quotation marks either side of the string\ndef my_function(x, y):\n    \"\"\"\n    This is my realllly long docstring\n    that explains how the function works. But sometimes\n    its best not to explain the obvious\n    \"\"\"\n    return x + y"
  },
  {
    "objectID": "lecture-1-reveal.html#understanding-scope",
    "href": "lecture-1-reveal.html#understanding-scope",
    "title": "Python Introduction",
    "section": "Understanding scope",
    "text": "Understanding scope\nIn this example we have two scopes which can be easily seen by the indentation. The first is the global scope. The second scope is the scope of the function. The scope of the function can reference variables in the larger scope. But once the function scope exits, we can no longer reference the variables from the function.\nx = 10\n\ndef compute_addition(y):\n    return x + y\n\nprint(compute_addition(10))\nprint(x)\nprint(y)  # does not work\n\nResults: \n# =&gt; 20\n# =&gt; 10\nEven though we can reference the global scope variable from the scope of the function, we can’t modify it like this:\nx = 10\n\ndef compute_addition_2(y):\n    x = x + 5  # error local variable referenced before assignment\n    return x + y\n\nprint(compute_addition_2(10))\nIf we really wanted to reference a variable in a global scope and modify its value, we could use the global keyword. Doing this makes the function output something different every time it is called. This can make it difficult to debug incorrect programs.\nx = 10\n\ndef compute_addition_2(y):\n    global x\n    x = x + 5\n    return x + y\n\nprint(compute_addition_2(10))\nprint(x)\nprint(compute_addition_2(10))\n\nResults: \n# =&gt; 25\n# =&gt; 15\n# =&gt; 30\nIn almost all cases, avoid using global variables. Instead pass the variables as parameters. This can reduce a source of potential errors and ensure that if a function is called multiple times, the output can be more consistent and expected.\nx = 10\n\ndef compute_addition_3(x, y):\n    x = x + 5\n    return x + y\n\nprint(compute_addition_3(x, 10))\nprint(x)\nprint(compute_addition_3(x, 10))\n\nResults: \n# =&gt; 25\n# =&gt; 10\n# =&gt; 25"
  },
  {
    "objectID": "lecture-1-reveal.html#library-system",
    "href": "lecture-1-reveal.html#library-system",
    "title": "Python Introduction",
    "section": "Library system",
    "text": "Library system"
  },
  {
    "objectID": "lecture-1-reveal.html#use-what-youve-learnt",
    "href": "lecture-1-reveal.html#use-what-youve-learnt",
    "title": "Python Introduction",
    "section": "Use what you’ve learnt!",
    "text": "Use what you’ve learnt!\nWe’re going to create a library system to help locate and lookup information about books. For example, we want to know the author of book called ‘Moby Dick’.\nTo create this system, we are going to do it in stages. First, we will want to create our database of books:\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1879\n\n\n\n\n\nOur database is going to be a list of dictionaries. Where each dictionary is a row from this table. For example, one of the dictionaries will have the key “title” and a value “Moby Dick”.\nCreate this database and call it db."
  },
  {
    "objectID": "lecture-1-reveal.html#locating-books",
    "href": "lecture-1-reveal.html#locating-books",
    "title": "Python Introduction",
    "section": "Locating Books",
    "text": "Locating Books\n\nCreate a function called locate_by_title that takes the database to look through, and the title to look up as arguments.\nThis function should check each dictionary, and if the title is the same as what was searched for, it should return the whole dictionary.\nTest this function by calling the locate_by_title function with db and \"Frankenstein\". You should get {\"title\": \"Frankenstein\", \"author\": ...}.\n\nNote you should include docstrings to describe the arguments to the function, and what it will return."
  },
  {
    "objectID": "lecture-1-reveal.html#selecting-a-subset",
    "href": "lecture-1-reveal.html#selecting-a-subset",
    "title": "Python Introduction",
    "section": "Selecting a subset",
    "text": "Selecting a subset\nNow that we can find books by the title name, we also want to find all books that were released after a certain data.\n\nCreate a function called books_released_after that takes two arguments: the database to look through, and the year.\nThis function should look through the database, if it finds a book that was released after the year, it should add it to a list of books that is returned from this function.\nTest this function by calling books_released_after with db and 1850. This function call should return a list containing three dictionaries. The first entry should be ‘Moby Dick’ and the section should be ‘A Study in Scarlet’, etc."
  },
  {
    "objectID": "lecture-1-reveal.html#updating-our-database",
    "href": "lecture-1-reveal.html#updating-our-database",
    "title": "Python Introduction",
    "section": "Updating our database",
    "text": "Updating our database\nOh no! ‘Hitchhikers Guide to the Galaxy’ was released in 1979 not 1879, there must have been a typo. Let’s create a function to update this.\n\nCreate a function called update, that takes 5 arguments: 1) the database to update, 2) the key of the value we want to update 3) the value we want to update it to 4) the key we want to check to find out if we have the correct book and 5) the value of the key to check if we have the correct book.\nupdate(db,\n       key=\"release year\",\n       value=1979,\n       where_key=\"title\",\n       where_value=\"Hitchhikers Guide to the Galaxy\")"
  },
  {
    "objectID": "lecture-1-reveal.html#extended-exercise",
    "href": "lecture-1-reveal.html#extended-exercise",
    "title": "Python Introduction",
    "section": "Extended exercise",
    "text": "Extended exercise\n\nIn the previous steps we created functions locate_by_title and books_released_after. These two functions are similar in a way that they are selecting a subset of our database (just by different criteria).\nFor this harder exercise, can we create a single function called query that allows us to do both locate_by_title and books_released_after.\nAn example call to this query function may look like:\nresults = query(db,\n                where_key=\"title\",\n                where_value=\"Moby Dick\",\n                where_qualifier=\"exactly\")\nwhere_qualifier should accept strings like \"exactly\", \"greater than\", and \"less       than\"."
  },
  {
    "objectID": "lecture-1.html#a-first-program",
    "href": "lecture-1.html#a-first-program",
    "title": "Python Introduction",
    "section": "A first program",
    "text": "A first program\nWe’re going to start with the ‘Hello, World’ program that prints Hello, World! to the screen. In python this is as simple as writing:\n    print(\"Hello, World!\")   # this prints: Hello, World!\nResults: \n# =&gt; Hello, World!\nNOTE anything following a # is a comment and is completely ignored by the computer. It is there for you to document your code for others, and most importantly, for yourself."
  },
  {
    "objectID": "lecture-1.html#running-this-program",
    "href": "lecture-1.html#running-this-program",
    "title": "Python Introduction",
    "section": "Running this program",
    "text": "Running this program\nBefore we can run this program, we need to save it somewhere. For this, will create a new file, insert this text, and save it as &lt;filename&gt;.py, where &lt;filename&gt; is what we want to call the script. This name doesn’t matter for its execution.\nOnce we have created the script, we can run it from the command line. We will get into the command line in a later lecture, but right now all you need to know is:\n    python3 &lt;filename&gt;.py"
  },
  {
    "objectID": "lecture-1.html#an-alternative-method-of-running-python",
    "href": "lecture-1.html#an-alternative-method-of-running-python",
    "title": "Python Introduction",
    "section": "An alternative method of running python",
    "text": "An alternative method of running python\nYou may notice that if you don’t give python a filename to run, you will enter something called the REPL.\n    Python 3.9.5 (default, Jun  4 2021, 12:28:51) \n    [GCC 7.5.0] :: Anaconda, Inc. on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    &gt;&gt;&gt; \nREPL stands for READ, EXECUTE, PRINT, LOOP."
  },
  {
    "objectID": "lecture-1.html#variables",
    "href": "lecture-1.html#variables",
    "title": "Python Introduction",
    "section": "Variables",
    "text": "Variables\nA variable is a symbol associated with a value. This value can differ widely, and we will take a look at different types of values/data later.\nNeverthless, variables are useful for referring to values and storing to the results of a computation.\n    x = 1\n    y = 2\n    z = x + y\n    print(z)   # prints: 3\n    \n    # variables can be /overwritten/\n    z = \"hello, world\"\n    print(z)   # prints: hello, world\nResults: \n# =&gt; 3\n# =&gt; hello, world"
  },
  {
    "objectID": "lecture-1.html#primitive-data-types",
    "href": "lecture-1.html#primitive-data-types",
    "title": "Python Introduction",
    "section": "Primitive data types",
    "text": "Primitive data types\nPrimitive data types are the most fundamental parts of programming, they cannot be broken down.\n    \"Hello\" # string\n    1       # integer\n    1.0     # float\n    True    # Boolean (or bool for short)\nWe can get the type of some data by using the type(...) function. For example,\n    print(type(5))\n    print(type(5.0))\n    \n    x = \"all cats meow\"\n    \n    print(type(x))\nResults: \n# =&gt; &lt;class 'int'&gt;\n# =&gt; &lt;class 'float'&gt;\n# =&gt; &lt;class 'str'&gt;"
  },
  {
    "objectID": "lecture-1.html#basic-math-with-primitives",
    "href": "lecture-1.html#basic-math-with-primitives",
    "title": "Python Introduction",
    "section": "Basic Math with primitives",
    "text": "Basic Math with primitives\nUsing these primitive data types, we can do some basic math operations!\n    print(1 + 2)    # Addtion\n    print(1 - 2)    # Subtraction\n    print(1 * 2)    # Multiplication\n    print(1 / 2)    # Division\n    print(2 ** 2)   # Exponent\n    print(3 % 2)    # Modulo operator\nResults: \n# =&gt; 3\n# =&gt; -1\n# =&gt; 2\n# =&gt; 0.5\n# =&gt; 4\n# =&gt; 1\nSometimes types get converted to the same type:\n    print(1.0 + 2)  # float + integer = float\nResults: \n# =&gt; 3.0\nEven more interesting is with Booleans!\n    True + True\nResults: \n# =&gt; 2"
  },
  {
    "objectID": "lecture-1.html#bodmas-in-python",
    "href": "lecture-1.html#bodmas-in-python",
    "title": "Python Introduction",
    "section": "BODMAS in Python",
    "text": "BODMAS in Python\nLike in mathematics, certain math operator take precedence over others.\n\nB - Brackets\nO - Orders (roots, exponents)\nD - division\nM - multiplication\nA - addition\nS - subtraction.\n\nTo make the context clear as to what operations to perform first, use brackets.\n    (5 / 5) + 1\n    5 / (5 + 1)\nResults: \n# =&gt; 2.0\n# =&gt; 0.8333333333333334"
  },
  {
    "objectID": "lecture-1.html#basic-math-quick-exercise",
    "href": "lecture-1.html#basic-math-quick-exercise",
    "title": "Python Introduction",
    "section": "Basic Math – Quick exercise",
    "text": "Basic Math – Quick exercise\nWrite the following equation in python:\n\\((5 + 2) \\times (\\frac{10}{2} + 10)^2\\)\nRemember to use parentheses ( ) to ensure that operations take precedence over others.\nYour answer should come out as: 1575.0"
  },
  {
    "objectID": "lecture-1.html#formatting-strings",
    "href": "lecture-1.html#formatting-strings",
    "title": "Python Introduction",
    "section": "Formatting strings",
    "text": "Formatting strings\nIn many previous examples when we’ve printed strings, we’ve done something like:\n    age = 35\n    \n    print(\"The value of age is\", age)\nResults: \n# =&gt; The value of age is 35\nWhile this works in this small context, it can get pretty cumbersome if we have many variables we want to print, and we also want to change how they are displayed when they are printed.\nWe’re going to take a look now at much better ways of printing."
  },
  {
    "objectID": "lecture-1.html#better-ways-of-printing-strings--",
    "href": "lecture-1.html#better-ways-of-printing-strings--",
    "title": "Python Introduction",
    "section": "Better ways of printing strings - %",
    "text": "Better ways of printing strings - %\nThe first method is using %. When we print, we first construct a string with special delimiters, such as %s that denotes a string, and %d that denotes a number. This is telling Python where we want the values to be placed in the string.\nOnce we’ve created the string, we need to specify the data, which we do with % (...). Like, for example:\n    age = 35\n    name = \"John\"\n    \n    print(\"%d years old\" % age)  # no tuple for one variable\n    print(\"%s is %d years old\" % (name, age)) \nResults: \n# =&gt; 35 years old\n# =&gt; John is 35 years old\nHere we are specifying the a string %s and number %d, and then giving the variables that correspond with that data type.\nThe special delimiters correspond with a data type. Here are some of the most common:\n\n%s – For strings\n%d – For numbers\n%f – For floating point numbers.\n\nThere are others such as %x that prints the hexadecimal representation, but these are less common. You can find the full list at: https://docs.python.org/3/library/stdtypes.html#old-string-formatting\nWhen using these delimiters, we can add modifiers to how they format and display the value. Take a very common example, where we have a floating point value, and, when printing it, we only want to print to 3 decimal places. To accomplish this, we again use %f but add a .3 to between the % and f. In this example, we are printing π to 3 decimal places.\n    print(\"Pi to 3 digits is: %.3f\" % 3.1415926535)\nResults: \n# =&gt; Pi to 3 digits is: 3.142\nIn the previous example, we used .3 to specify 3 decimal places. If we put a number before the decimal, like 10.3 we are telling Python make this float occupy 10 spaces and this float should have 3 decimal places printed. When it gets printed, you will notice that it shifts to the right, it gets padded by space. If we use a negative number in front of the decimal place, we are telling python to shift it to the left.\n    print(\"Pi to 3 digits is: %10.3f\" % 3.1415926535)\n    print(\"Pi to 3 digits is: %-10.3f\" % 3.1415926535)\nResults: \n# =&gt; Pi to 3 digits is:      3.142\n# =&gt; Pi to 3 digits is: 3.142\nThe final method of formatting strings is a newcomer within the language, it is the so-called f-string. Where a f character is prefixed to the beginning of the string you’re creating. f-string’s allow you to use Python syntax within the string (again delimited by {}.\nTake this for example where we are referencing the variables name and age directly.\n    name = \"Jane\"\n    age = 35\n\n    print(f\"{name} is {age} years old\")\nResults: \n# =&gt; Jane is 35 years old\nf-string’s allow you to execute Python code within the string. Here we are accessing the value from the dictionary by specifying the key within the string itself! It certainly makes it a lot easier, especially if we only need to access the values for the string itself.\n    contact_info = {\"name\": \"Jane\", \"age\": 35}\n    \n    print(f\"{contact_info['name']} is {contact_info['age']} years old\")\nResults: \n# =&gt; Jane is 35 years old\nhttps://pyformat.info/\nWe can still format the values when using f-string. The method is similar to those using the %f specifiers.\n    pi = 3.1415926535\n    print(f\"Pi is {pi:.3f} to 3 decimal places\")\nResults: \n# =&gt; Pi is 3.142 to 3 decimal places\nMany more examples can be found at: https://zetcode.com/python/fstring/"
  },
  {
    "objectID": "lecture-1.html#splitting-strings",
    "href": "lecture-1.html#splitting-strings",
    "title": "Python Introduction",
    "section": "Splitting strings",
    "text": "Splitting strings\nApart from formatting, there are plenty more operations we can perform on strings. We are going to highlight some of the most common here.\nThe first we’re going to look at is splitting a string by a delimiter character using the .split() method. If we don’t pass any argument to the .split() method, then by default, it will split by spaces. However, we can change this by specifying the delimiter.\n    my_string = \"This is a sentence, where each word is separated by a space\"\n    \n    print(my_string.split())\n    print(my_string.split(\",\"))\nResults: \n# =&gt; ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n# =&gt; ['This is a sentence', ' where each word is separated by a space']"
  },
  {
    "objectID": "lecture-1.html#joining-strings-together",
    "href": "lecture-1.html#joining-strings-together",
    "title": "Python Introduction",
    "section": "Joining strings together",
    "text": "Joining strings together\nAs .split() splits a single string into a list, .join() joins a list of strings into a single string. To use .join(), we first create a string of the delimiter we want to use to join the list of strings by. In this example we’re going to use \"-\". Then we call the .join() method, passing the list as an argument.\nThe result is a single string using the delimiter to separate the items of the list.\n    x = ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    \n    print(\"-\".join(x))\nResults: \n# =&gt; This-is-a-sentence,-where-each-word-is-separated-by-a-space"
  },
  {
    "objectID": "lecture-1.html#changing-cases",
    "href": "lecture-1.html#changing-cases",
    "title": "Python Introduction",
    "section": "Changing cases",
    "text": "Changing cases\nOther common operations on strings involve change the case. For example:\n\nMake the entire string uppercase or lowercase\nMaking the string title case (every where starts with a capital letter).\nStripping the string by removing any empty spaces either side of the string.\n\nNote we can chain many methods together by doing .method_1().method_2(), but only if they return string. If they return None, then chaining will not work.\n    x = \"    this String Can change case\"\n    \n    print(x.upper())\n    print(x.lower())\n    print(x.title())\n    print(x.strip())\n    print(x.strip().title())\nResults: \n# =&gt;     THIS STRING CAN CHANGE CASE\n# =&gt;     this string can change case\n# =&gt;     This String Can Change Case\n# =&gt; this String Can change case\n# =&gt; This String Can Change Case"
  },
  {
    "objectID": "lecture-1.html#replacing-parts-of-a-string",
    "href": "lecture-1.html#replacing-parts-of-a-string",
    "title": "Python Introduction",
    "section": "Replacing parts of a string",
    "text": "Replacing parts of a string\nTo replace a substring, we use the .replace() method. The first argument is the old string you want to replace. The second argument is what you want to replace it with.\n    x = \"This is a string that contains some text\"\n    \n    print(x.replace(\"contains some\", \"definitely contains some\"))\nResults: \n# =&gt; This is a string that definitely contains some text"
  },
  {
    "objectID": "lecture-1.html#container-data-typesdata-structures",
    "href": "lecture-1.html#container-data-typesdata-structures",
    "title": "Python Introduction",
    "section": "Container data types/Data structures",
    "text": "Container data types/Data structures\nContainer data types or data structures, as the name suggests, are used to contain other things. Types of containers are:\n\nLists\nDictionaries\nTuples\nSets\n\n    [1, \"hello\", 2]                 # list\n    {\"my-key\": 2, \"your-key\": 1}    # dictionary (or dict)\n    (1, 2)                          # tuple\n    set(1, 2)                       # set\nWe’ll take a look at each of these different container types and explore why we might want to use each of them."
  },
  {
    "objectID": "lecture-1.html#an-aside-on-terminology",
    "href": "lecture-1.html#an-aside-on-terminology",
    "title": "Python Introduction",
    "section": "An aside on Terminology",
    "text": "An aside on Terminology\nTo make our explanations clearer and reduce confusion, each of the different symbols have unique names.\nI will use this terminology consistently throughout the course, and it is common to see the same use outside the course.\n\n[ ] brackets (square brackets).\n{ } braces (curly braces).\n( ) parentheses."
  },
  {
    "objectID": "lecture-1.html#lists",
    "href": "lecture-1.html#lists",
    "title": "Python Introduction",
    "section": "Lists",
    "text": "Lists\nA hetreogenious container. This means that it can store any type of data.\n    x = [1, \"hello\", 2]\nElements can be accessed using indexing [ ] notation. For example:\n    print(x[0])    # this will get the first element (i.e. 1)\n    print(x[1])    # the second element (i.e. \"hello\")\n    print(x[2])    # the third element (i.e. 2)\nResults: \n# =&gt; 1\n# =&gt; hello\n# =&gt; 2\nnotice how the first element is the 0-th item in the list/ we say that python is 0-indexed."
  },
  {
    "objectID": "lecture-1.html#slices",
    "href": "lecture-1.html#slices",
    "title": "Python Introduction",
    "section": "Slices",
    "text": "Slices\nIf we wanted to access an element from a data structure, such as a list, we would use the [ ] accessor, specifying the index of the element we wish to retrieve (remember that indexes start at zero!). But what if we ranted to access many elements at once? Well to accomplish that, we have a slice or a range of indexes (not to be confused with the range function). A slice is defined as:\nstart_index:end_index\nwhere the end_index is non inclusive – it doesn’t get included in the result. Here is an example where we have a list of 6 numbers from 0 to 5, and we slice the list from index 0 to 3. Notice how the 3rd index is not included.\n    x = [0, 1, 2, 3, 4, 5]\n    print(x[0:3])\nResults: \n# =&gt; [0, 1, 2]"
  },
  {
    "objectID": "lecture-1.html#ranges",
    "href": "lecture-1.html#ranges",
    "title": "Python Introduction",
    "section": "Ranges",
    "text": "Ranges\nWhen we use start_index:end_index, the slice increments by 1 from start_index to end_index. If we wanted to increment by a different amount we can use the slicing form:\nstart_index:end_index:step\nHere is an example where we step the indexes by 2:\n    x = list(range(100))\n    print(x[10:15:2])\nResults: \n# =&gt; [10, 12, 14]"
  },
  {
    "objectID": "lecture-1.html#reverse",
    "href": "lecture-1.html#reverse",
    "title": "Python Introduction",
    "section": "Reverse",
    "text": "Reverse\nOne strange fact about the step is that if we specify a negative number for the step, Python will work backwards, and effectively reverse the list.\n    x = list(range(5))\n    \n    print(x[::-1])\nResults: \n# =&gt; [4, 3, 2, 1, 0]\nIn a previous example, I created a slice like 0:3. This was a little wasteful as we can write slightly less code. If we write :end_index, Python assumes and creates a slice from the first index (0) to the end_index. If we write start_index:, Python assumes and creates a slice from start_index to the end of the list.\n    x = list(range(100))\n    \n    print(x[:10])\n    print(x[90:])\nResults: \n# =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n# =&gt; [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]"
  },
  {
    "objectID": "lecture-1.html#indexing-backwards",
    "href": "lecture-1.html#indexing-backwards",
    "title": "Python Introduction",
    "section": "Indexing backwards",
    "text": "Indexing backwards\nFinally, we also work backwards from the end of list. If we use a negative number, such as -1, we are telling Python, take the elements from the end of the list. -1 is the final index, and numbers lower than -1 work further backwards through the list.\n    x = list(range(100))\n    \n    print(x[-1])\n    print(x[-2])\nResults: \n# =&gt; 99\n# =&gt; 98\nSlicing with negative indexes, also works. Here we are creating a slice from the end of the list - 10, to the last (but not including) index.\n    x = list(range(100))\n    \n    print(x[-10:-1])\nResults: \n# =&gt; [90, 91, 92, 93, 94, 95, 96, 97, 98]"
  },
  {
    "objectID": "lecture-1.html#adding-data-to-a-list",
    "href": "lecture-1.html#adding-data-to-a-list",
    "title": "Python Introduction",
    "section": "Adding data to a list",
    "text": "Adding data to a list\nIf we want to add items to the end of the list, we use the append function:\n    my_list = []\n    \n    my_list.append(\"all\")\n    my_list.append(\"dogs\")\n    my_list.append(\"bark\")\n    \n    print(my_list)\nResults: \n# =&gt; ['all', 'dogs', 'bark']"
  },
  {
    "objectID": "lecture-1.html#dictionaries",
    "href": "lecture-1.html#dictionaries",
    "title": "Python Introduction",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries are a little different from lists as each ‘element’ consists of a key-pair value. Let’s have a look at some examples where the dictionaries contains one element:\n    my_dictionary = {\"key\": \"value\"}\n    my_other_dict = {\"age\": 25}\nTo access the value, we get it using [key] notation:\n    my_other_dict[\"age\"]\nResults: \n# =&gt; 25\nNOTE keys are unique, i.e:\n    my_dictionary = {\"age\": 25, \"age\": 15}\n    my_dictionary[\"age\"]\nResults: \n# =&gt; 15\nThe key in the dictionary doesn’t necessarily need to be a string. For example, in this case, we have created two key-pair elements, where the keys to both are tuples of numbers.\n    my_dictionary = {(1, 2): \"square\", (3, 4): \"circle\"}\n    \n    print(my_dictionary[(1, 2)])\nResults: \n# =&gt; square\n\nadding data\nIf we want to add data to a dictionary, we simply perform the accessor method with a key that is not in the dictionary:\n    my_dict = {}\n    \n    my_dict[\"name\"] = \"James\"\n    my_dict[\"age\"] = 35\n    \n    print(my_dict)\nResults: \n# =&gt; {'name': 'James', 'age': 35}\n\n\nQuick Exercise\n\nCreate a dictionary for the following address, and assign it a variable name called address:\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\nnumber\n\n\n22\n\n\n\n\nstreet\n\n\nBakers Street\n\n\n\n\ncity\n\n\nLondon\n\n\n\n\n\n\nPrint out the address’s street name using the [ ] accessor with the correct key."
  },
  {
    "objectID": "lecture-1.html#tuples",
    "href": "lecture-1.html#tuples",
    "title": "Python Introduction",
    "section": "Tuples",
    "text": "Tuples\n    my_tuple = (1, 56, -2)\nLike lists, elements of the tuple can be accessed by their position in the list, starting with the 0-th element:\n    print(my_tuple[0])  # =&gt; 1\n    print(my_tuple[1])  # =&gt; 56\n    print(my_tuple[2])  # =&gt; -2\nResults: \n# =&gt; 1\n# =&gt; 56\n# =&gt; -2\nUnlike lists, tuples cannot be changed after they’ve been created. We say they are immutable. So this will not work:\n    my_tuple[2] = \"dogs\"  # creates an Error\nResults: \n# =&gt; Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/tmp/pyKdIIcx\", line 18, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment"
  },
  {
    "objectID": "lecture-1.html#sets",
    "href": "lecture-1.html#sets",
    "title": "Python Introduction",
    "section": "Sets",
    "text": "Sets\nSets in Python are like tuples, but contain only unique elements.\nYou can use the set( ) function (more on functions later!), supplying a list, to create a set:\n    my_set = set([1, 2, 2, 2, 3, 4])\n    my_set\nResults: \n# =&gt; {1, 2, 3, 4}\nNotice how there is only one ‘2’ in the resulting set, duplicate elements are removed.\n\nadding data\nIf we want to add data to a set, we use the .add() method. The element used as an argument to this function will only be added to the set if it is not already in the set.\n    my_set = set([])\n    \n    my_set.add(1)\n    my_set.add(2)\n    my_set.add(1)\n    \n    print(my_set)\nResults: \n# =&gt; {1, 2}"
  },
  {
    "objectID": "lecture-1.html#if-statement",
    "href": "lecture-1.html#if-statement",
    "title": "Python Introduction",
    "section": "If statement",
    "text": "If statement\nIf statements allow for branching paths of execution. In other words, we can execute some statements if some conditions holds (or does not hold).\nThe structure of a simple if statement is:\nif &lt;condition&gt;:\n    &lt;body&gt;\n    x = 2\n    y = \"stop\"\n    \n    if x &lt; 5:\n        print(\"X is less than five\")\n    if y == \"go\":\n        print(\"All systems go!!\")\nResults: \n# =&gt; X is less than five\nIn the previous example, the first print statement was only executed if the x &lt; 5 evaluates to True, but in python, we can add another branch if the condition evaluates to False. This branch is denoted by the else keyword.\n    x = 10\n    \n    if x &lt; 5:\n        print(\"X is less than five\")\n    else:\n        print(\"X is greater than or equal to five\")\nResults: \n# =&gt; X is greater than or equal to five"
  },
  {
    "objectID": "lecture-1.html#does-it-contain-a-substring",
    "href": "lecture-1.html#does-it-contain-a-substring",
    "title": "Python Introduction",
    "section": "does it contain a substring?",
    "text": "does it contain a substring?\nWe can check if a string exists within another string using the in keyword. This returns a Boolean value, so we can use it as a condition to an if statement.\n    x = \"This is a string that contains some text\"\n    \n    if \"text\" in x:\n        print(\"It exists\")\nResults: \n# =&gt; It exists"
  },
  {
    "objectID": "lecture-1.html#if-statement-quick-exercise",
    "href": "lecture-1.html#if-statement-quick-exercise",
    "title": "Python Introduction",
    "section": "If statement – Quick Exercise",
    "text": "If statement – Quick Exercise\n\nCreate a variable called age and assign the value of this variable 35.\nCreate and if statement that prints the square of age if the value of age is more than 24.\nThis if statement should have an else condition, that prints age divided by 2.\nWhat is the printed value?"
  },
  {
    "objectID": "lecture-1.html#multiple-paths",
    "href": "lecture-1.html#multiple-paths",
    "title": "Python Introduction",
    "section": "Multiple paths",
    "text": "Multiple paths\nIf we wanted to add multiple potential paths, we can add more using the elif &lt;condition&gt; keywords.\nNote: The conditions are checked from top to bottom, only executing the else if none evaluate to True. The first condition that evaluates to True is executed, the rest are skipped.\nx = 15\n\nif x &lt; 5:\n    print(\"X is less than five\")\nelif x &gt; 10:\n    print(\"X is greater than ten\")\nelse:\n    print(\"X is between five and ten\")\n\nResults: \n# =&gt; X is greater than ten"
  },
  {
    "objectID": "lecture-1.html#inline-if-statements",
    "href": "lecture-1.html#inline-if-statements",
    "title": "Python Introduction",
    "section": "Inline if-statements",
    "text": "Inline if-statements\nSometimes, we might want to conditionally set a variable a value. For this, we can use an inline if statement. The form of an inline if statement is:\n&lt;value-if-true&gt; if &lt;condition&gt; else &lt;value-if-false&gt;\nx = 10\n\ny = 5 if x &gt; 5 else 2\n\nprint(x + y)\n\nResults: \n# =&gt; 15"
  },
  {
    "objectID": "lecture-1.html#boolean-logic",
    "href": "lecture-1.html#boolean-logic",
    "title": "Python Introduction",
    "section": "Boolean Logic",
    "text": "Boolean Logic\nAs we’ve seen, if statements are checking for conditions to evaluate to True or False. In python we use various comparison operators to check for conditions that evaluate to Booleans.\n\nComparison operators\n\n&lt; less than\n&lt;= less than or equal to\n&gt; greater than\n&gt;= greater than or equal to\n== is equal to\nnot negation\n\nIf we want to check for multiple conditions, we can use conjunctives or disjunctive operators to combine the Boolean formulas.\nConjunctives/Disjunctives\n\nand all boolean expressions must evaluate to true\nor only one expression needs to be true\n\n\n\nNot\nUsing not you can invert the Boolean result of the expression.\nprint(not True)\n\nResults: \n# =&gt; False\n\nx = 10\n\nif not x == 11:\n    print(\"X is not 11\")\n\nResults: \n# =&gt; X is not 11\n\n\nAnd\nLet’s take an example using the and keyword. and here is checking that x is above or equal to 10 and y is exactly 5. If either of the conditions is False, python will execute the else path (if there is one, of course!).\nx = 10\ny = 5\n\nif x &gt;= 10 and y == 5:\n    z = x + y\nelse:\n    z = x * y\n\nprint(z)\n\nResults: \n# =&gt; 15\n\n\nOr\nHere we see the use of the or keyword. If any of the conditions evaluates to True then the whole condition evaluates to True.\nx = 10\ny = 5\n\nif x &lt; 5 or y == 5:\n    print(\"We got here!\")\nelse:\n    print(\"We got here instead...\")\n\nResults: \n# =&gt; We got here!\nNote: or is short-circuiting. This means that if tests the conditions left-to-right, and when it finds something that is True it stops evaluating the rest of the conditions.\nx = 10\n\nif x &lt; 20 or print(\"We got to this condition\"):\n    print(\"The value of x is\", x) \n\nResults: \n# =&gt; The value of x is 10\n\n\nCombining And and Or\nIf your Boolean logic refers to a single variable, you can combine the logic without the and and or. But its not always common.\nFor example,\nx = 7\n\nif x &lt; 10 and x &gt; 4:\n    print(\"X is between 5 and 10\")\nCan be the same as:\nx = 7\n\nif 5 &lt; x &lt; 10:\n    print(\"X is between 5 and 10\")\n\nResults: \n# =&gt; X is between 5 and 10"
  },
  {
    "objectID": "lecture-1.html#for-loop",
    "href": "lecture-1.html#for-loop",
    "title": "Python Introduction",
    "section": "For loop",
    "text": "For loop\nLooping or iteration allows us to perform a series of actions multiple times. We are going to start with the more useful for loop in python. The syntax of a for loop is:\nfor &lt;variable_name&gt; in &lt;iterable&gt;:\n    &lt;body&gt;\n\nfor i in range(3):\n    print(i)\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2"
  },
  {
    "objectID": "lecture-1.html#break",
    "href": "lecture-1.html#break",
    "title": "Python Introduction",
    "section": "break",
    "text": "break\nThe previous example loops over the body a fix number of times. But what if we wanted to stop looping early? Well, we can use the break keyword. This keyword will exit the body of the loop.\nfor i in range(10):\n    if i &gt; 5:\n        break\n    print(i)\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2\n# =&gt; 3\n# =&gt; 4\n# =&gt; 5"
  },
  {
    "objectID": "lecture-1.html#continue",
    "href": "lecture-1.html#continue",
    "title": "Python Introduction",
    "section": "continue",
    "text": "continue\nA different keyword you might want to use is continue. Continue allows you to move/skip onto the next iteration without executing the entire body of the for loop.\nfor i in range(10):\n    if i % 2 == 0:\n        continue\n    print(i)\n\nResults: \n# =&gt; 1\n# =&gt; 3\n# =&gt; 5\n# =&gt; 7\n# =&gt; 9"
  },
  {
    "objectID": "lecture-1.html#ranges-1",
    "href": "lecture-1.html#ranges-1",
    "title": "Python Introduction",
    "section": "ranges",
    "text": "ranges\nInstead of using continue like in the previous slide, the range function provides us with some options:\nrange(start, stop, step)\nIn this example, we are starting our iteration at 10, ending at 15, but stepping the counter 2 steps.\nfor i in range(10, 15, 2):\n    print(i)\n\nResults: \n# =&gt; 10\n# =&gt; 12\n# =&gt; 14"
  },
  {
    "objectID": "lecture-1.html#loop-over-collections",
    "href": "lecture-1.html#loop-over-collections",
    "title": "Python Introduction",
    "section": "Loop over collections",
    "text": "Loop over collections\nFor loops allow us to iterate over a collection, taking one element at a time. Take for example, a list, and for every item in the list we print its square.\nmy_list = [1, 5, 2, 3, 5.5]\n\nfor el in my_list:\n    print(el**2)\n\nResults: \n# =&gt; 1\n# =&gt; 25\n# =&gt; 4\n# =&gt; 9\n# =&gt; 30.25\nThis kind of looping can work for tuples and sets, but as we have seen, dictionaries are a little different. Every ‘element’ in a dictionary consists of a key and a value. Therefore when we iterate over items in a dictionary, we can assign the key and value to different variables in the loop.\nNote the use of the .items() after the dictionary. We will explore this later.\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor el_key, el_val in my_dict.items():\n    print(\"Key is:\", el_key, \" value is: \", el_val)\n\nResults: \n# =&gt; Key is: name  and the value is:  jane\n# =&gt; Key is: age  and the value is:  35\n# =&gt; Key is: location  and the value is:  France\nWe could also loop over the keys in the dictionary using the .keys() method instead of .items().\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor the_key in my_dict.keys():\n    print(the_key)\n\nResults: \n# =&gt; name\n# =&gt; age\n# =&gt; loc\nOr, the values using .values().\nmy_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n\nfor the_value in my_dict.values():\n    print(the_value)\n\nResults: \n# =&gt; jane\n# =&gt; 35\n# =&gt; France"
  },
  {
    "objectID": "lecture-1.html#list-comprehensions",
    "href": "lecture-1.html#list-comprehensions",
    "title": "Python Introduction",
    "section": "List comprehensions",
    "text": "List comprehensions\nWe have seen previously how for loops work. Knowing the syntax of a for loop and wanting to populate a list with some data, we might be tempted to write:\nx = []\nfor i in range(3):\n    x.append(i)\n\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2]\nWhile this is perfectly valid Python code, Python itself provides ‘List comprehensions’ to make this process easier.\nx = [i for i in range(3)]\nThe syntax of a list comprehensions is:\n[ &lt;variable&gt; for &lt;variable&gt; in &lt;iterable&gt; ]\nWe can also perform similar actions with a dictionary\n[ &lt;key&gt;, &lt;value&gt; for &lt;key&gt;, &lt;value&gt; in &lt;dictionary.items()&gt; ]\n\nusing if’s\nPerhaps we only want to optionally perform an action within the list comprehension? Python allows us to do this with the inline if statement we’ve seen in the previous lecture.\nx = [i if i &lt; 5 else -1 for i in range(7)]\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2, 3, 4, -1, -1]\nWe add the inline &lt;var&gt; if &lt;condition&gt; else &lt;other-var&gt; before the for loop part of the comprehension.\nThere is another type of if statement in a list comprehension, this occurs when we don’t have an else.\nx = [i for i in range(7) if i &lt; 3]\nprint(x)\n\nResults: \n# =&gt; [0, 1, 2]\nIn this example, we’re only ‘adding’ to the list if the condition (\\(i &lt; 3\\)) is true, else the element is not included in the resulting list.\n\n\nmultiple for’s\nIf we like, we can also use nested for loops by simply adding another for loop into the comprehension.\nx = [(i, j) for i in range(2) for j in range(2)]\n\nprint(x)\n\nResults: \n# =&gt; [(0, 0), (0, 1), (1, 0), (1, 1)]\nIn this example, we’re creating a tuple for each element, effectively each combination of 1 and 0."
  },
  {
    "objectID": "lecture-1.html#list-comprehensions-with-dictionary",
    "href": "lecture-1.html#list-comprehensions-with-dictionary",
    "title": "Python Introduction",
    "section": "List comprehensions with dictionary",
    "text": "List comprehensions with dictionary\nPython doesn’t restrict us to list comprehensions, but we can do a similar operation to create a dictionary.\nx = [2, 5, 6]\ny = {idx: val for idx, val in enumerate(x)}\nprint(y)\n\nResults: \n# =&gt; {0: 2, 1: 5, 2: 6}\nHere, every item in x has been associated with its numerical index as a key thanks to the enumerate function that returns both the index and value at iteration in the for loop."
  },
  {
    "objectID": "lecture-1.html#for-loop-quick-exercise",
    "href": "lecture-1.html#for-loop-quick-exercise",
    "title": "Python Introduction",
    "section": "For loop – Quick Exercise",
    "text": "For loop – Quick Exercise\n\nCreate a list of elements:\n\n2\n“NA”\n24\n5\n\nUse a for loop to iterate over this list.\nIn the body of the for loop, compute \\(2x + 1\\), where \\(x\\) is the current element of the list.\nStore the result of this computation in a new variable \\(y\\), and then print y.\n\nNote You cannot compute \\(2x + 1\\) of “NA”, therefore you will to use an if statement to skip onto the next iteration if it encounters this. Hint try: type(...) =!= str"
  },
  {
    "objectID": "lecture-1.html#while-loop",
    "href": "lecture-1.html#while-loop",
    "title": "Python Introduction",
    "section": "While loop",
    "text": "While loop\nA while loop is another looping concept like for but it can loop for an arbitrary amount of times. A while loop looks to see if the condition is True, and if it is, it will execute the body.\nThe syntax of the while loop is:\nwhile &lt;condition&gt;:\n    &lt;body&gt;\n\ni = 0\n\nwhile i &lt; 3:\n    print(i)\n    i = i + 1\n\nResults: \n# =&gt; 0\n# =&gt; 1\n# =&gt; 2\n\nx = 0\ny = 1\nHere is another example:\nwhile x + y &lt; 10:\n    print(\"X is,\", x, \"and y is\", y)\n    x = x + 1\n    y = y * 2\n\nprint(\"X ended as\", x, \", while y is\", y)\n\nResults: \n# =&gt; X is, 0 and y is 1\n# =&gt; X is, 1 and y is 2\n# =&gt; X is, 2 and y is 4\n# =&gt; X ended as 3 , while y is 8"
  },
  {
    "objectID": "lecture-1.html#example-usage-of-a-function",
    "href": "lecture-1.html#example-usage-of-a-function",
    "title": "Python Introduction",
    "section": "Example usage of a function",
    "text": "Example usage of a function\nLet’s make a function that takes two numbers and adds them together:\ndef my_addition(a, b):\n    result = a + b\n    return result\n\nx = 2\ny = 3\nz = my_addition(2, 3)  # return 5 and stores in z\nprint(z)\n\nResults: \n# =&gt; 5"
  },
  {
    "objectID": "lecture-1.html#quick-exercise-1",
    "href": "lecture-1.html#quick-exercise-1",
    "title": "Python Introduction",
    "section": "Quick exercise",
    "text": "Quick exercise\n\nCreate a function called my_square. This function should take one argument (you can call this argument what you like).\nThe body of the function should compute and return the square of the argument.\nCall this function with 5.556.\nStore the result of calling this function, and print it.\nWhat is the result?"
  },
  {
    "objectID": "lecture-1.html#re-usability-with-functions",
    "href": "lecture-1.html#re-usability-with-functions",
    "title": "Python Introduction",
    "section": "Re-usability with Functions",
    "text": "Re-usability with Functions\nFunctions are better illustrated through some examples, so let’s see some!\nname_1 = \"john\"\nname_2 = \"mary\"\nname_3 = \"michael\"\n\nprint(\"Hello \" + name_1 + \", how are you?\")\nprint(\"Hello \" + name_2 + \", how are you?\")\nprint(\"Hello \" + name_3 + \", how are you?\")\nThe above is pretty wasteful. Why? Because we are performing the exact same operation multiple times, with only the variable changed.\nBy abstracting the actions we want to perform into a function, we can ultimately reduce the amount of code we write. Be a lazy programmer!\nname_1 = \"john\"\nname_2 = \"mary\"\nname_3 = \"michael\"\n\ndef say_hello(name):\n    print(\"Hello \" + name + \", how are you?\")\n\nsay_hello(name_1)\nsay_hello(name_2)\nsay_hello(name_3)\nIn this example, we’ve used the function as defined with the def pattern to write the print statement once. Then, we’ve called the function with each variable as its argument."
  },
  {
    "objectID": "lecture-1.html#named-parameters",
    "href": "lecture-1.html#named-parameters",
    "title": "Python Introduction",
    "section": "Named parameters",
    "text": "Named parameters\nWe’ve seen in previous examples that, when we create a function, we give each of the arguments (if there are any) a name.\nWhen calling this function, we can specify these same names such as:\ndef say_hello(name):\n    print(\"Hello,\", name)\n\nsay_hello(\"Micheal\")\nsay_hello(name=\"Micheal\")\n\nResults: \n# =&gt; Hello, Micheal\n# =&gt; Hello, Micheal\nBy specifying the name of the parameter we’re using with the called function, we can change the order\ndef say_greeting(greeting, name):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(name=\"John\", greeting=\"Hi\")\n\nResults: \n# =&gt; Hi John I hope you're having a good day"
  },
  {
    "objectID": "lecture-1.html#optionaldefaultpositional-arguments",
    "href": "lecture-1.html#optionaldefaultpositional-arguments",
    "title": "Python Introduction",
    "section": "Optional/Default/Positional arguments",
    "text": "Optional/Default/Positional arguments\nWhen we call a function with arguments without naming them, we are supplying them by position.\ndef say_greeting(greeting, name):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(#first position, #section position)\nThe first position gets mapped to variable name of greeting inside the body of the say_greeting function, while the second position gets mapped to name.\nSometimes when creating a function we may want to use default arguments, these are arguments that are used if the call to the function does not specify what their value should be. For example.\ndef say_greeting(name, greeting=\"Hello\"):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(\"John\")\nsay_greeting(\"John\", \"Hi\")  # supply greeting as positional argument\n\nResults: \n# =&gt; Hello John I hope you're having a good day\n# =&gt; Hi John I hope you're having a good day\nNote if you supply a default argument in the function definition, all arguments after this default argument must also supply a default argument.\nSo, this won’t work:\ndef say_greeting(name=\"Jane\", greeting):\n    print(greeting, name, \"I hope you're having a good day\")\n\nsay_greeting(\"John\", \"Hi\")"
  },
  {
    "objectID": "lecture-1.html#recap-on-arguments",
    "href": "lecture-1.html#recap-on-arguments",
    "title": "Python Introduction",
    "section": "Recap on arguments",
    "text": "Recap on arguments\n# defining the function\n\ndef say_greeting(name, greeting)  # no default arguments\ndef say_greeting(name, greeting=\"Hello\")  # greeting is a default argument\ndef say_greeting(name=\"Jane\", greeting=\"Hello\")  # both arguments have a default\n\n# calling the functions\n\nsay_greeting(\"John\", \"Hi\")  # both arguments are provided by position\nsay_greeting(name=\"John\", greeting=\"Hi\")  # arguments are supplied by name\nsay_greeting(greeting=\"Hi\", name=\"John\")  # the position of named arguments do not matter"
  },
  {
    "objectID": "lecture-1.html#function-doc-strings",
    "href": "lecture-1.html#function-doc-strings",
    "title": "Python Introduction",
    "section": "Function doc-strings",
    "text": "Function doc-strings\nTo make it clear for a human to quickly understand what a function is doing, you can add an optional doc-string. This is a string that is added directly after the initial definition of the function:\ndef my_function(x, y):\n    \"\"\"I am a docstring!!!\"\"\"\n    return x + y\nSome common use cases for docstrings are explaining what the parameters are that it expects, and what it returns.\nIf your explanation is a little longer than a line, a multiline docstring can be created as long as you’re using \"\"\" three quotation marks either side of the string\ndef my_function(x, y):\n    \"\"\"\n    This is my realllly long docstring\n    that explains how the function works. But sometimes\n    its best not to explain the obvious\n    \"\"\"\n    return x + y"
  },
  {
    "objectID": "lecture-1.html#understanding-scope",
    "href": "lecture-1.html#understanding-scope",
    "title": "Python Introduction",
    "section": "Understanding scope",
    "text": "Understanding scope\nIn this example we have two scopes which can be easily seen by the indentation. The first is the global scope. The second scope is the scope of the function. The scope of the function can reference variables in the larger scope. But once the function scope exits, we can no longer reference the variables from the function.\nx = 10\n\ndef compute_addition(y):\n    return x + y\n\nprint(compute_addition(10))\nprint(x)\nprint(y)  # does not work\n\nResults: \n# =&gt; 20\n# =&gt; 10\nEven though we can reference the global scope variable from the scope of the function, we can’t modify it like this:\nx = 10\n\ndef compute_addition_2(y):\n    x = x + 5  # error local variable referenced before assignment\n    return x + y\n\nprint(compute_addition_2(10))\nIf we really wanted to reference a variable in a global scope and modify its value, we could use the global keyword. Doing this makes the function output something different every time it is called. This can make it difficult to debug incorrect programs.\nx = 10\n\ndef compute_addition_2(y):\n    global x\n    x = x + 5\n    return x + y\n\nprint(compute_addition_2(10))\nprint(x)\nprint(compute_addition_2(10))\n\nResults: \n# =&gt; 25\n# =&gt; 15\n# =&gt; 30\nIn almost all cases, avoid using global variables. Instead pass the variables as parameters. This can reduce a source of potential errors and ensure that if a function is called multiple times, the output can be more consistent and expected.\nx = 10\n\ndef compute_addition_3(x, y):\n    x = x + 5\n    return x + y\n\nprint(compute_addition_3(x, 10))\nprint(x)\nprint(compute_addition_3(x, 10))\n\nResults: \n# =&gt; 25\n# =&gt; 10\n# =&gt; 25"
  },
  {
    "objectID": "lecture-1.html#library-system",
    "href": "lecture-1.html#library-system",
    "title": "Python Introduction",
    "section": "Library system",
    "text": "Library system"
  },
  {
    "objectID": "lecture-1.html#use-what-youve-learnt",
    "href": "lecture-1.html#use-what-youve-learnt",
    "title": "Python Introduction",
    "section": "Use what you’ve learnt!",
    "text": "Use what you’ve learnt!\nWe’re going to create a library system to help locate and lookup information about books. For example, we want to know the author of book called ‘Moby Dick’.\nTo create this system, we are going to do it in stages. First, we will want to create our database of books:\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1879\n\n\n\n\n\nOur database is going to be a list of dictionaries. Where each dictionary is a row from this table. For example, one of the dictionaries will have the key “title” and a value “Moby Dick”.\nCreate this database and call it db."
  },
  {
    "objectID": "lecture-1.html#locating-books",
    "href": "lecture-1.html#locating-books",
    "title": "Python Introduction",
    "section": "Locating Books",
    "text": "Locating Books\n\nCreate a function called locate_by_title that takes the database to look through, and the title to look up as arguments.\nThis function should check each dictionary, and if the title is the same as what was searched for, it should return the whole dictionary.\nTest this function by calling the locate_by_title function with db and \"Frankenstein\". You should get {\"title\": \"Frankenstein\", \"author\": ...}.\n\nNote you should include docstrings to describe the arguments to the function, and what it will return."
  },
  {
    "objectID": "lecture-1.html#selecting-a-subset",
    "href": "lecture-1.html#selecting-a-subset",
    "title": "Python Introduction",
    "section": "Selecting a subset",
    "text": "Selecting a subset\nNow that we can find books by the title name, we also want to find all books that were released after a certain data.\n\nCreate a function called books_released_after that takes two arguments: the database to look through, and the year.\nThis function should look through the database, if it finds a book that was released after the year, it should add it to a list of books that is returned from this function.\nTest this function by calling books_released_after with db and 1850. This function call should return a list containing three dictionaries. The first entry should be ‘Moby Dick’ and the section should be ‘A Study in Scarlet’, etc."
  },
  {
    "objectID": "lecture-1.html#updating-our-database",
    "href": "lecture-1.html#updating-our-database",
    "title": "Python Introduction",
    "section": "Updating our database",
    "text": "Updating our database\nOh no! ‘Hitchhikers Guide to the Galaxy’ was released in 1979 not 1879, there must have been a typo. Let’s create a function to update this.\n\nCreate a function called update, that takes 5 arguments: 1) the database to update, 2) the key of the value we want to update 3) the value we want to update it to 4) the key we want to check to find out if we have the correct book and 5) the value of the key to check if we have the correct book.\nupdate(db,\n       key=\"release year\",\n       value=1979,\n       where_key=\"title\",\n       where_value=\"Hitchhikers Guide to the Galaxy\")"
  },
  {
    "objectID": "lecture-1.html#extended-exercise",
    "href": "lecture-1.html#extended-exercise",
    "title": "Python Introduction",
    "section": "Extended exercise",
    "text": "Extended exercise\n\nIn the previous steps we created functions locate_by_title and books_released_after. These two functions are similar in a way that they are selecting a subset of our database (just by different criteria).\nFor this harder exercise, can we create a single function called query that allows us to do both locate_by_title and books_released_after.\nAn example call to this query function may look like:\nresults = query(db,\n                where_key=\"title\",\n                where_value=\"Moby Dick\",\n                where_qualifier=\"exactly\")\nwhere_qualifier should accept strings like \"exactly\", \"greater than\", and \"less       than\"."
  },
  {
    "objectID": "lecture-3-reveal.html#importing-in-python",
    "href": "lecture-3-reveal.html#importing-in-python",
    "title": "Python Modules",
    "section": "Importing in python",
    "text": "Importing in python\n\nhttps://xkcd.com/353/"
  },
  {
    "objectID": "lecture-3-reveal.html#the-basic-structure-of-importing",
    "href": "lecture-3-reveal.html#the-basic-structure-of-importing",
    "title": "Python Modules",
    "section": "The basic structure of importing",
    "text": "The basic structure of importing\nModules or packages are other scripts or programs that can be imported into other scripts. This definition is very general, but we shall see how flexible importing in Python can be.\nThe basic syntax of importing is:\nimport &lt;package_name&gt;\n\n&lt;package_name&gt;.&lt;function/class/variable/etc&gt;\nIf we import &lt;package_name&gt; using this syntax, we always have to use the dot . syntax to refer to something within this package.\nLet’s take a look at a very basic example.\nimport math\n\nradius = 6.4  # cm\ncircum = 2 * math.pi * radius\nIn this example, we are importing the built-in math package. This package contains a bunch of useful functions and variables. We’re not going to take a look at them here, as we’re focusing on importing, but you can see we’re referring to a variable called pi to calculate the circumference of a circle."
  },
  {
    "objectID": "lecture-3-reveal.html#importing-specific-items",
    "href": "lecture-3-reveal.html#importing-specific-items",
    "title": "Python Modules",
    "section": "Importing specific items",
    "text": "Importing specific items\nIf we didn’t always want to specify the package name when we only want to use something specific from a package, we can directly import that something.\nfrom &lt;package_name&gt; import &lt;function/class/variable/etc&gt;\n\n&lt;function/class/variable/etc&gt;\nAs you can see, we’re using the from ... import ... syntax.\nfrom math import pi\n\ncircumference = 2 * pi * radius"
  },
  {
    "objectID": "lecture-3-reveal.html#dont-do-this",
    "href": "lecture-3-reveal.html#dont-do-this",
    "title": "Python Modules",
    "section": "Don’t do this!",
    "text": "Don’t do this!\nWhen using from ... import ..., there is a wildcard * that we could use. You may sometimes see this style of importing when looking at documentation online:\nfrom &lt;package_name&gt; import *\n\n&lt;function/class/variable/etc&gt;\nHowever, this can create many problems with reading your program code\nWhich module does my_function() originate? Are there are common names between the two? Which would be used?\nfrom my_module import *\nfrom my_second_module import *\n\nmy_function()"
  },
  {
    "objectID": "lecture-3-reveal.html#alias",
    "href": "lecture-3-reveal.html#alias",
    "title": "Python Modules",
    "section": "Alias",
    "text": "Alias\nWhen importing, we can optionally create an alias to a symbol. Here we’re creating an alias to the existing pi in math.\nfrom math import pi as decilious_pi\n\ncircumference = 2 * delicious_pi * radius\nThere are some very common conventions of aliasing very highly used packages that we will definitely revisit in another lecture!\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "lecture-3-reveal.html#importing-local-libraries",
    "href": "lecture-3-reveal.html#importing-local-libraries",
    "title": "Python Modules",
    "section": "Importing local libraries",
    "text": "Importing local libraries\nlet’s consider a hypothetical local directory:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nIf we wanted to import something from my_module.py we would do:\nfrom src.my_module import MyAwesomeClass\n\nmy_class = MyAwesomeclass()\nHere is another example for increased nesting of directories:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nfrom src.module_1 import cats\nfrom src.module_1.dogs import Dog\n\ncat = cats.Cat()\ndog = Dog()"
  },
  {
    "objectID": "lecture-3-reveal.html#quick-exercise-imports",
    "href": "lecture-3-reveal.html#quick-exercise-imports",
    "title": "Python Modules",
    "section": "Quick exercise – imports",
    "text": "Quick exercise – imports\n\nCreate a directory to store your scripts\nIn this directory, create a file called main.py.\nCreate a sub-directory called src. In src create another file called library.py.\nIn library.py create a class (that doesn’t do anything right now) called Database.\nIn main.py, create an instance of Database."
  },
  {
    "objectID": "lecture-3-reveal.html#shortcuts-with-__init__.py",
    "href": "lecture-3-reveal.html#shortcuts-with-__init__.py",
    "title": "Python Modules",
    "section": "Shortcuts with __init__.py",
    "text": "Shortcuts with __init__.py\nLet’s say you often import Cat and Dog. We can use a file called __init__.py to help us and make the imports shorter. This fill gets executed when its module is imported.\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- __init__.py\n            |-- cats.py\n            |-- dogs.py\nIn __init__.py:\nfrom cats import Cat\nfrom dogs import Dog\nIn main.py:\nfrom src.module_1 import Cat, Dog"
  },
  {
    "objectID": "lecture-3-reveal.html#what-is-__main__",
    "href": "lecture-3-reveal.html#what-is-__main__",
    "title": "Python Modules",
    "section": "What is __main__?",
    "text": "What is __main__?\nConsider a file with the following:\nx = 2\ny = 1\nz = x + y\n\nclass MyAwesomeClass:\n...\nIf we import this file in another script, x, y, and z will be computed. In this very simple case this will have very little impact. But what if the computation of these takes a very long time?\nHere we are wrapping any global computations into a appropriate functions. This prevents the global variables being computed as soon as the script is imported.\nNow, if we wanted to compute x, y, and z if this script is run, we could use:\nif __name__ == \"__main__\":\n# do something\nAnything within the scope of the if function will only be run if the current file is the script that is being run directly (i.e. python &lt;the-file&gt;.py). If the script is being imported, the statements within this if scope will not be run.\nSo if we wanted to run compute() if this file is being run directly, we would write:\ndef compute():\n    x = 2\n    y = 1\n    z = x + y\n\nclass MyAwesomeClass:\n    ...\n    \nif __name__ == \"__main__\":\n    compute()\n    # we can of course use MyAwesomeClass as well\n    my_class = MyAwesomeClass()\n    my_class.do_something()"
  },
  {
    "objectID": "lecture-3-reveal.html#current-working-directory",
    "href": "lecture-3-reveal.html#current-working-directory",
    "title": "Python Modules",
    "section": "Current working directory",
    "text": "Current working directory\nThe folder in which you run Python will be the current working directory (CWD). We can print this value with the os.getcwd() function, or change the directory with os.chdir(...). Its important to know what your CWD is as all relative paths (paths that do not start with a ‘/’) will be relative to your CWD.\nimport os\n\nprint(os.getcwd())\nos.chdir(\"../\")\nprint(os.getcwd())\nos.chdir(\"week-3\")`\nResults: \n# =&gt; [...]/Programming Level-up/week-3\n# =&gt; [...]/Programming Level-up\nI’ve replaced the full path printed by Python with [...] so you can see the differences in the paths!"
  },
  {
    "objectID": "lecture-3-reveal.html#listing-directories",
    "href": "lecture-3-reveal.html#listing-directories",
    "title": "Python Modules",
    "section": "Listing directories",
    "text": "Listing directories\nContinuing with our usage of the os package, we can use the listdir function to list all files within a directory.\nprint(os.listdir())\nprint(os.listdir(\"images/\"))\nResults: \n# =&gt; ['images', '__pycache__', 'lecture.pdf', 'lecture.tex', 'data', 'test_file_1.py', 'lecture.org', '_minted-lecture', 'test_file_2.py']\n# =&gt; ['legend-2.png', 'fig-size.png', 'basic.png', 'subplots.png', 'python.png', 'pycharm01.png', 'installing-scikit-learn.png', 'pycharm02.png', 'PyCharm_Icon.png', 'axis.png', 'legend.png', 'complex-pycharm.jpg']\nThis returns a list of files and directory relative to your current working directory. Notice how from this list you cannot tell if something is a file or directory (though the filename does provide some hint)."
  },
  {
    "objectID": "lecture-3-reveal.html#testing-for-files-or-directories",
    "href": "lecture-3-reveal.html#testing-for-files-or-directories",
    "title": "Python Modules",
    "section": "Testing for files or directories",
    "text": "Testing for files or directories\nIn the previous example we saw that the items returned by listdir does not specify if the item is a file or directory. However, os provides an isfile function in the path submodule to test if the argument is a file, else it will be a directory.\nfor path in os.listdir():\n    print(f\"{path} =&gt; is file: {os.path.isfile(path)}\")\nResults: \n# =&gt; images =&gt; is file: False\n# =&gt; __pycache__ =&gt; is file: False\n# =&gt; lecture.pdf =&gt; is file: True\n# =&gt; lecture.tex =&gt; is file: True\n# =&gt; data =&gt; is file: False\n# =&gt; test_file_1.py =&gt; is file: True\n# =&gt; lecture.org =&gt; is file: True\n# =&gt; _minted-lecture =&gt; is file: False\n# =&gt; test_file_2.py =&gt; is file: True"
  },
  {
    "objectID": "lecture-3-reveal.html#using-wildcards",
    "href": "lecture-3-reveal.html#using-wildcards",
    "title": "Python Modules",
    "section": "Using wildcards",
    "text": "Using wildcards\nIf we wanted to get all files within a directory, we could use the glob function from the glob package. glob allows us to use the * wildcard. E.g. *.png will list all files that end with .png. test-* will list all files that start with test-*.\nfrom glob import glob\n\nfor fn in glob(\"images/*\"):\n    print(fn)\nResults: \n# =&gt; images/legend-2.png\n# =&gt; images/fig-size.png\n# =&gt; images/basic.png\n# =&gt; images/subplots.png\n# =&gt; images/python.png\n# =&gt; images/pycharm01.png\n# =&gt; images/installing-scikit-learn.png\n# =&gt; images/pycharm02.png\n# =&gt; images/PyCharm_Icon.png\n# =&gt; images/axis.png\n# =&gt; images/legend.png\n# =&gt; images/complex-pycharm.jpg"
  },
  {
    "objectID": "lecture-3-reveal.html#pathlib-a-newer-way",
    "href": "lecture-3-reveal.html#pathlib-a-newer-way",
    "title": "Python Modules",
    "section": "Pathlib – a newer way",
    "text": "Pathlib – a newer way\npathlib is a somewhat recent addition to the Python standard library which makes working with files a little easier. Firstly, we can create a Path object, allowing us to concatenate paths with the /. Instead of using the glob module, a Path object has a glob class method.\nfrom pathlib import Path\n\ndata_dir = Path(\"data\")\nprocessed_data = data_dir / \"processed\"\n\ndata_files = processed_data.glob(\"*.txt\")\n\nfor data_file in data_files:\n    print(data_file)\nResults: \n# =&gt; data/processed/data-2.txt\n# =&gt; data/processed/data.txt"
  },
  {
    "objectID": "lecture-3-reveal.html#pathlib-convenient-functions",
    "href": "lecture-3-reveal.html#pathlib-convenient-functions",
    "title": "Python Modules",
    "section": "Pathlib – convenient functions",
    "text": "Pathlib – convenient functions\npathlib allows us to easily decompose a path into different components. Take for example getting the filename of a path with .name.\nfrom pathlib import Path\n\nsome_file = Path(\"data/processed/data.txt\")\n\nprint(some_file.parts)  # get component parts\nprint(some_file.parents[0])  # list of parent dirs\nprint(some_file.name)   # only filename\nprint(some_file.suffix) # extension\nResults: \n# =&gt; ('data', 'processed', 'data.txt')\n# =&gt; data/processed\n# =&gt; data.txt\n# =&gt; .txt"
  },
  {
    "objectID": "lecture-3-reveal.html#converting-path-into-a-string",
    "href": "lecture-3-reveal.html#converting-path-into-a-string",
    "title": "Python Modules",
    "section": "Converting Path into a string",
    "text": "Converting Path into a string\nAs pathlib is a recent addition to Python, some functions/classes are expecting a str representation of the path, not a Path object. Therefore, you may want to use the str function to convert a Path object to a string.\nstr(Path(\"data/\"))\nResults: \n# =&gt; 'data'"
  },
  {
    "objectID": "lecture-3-reveal.html#quick-exercise-locating-files",
    "href": "lecture-3-reveal.html#quick-exercise-locating-files",
    "title": "Python Modules",
    "section": "Quick exercise – locating files",
    "text": "Quick exercise – locating files\n\nIn the same directory of scripts you created in the last exercise, create another directory called data.\nIn data, create 3 text files, calling them &lt;book_name&gt;.txt.\nThese each text file should contain the information from table below in the format:\nName:  Author:  Release Year: \n\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1979\n\n\n\n\n\n\nFrom main.py, print out all of the text files in the directory."
  },
  {
    "objectID": "lecture-3-reveal.html#reading-files",
    "href": "lecture-3-reveal.html#reading-files",
    "title": "Python Modules",
    "section": "Reading files",
    "text": "Reading files\nTo read a file, we must first open it with the open function. This returns a file stream to which we can call the read() class method.\nYou should always make sure to call the close() class method on this stream to close the file.\nread() reads the entire contents of the file and places it into a string.\nopen_file = open(str(Path(\"data\") / \"processed\" / \"data.txt\"))\ncontents_of_file = open_file.read()\nopen_file.close()  # should always happen!\nprint(contents_of_file)\nResults: \n# =&gt; this is some data\n# =&gt; on another line"
  },
  {
    "objectID": "lecture-3-reveal.html#reading-files-lines-or-entire-file",
    "href": "lecture-3-reveal.html#reading-files-lines-or-entire-file",
    "title": "Python Modules",
    "section": "Reading files – lines or entire file?",
    "text": "Reading files – lines or entire file?\nWhile read works for the last example, you may want to read files in different ways. Luckily there are a number of methods you could use.\nopen_file.read()       # read entire file\nopen_file.readline()   # read a single line\nopen_file.readline(5)  # read 5 lines\nopen_file.readlines()  # returns all lines as a list\n\nfor line in open_file:  # read one line at a time\n    do_something(line)"
  },
  {
    "objectID": "lecture-3-reveal.html#the-with-keyword",
    "href": "lecture-3-reveal.html#the-with-keyword",
    "title": "Python Modules",
    "section": "The with keyword",
    "text": "The with keyword\nIt can be a pain to remember to use the .close() every time you open a file. In Python, we can use open() as a context with the with keyword. This context will handle the closing of the file as soon as the scope is exited.\nThe syntax for opening a file is as follows:\nwith open(\"data/processed/data.txt\", \"r\") as open_file:\n    contents = open_file.read()\n\n# the file is automatically closed at this point\n\n    print(contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line"
  },
  {
    "objectID": "lecture-3-reveal.html#writing-files",
    "href": "lecture-3-reveal.html#writing-files",
    "title": "Python Modules",
    "section": "Writing files",
    "text": "Writing files\nThe syntax for writing a file is similar to reading a file. The main difference is the use \"w\" instead of \"r\" in the second argument of open. Also, instead of read(), we use write().\ndata = [\"this is some data\", \"on another line\", \"with another line\"]\nnew_filename = \"data/processed/new-data.txt\"\n\nwith open(new_filename, \"w\") as open_file:\n    for line in data:\n        open_file.write(line + \"\\n\")\n\nwith open(new_filename, \"r\") as open_file:\n    new_contents = open_file.read()\n\nprint(new_contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line\n# =&gt; with another line"
  },
  {
    "objectID": "lecture-3-reveal.html#appending-to-files",
    "href": "lecture-3-reveal.html#appending-to-files",
    "title": "Python Modules",
    "section": "Appending to files",
    "text": "Appending to files\nEvery time we write to a file, the entire contents is deleted and replaced. If we want to just append to the file instead, we use \"a\".\ndata = [\"this is some appended data\"]\nnew_filename = \"data/processed/new-data.txt\"\n\nwith open(new_filename, \"a\") as open_file:\n    for line in data:\n        open_file.write(line + \"\\n\")\n\nwith open(new_filename, \"r\") as open_file:\n    new_contents = open_file.read()\n\nprint(new_contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line\n# =&gt; with another line\n# =&gt; this is some appended data"
  },
  {
    "objectID": "lecture-3-reveal.html#quick-exercise-readingwriting-files",
    "href": "lecture-3-reveal.html#quick-exercise-readingwriting-files",
    "title": "Python Modules",
    "section": "Quick exercise – reading/writing files",
    "text": "Quick exercise – reading/writing files\n\nUsing the same text files from the previous exercise, we will want to be able to read each text file, and parse the information contained in the file.\nThe output of reading each of the text files should be a list of dictionaries, like we have seen in previous lectures.\nWe will go through a sample solution together once you’ve had the chance to try it for yourself."
  },
  {
    "objectID": "lecture-3-reveal.html#reading-csv-files-builtin",
    "href": "lecture-3-reveal.html#reading-csv-files-builtin",
    "title": "Python Modules",
    "section": "Reading CSV files – builtin",
    "text": "Reading CSV files – builtin\nWhen working with common file types, Python has built-in modules to make the process a little easier. Take, for example, reading and writing a CSV file. Here we are importing the csv module and in the context of reading the file, we are creating a CSV reader object. When reading, every line of the CSV file is returned as a list, thus an entire CSV file is a list of lists.\nimport csv  # built-in library\n\ndata_path = \"data/processed/data.csv\"\n\n# read a csv\nwith open(data_path, \"r\") as csv_file:\n    csv_reader = csv.reader(csv_file, delimiter=\",\")\n    for line in csv_reader:\n        print(line)\nResults: \n# =&gt; ['name', 'id', 'age']\n# =&gt; ['jane', '01', '35']\n# =&gt; ['james', '02', '50']"
  },
  {
    "objectID": "lecture-3-reveal.html#writing-a-csv-file-builtin",
    "href": "lecture-3-reveal.html#writing-a-csv-file-builtin",
    "title": "Python Modules",
    "section": "Writing a CSV file – builtin",
    "text": "Writing a CSV file – builtin\nWriting a CSV file is similar except we are creating a CSV writer object, and are using writerow instead.\n# write a csv file\nnew_data_file = \"data/processed/new-data.csv\"\nnew_data = [[\"name\", \"age\", \"height\"], [\"jane\", \"35\", \"6\"]]\n\nwith open(new_data_file, \"w\") as csv_file:\n  csv_writer = csv.writer(csv_file, delimiter=\",\")\n  for row in new_data:\n      csv_writer.writerow(row)"
  },
  {
    "objectID": "lecture-3-reveal.html#quick-exercise-readingwriting-csv-files",
    "href": "lecture-3-reveal.html#quick-exercise-readingwriting-csv-files",
    "title": "Python Modules",
    "section": "Quick exercise – reading/writing CSV files",
    "text": "Quick exercise – reading/writing CSV files\n\nGiven the parsed data from the previous exercise, write a new CSV file in the data directory.\nThis CSV file should contain the headings: name, author, releasedata.\nThe data in the CSV file should be the 3 books with data in the correct columns.\nTest that you can read this same CSV file in python."
  },
  {
    "objectID": "lecture-3-reveal.html#read-json-files-builtin",
    "href": "lecture-3-reveal.html#read-json-files-builtin",
    "title": "Python Modules",
    "section": "Read JSON files – builtin",
    "text": "Read JSON files – builtin\nLike CSV, json is a common format for storing data. Python includes a package called json that enables us to read/write to json files with ease.\nLet’s first tackle the process of reading:\nimport json\n\njson_file_path = \"data/processed/data.json\"\n\n# read a json file\nwith open(json_file_path, \"r\") as json_file:\n    data = json.load(json_file)\n    print(data)\n    print(data.keys())\n    print(data[\"names\"])\nResults: \n# =&gt; {'names': ['jane', 'james'], 'ages': [35, 50]}\n# =&gt; dict_keys(['names', 'ages'])\n# =&gt; ['jane', 'james']"
  },
  {
    "objectID": "lecture-3-reveal.html#write-json-files-builtin",
    "href": "lecture-3-reveal.html#write-json-files-builtin",
    "title": "Python Modules",
    "section": "Write JSON files – builtin",
    "text": "Write JSON files – builtin\nWhile we used json.load to read the file, we use json.dump to write the data to a json file.\nnew_data = {\"names\": [\"someone-new\"], \"ages\": [\"NA\"]}\n\n# write a json file\nwith open(\"data/processed/new-data.json\", \"w\") as json_file:\n    json.dump(new_data, json_file)\n\nwith open(\"data/processed/new-data.json\", \"r\") as json_file:\n    print(json.load(json_file))`\nResults: \n# =&gt; {'names': ['someone-new'], 'ages': ['NA']}"
  },
  {
    "objectID": "lecture-3-reveal.html#virtual-environments",
    "href": "lecture-3-reveal.html#virtual-environments",
    "title": "Python Modules",
    "section": "Virtual Environments",
    "text": "Virtual Environments\nWhen installing packages, by default, the packages are going to be installed into the system-level Python. This can be a problem, for example, if you’re working on multiple projects that require different versions of packages.\nVirtual environments are ‘containerised’ versions of Python that can be created for each different project you’re working on.\nWe will take a look at package management and virtual environments in Python."
  },
  {
    "objectID": "lecture-3-reveal.html#anaconda",
    "href": "lecture-3-reveal.html#anaconda",
    "title": "Python Modules",
    "section": "Anaconda",
    "text": "Anaconda\n\n\nDistribution of Python and R designed for scientific computing.\nWe’re going to focus on Conda, a package manager in the Anaconda ecosystem.\nHelps with package management and deployment.\nCreate virtual environments to install packages to avoid conflicts with other projects"
  },
  {
    "objectID": "lecture-3-reveal.html#installing-anaconda",
    "href": "lecture-3-reveal.html#installing-anaconda",
    "title": "Python Modules",
    "section": "Installing Anaconda",
    "text": "Installing Anaconda\nWe’re going to install miniconda (a minimal installation of anaconda). https://docs.conda.io/en/latest/miniconda.html\nThe steps to install Miniconda are roughly:\n\nDownload Miniconda3 Linux 64-bit\nSave the file to the disk\nOpen up a terminal and run the following commands:\n\n    chmod +x &lt;miniconda-file&gt;.sh\n    ./&lt;miniconda-file&gt;.sh\nFollow the installation instructions (most of the time the defaults are sensible)."
  },
  {
    "objectID": "lecture-3-reveal.html#creating-an-environment",
    "href": "lecture-3-reveal.html#creating-an-environment",
    "title": "Python Modules",
    "section": "Creating an environment",
    "text": "Creating an environment\nConda is a command line tool to manage environments. We’re going to highlight some of the most used commands. But for the full list of management, you can use the instructions at: https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html\nIf you’re creating a brand new environment, use:\nconda create --name &lt;name-of-env&gt;\nThis will prompt you to confirm you want to create a new environment, whereupon you enter either a y or n. If y your new environment will be created, but start using the environment, you will first have to activate it."
  },
  {
    "objectID": "lecture-3-reveal.html#activating-an-environment",
    "href": "lecture-3-reveal.html#activating-an-environment",
    "title": "Python Modules",
    "section": "Activating an environment",
    "text": "Activating an environment\nOnce you’ve created a new environment, you can activate it. This is as simple as:\nconda activate &lt;name-of-env&gt;\nYou will notice that your command line prompt has changed from (base) to (&lt;name-of-env&gt;). And whenever you start a new terminal it will always be (base)."
  },
  {
    "objectID": "lecture-3-reveal.html#de-activating-an-environment",
    "href": "lecture-3-reveal.html#de-activating-an-environment",
    "title": "Python Modules",
    "section": "De-activating an environment",
    "text": "De-activating an environment\nTo deactivate an environment, just use:\nconda deactivate\nor:\nconda activate base"
  },
  {
    "objectID": "lecture-3-reveal.html#installing-using-conda",
    "href": "lecture-3-reveal.html#installing-using-conda",
    "title": "Python Modules",
    "section": "Installing using conda",
    "text": "Installing using conda\nLet’s say we want to install a package, say scikit-learn (if we’re doing some data processing or machine learning). To install this package in conda, use:\nconda install scikit-learn\nConda will then check what packages are needed for scikit-learn to work, and figure out if anything needs to be upgraded/downgraded to match the required dependencies of other packages.\nWhen Conda has finalised what packages need to change, it will tell you these changes and ask to confirm. If everything seems okay type y, and enter.\nscikit-learn is a package in the anaconda repository. For a list of packages, you can use: https://anaconda.org/anaconda/repo"
  },
  {
    "objectID": "lecture-3-reveal.html#package-versions",
    "href": "lecture-3-reveal.html#package-versions",
    "title": "Python Modules",
    "section": "Package versions",
    "text": "Package versions\nconda install &lt;package-name&gt;=&lt;version-number&gt;"
  },
  {
    "objectID": "lecture-3-reveal.html#installing-a-specific-version-of-python",
    "href": "lecture-3-reveal.html#installing-a-specific-version-of-python",
    "title": "Python Modules",
    "section": "Installing a specific version of Python",
    "text": "Installing a specific version of Python\nIf we wanted to, we could also change the python version being used in the virtual environment.\nconda install python=3.9\nThis will try to install Python version 3.9 providing that the packages you already have installed support it."
  },
  {
    "objectID": "lecture-3-reveal.html#conda-forge-and-other-repositories",
    "href": "lecture-3-reveal.html#conda-forge-and-other-repositories",
    "title": "Python Modules",
    "section": "Conda-forge and other repositories",
    "text": "Conda-forge and other repositories\nLet’s say that the package is not within the basic anaconda repository. You can specify another repository or channel using the -c flag.\nconda install -c &lt;channel&gt; &lt;package&gt;\nFor example, PyTorch (https://pytorch.org/) uses their own channel:\nconda install -c pytorch pytorch"
  },
  {
    "objectID": "lecture-3-reveal.html#exporting-an-environment",
    "href": "lecture-3-reveal.html#exporting-an-environment",
    "title": "Python Modules",
    "section": "Exporting an environment",
    "text": "Exporting an environment\nWe will want to share our research and work with others. To allow others to use the exact same packages and especially the versions of packages we’re using, we want to export a snapshot of our environment. Conda includes an export command to do just this:\nconda env export --no-builds &gt; environment.yml\nHere we exporting our currently activated environment to a file called environment.yml (common convention) file. I am using the --no-builds flag to improve compatibility with other operating systems such as Mac OS."
  },
  {
    "objectID": "lecture-3-reveal.html#reproducing-an-environment",
    "href": "lecture-3-reveal.html#reproducing-an-environment",
    "title": "Python Modules",
    "section": "Reproducing an environment",
    "text": "Reproducing an environment\nTo create an environment from an existing environment.yml file, you can use the following command:\nconda env create -f environment.yml\nThis will create an environment with the same name and install the same versions of the packages."
  },
  {
    "objectID": "lecture-3-reveal.html#deleting-an-environment",
    "href": "lecture-3-reveal.html#deleting-an-environment",
    "title": "Python Modules",
    "section": "Deleting an Environment",
    "text": "Deleting an Environment\nAt later points in our project life-cycle – we have finished our project and we don’t want to have the environment installed anymore (besides we already have the environment.yml to recreate it from if we need to!).\nWe can remove an environment using:\nconda env remove --name &lt;name-of-env&gt;\nThis will remove the environment from Anaconda."
  },
  {
    "objectID": "lecture-3-reveal.html#cleaning-up",
    "href": "lecture-3-reveal.html#cleaning-up",
    "title": "Python Modules",
    "section": "Cleaning up",
    "text": "Cleaning up\nIf you use Anaconda for a long time, you may start to see that a lot of memory is being used, this is because for every version of the package you install, a download of that package is cached to disk. Having these caches can make reinstalling these packages quicker as you won’t need to download the package again. But if you’re running out of hard drive space, cleaning up these cached downloads is an instant space saver:\nconda clean --all\nThis command will clean up the cache files for all environments, but doesn’t necessarily affect what’s already installed in the environments – so nothing should be broken by running this command."
  },
  {
    "objectID": "lecture-3-reveal.html#pip",
    "href": "lecture-3-reveal.html#pip",
    "title": "Python Modules",
    "section": "Pip",
    "text": "Pip\nPip is another package installer for python. If you’re reading documentation online about how to install a certain Python package, the documentation will normally refer to pip.\nPip, like conda, uses a package repository to locate packages. For pip it is called Pypi (https://pypi.org)\nWe’re going to take a look at the most commonly used commands with pip."
  },
  {
    "objectID": "lecture-3-reveal.html#installing-packages-with-pip",
    "href": "lecture-3-reveal.html#installing-packages-with-pip",
    "title": "Python Modules",
    "section": "Installing packages with pip",
    "text": "Installing packages with pip\nIf you want to install a package, its as simple as pip install.\npip install &lt;package-name&gt;"
  },
  {
    "objectID": "lecture-3-reveal.html#installing-specific-versions",
    "href": "lecture-3-reveal.html#installing-specific-versions",
    "title": "Python Modules",
    "section": "Installing specific versions",
    "text": "Installing specific versions\nSometimes, though, you will want to install a specific package version. For this use ‘==’ after the name of the package.\npip install &lt;package-name&gt;==&lt;version-number&gt;"
  },
  {
    "objectID": "lecture-3-reveal.html#upgrade-packages-with-pip",
    "href": "lecture-3-reveal.html#upgrade-packages-with-pip",
    "title": "Python Modules",
    "section": "Upgrade packages with pip",
    "text": "Upgrade packages with pip\nIf you want upgrade/install the package to the latest version, use the --upgrade flag.\npip install &lt;package-name&gt; --upgrade"
  },
  {
    "objectID": "lecture-3-reveal.html#export-requirements-file",
    "href": "lecture-3-reveal.html#export-requirements-file",
    "title": "Python Modules",
    "section": "Export requirements file",
    "text": "Export requirements file\nLike exporting with conda, pip also includes a method to capture the currently installed environment. In pip, this is called freeze.\nThe common convention is to call the file requirements.txt.\npip freeze &gt; requirements.txt"
  },
  {
    "objectID": "lecture-3-reveal.html#installing-multiple-packages-from-a-requirements-file",
    "href": "lecture-3-reveal.html#installing-multiple-packages-from-a-requirements-file",
    "title": "Python Modules",
    "section": "Installing multiple packages from a requirements file",
    "text": "Installing multiple packages from a requirements file\nIf we want to recreate the environment, we can install multiple packages with specific versions from a requirements file with:\npip install -r requirements.txt"
  },
  {
    "objectID": "lecture-3-reveal.html#anaconda-handles-both-conda-and-pip",
    "href": "lecture-3-reveal.html#anaconda-handles-both-conda-and-pip",
    "title": "Python Modules",
    "section": "Anaconda handles both conda and pip",
    "text": "Anaconda handles both conda and pip\nConda encompasses pip, which means that when you create a virtual environment with conda, it can also include pip. So I would recommend using conda to create the virtual environment and to install packages when you can. But if the package is only available via pip, then it will be okay to install it using pip as well. When you export the environment with conda, it will specify what is installed with pip and what is installed via conda.\nconda env create -f environment.yml\nWhen the environment is re-created with conda, it will install the packages from the correct places, whether that is conda or pip."
  },
  {
    "objectID": "lecture-3-reveal.html#pycharm",
    "href": "lecture-3-reveal.html#pycharm",
    "title": "Python Modules",
    "section": "PyCharm",
    "text": "PyCharm\n\nSo far we have been using a very basic text editor. This editor is only providing us with syntax highlighting (the colouring of keywords, etc) and helping with indentation.\nPyCharm is not a text editor. PyCharm is an Integrated Development Environment (IDE). An IDE is a fully fledged environment for programming in a specific programming language and offers a suite of features that makes programming in a particular language (Python in this case), a lot easier.\nSome of the features of an IDE are typically:\n\nDebugging support with breakpoints and variable inspection.\nPrompts and auto-completion with documentation support.\nBuild tools to run and test programs in various configurations.\n\nWe will use PyCharm for the rest of this course."
  },
  {
    "objectID": "lecture-3-reveal.html#installing-pycharm",
    "href": "lecture-3-reveal.html#installing-pycharm",
    "title": "Python Modules",
    "section": "Installing PyCharm",
    "text": "Installing PyCharm\nUsing Ubuntu snaps:\nsnap install pycharm-community --classic\nOr we can download an archive with the executable. The steps to run goes something like:\ntar xvf pycharm-community-&lt;version&gt;.tar.gz\nbash pycharm-community-&lt;version&gt;/bin/pycharm.sh"
  },
  {
    "objectID": "lecture-3-reveal.html#using-pycharm",
    "href": "lecture-3-reveal.html#using-pycharm",
    "title": "Python Modules",
    "section": "Using PyCharm",
    "text": "Using PyCharm\nWe shall take a look at the following:\n\nCreating a new project.\nSpecifying the conda environment.\nCreating build/run instructions.\nAdding new files/folders.\nDebugging with breakpoints."
  },
  {
    "objectID": "lecture-3-reveal.html#jupyter",
    "href": "lecture-3-reveal.html#jupyter",
    "title": "Python Modules",
    "section": "Jupyter",
    "text": "Jupyter\n\nJupyter notebooks are environments where code is split into cells, where each cell can be executed independently and immediate results can be inspected.\nNotebooks can be very useful for data science projects and exploratory work where the process cannot be clearly defined (and therefore cannot be immediately programmed)."
  },
  {
    "objectID": "lecture-3-reveal.html#installing-jupyter",
    "href": "lecture-3-reveal.html#installing-jupyter",
    "title": "Python Modules",
    "section": "Installing Jupyter",
    "text": "Installing Jupyter\nWe first need to install Jupyter. In you conda environment type:\nconda install jupyter\n# or pip install jupyter"
  },
  {
    "objectID": "lecture-3-reveal.html#starting-the-server",
    "href": "lecture-3-reveal.html#starting-the-server",
    "title": "Python Modules",
    "section": "Starting the server",
    "text": "Starting the server\nWith Jupyter installed, we can now start the notebook server using:\njupyter notebook\nA new browser window will appear. This is the Jupyter interface.\nIf you want to stop the server, press Ctrl+c in the terminal window."
  },
  {
    "objectID": "lecture-3-reveal.html#using-the-interface",
    "href": "lecture-3-reveal.html#using-the-interface",
    "title": "Python Modules",
    "section": "Using the interface",
    "text": "Using the interface\nWe shall take a look at the following:\n\nCreating a new notebook\nDifferent cell types\nExecuting code cells\nMarkdown cells\nExporting to a different format\nHow the notebook gets stored"
  },
  {
    "objectID": "lecture-3-reveal.html#markdown-101",
    "href": "lecture-3-reveal.html#markdown-101",
    "title": "Python Modules",
    "section": "Markdown 101",
    "text": "Markdown 101\nWe will revisit markdown in a later lecture, but since we’re using notebooks, some of the cells can be of a type markdown. In these cells, we can style the text using markdown syntax.\nhttps://www.markdownguide.org/basic-syntax/"
  },
  {
    "objectID": "lecture-3-reveal.html#a-slightly-better-environment-jupyterlab",
    "href": "lecture-3-reveal.html#a-slightly-better-environment-jupyterlab",
    "title": "Python Modules",
    "section": "A slightly better environment – jupyterlab",
    "text": "A slightly better environment – jupyterlab\nThe notebook environment is fine, but there exists another package called jupyter-lab that enhances the environment to include a separate file browser, etc.\nconda install jupyterlab -c conda-forge\n\njupyter-lab"
  },
  {
    "objectID": "lecture-3-reveal.html#a-sense-of-style",
    "href": "lecture-3-reveal.html#a-sense-of-style",
    "title": "Python Modules",
    "section": "A sense of style",
    "text": "A sense of style\nNow that we have looked at syntax you will need to create Python projects, I want to take a minute to talk about the style of writing Python code.\nThis style can help you create projects that can be maintained and understood by others but also yourself.\nPython itself also advocates for an adherence to a particular style of writing Python code with the PEP8 style guide: https://www.python.org/dev/peps/pep-0008/. Though, I will talk through some of the most important ones, in my opinion."
  },
  {
    "objectID": "lecture-3-reveal.html#meaningful-names",
    "href": "lecture-3-reveal.html#meaningful-names",
    "title": "Python Modules",
    "section": "Meaningful names",
    "text": "Meaningful names\n\n\n\nWhat does this code do?\ndef f(l):\n    x = 0\n    y = 0\n    for i in l:\n        x += i\n        y += 1\n    return x / y\n\na = range(100)\nr = f(a)\n\n\n\nWhat about this one?\ndef compute_average(list_of_data):\n    sum = 0\n    num_elements = 0\n    for element in list_of_data:\n        sum += element\n        num_elements += 1\n    return sum / num_elements\n\ndataset = range(100)\naverage_value = compute_average(dataset)\n\n\n\n\nThey are both the same code, but the second version is a lot more readable and understandable because we have used meaningful names for things!"
  },
  {
    "objectID": "lecture-3-reveal.html#use-builtins-where-possible",
    "href": "lecture-3-reveal.html#use-builtins-where-possible",
    "title": "Python Modules",
    "section": "Use builtins where possible",
    "text": "Use builtins where possible\nDon’t re-invent the wheel. Try to use Python’s built-in functions/classes if they exist, they will normally be quicker and more accurate than what you could make in Python itself. For example:\ndataset = range(100)\naverage_value = sum(dataset) / len(dataset)\n\nor maybe even:\nimport numpy as np\ndataset = range(100)\naverage_value = np.mean(dataset)"
  },
  {
    "objectID": "lecture-3-reveal.html#use-docstrings-and-comments",
    "href": "lecture-3-reveal.html#use-docstrings-and-comments",
    "title": "Python Modules",
    "section": "Use docstrings and comments",
    "text": "Use docstrings and comments\ndef compute_average(list_of_data, exclude=None):\n    \"\"\"\n    Compute and return the average value of an iterable list. \n    This average excludes any value if specified by exclude\n\n    params: \n    - list_of_data: data for which the average is computed \n    - exclude: numeric value of values that should not be taken \n        into account\n\n    returns: \n    The computed average, possibly excluding a value.\n    \"\"\"\n    sum = 0\n    num_elements = 0\n    for element in list_of_data:\n        if exclude is not None and element == exclude:\n            continue  # skip this element\n        sum += element\n        num_elements += 1\n    return sum / num_elements"
  },
  {
    "objectID": "lecture-3-reveal.html#using-agreed-upon-casing",
    "href": "lecture-3-reveal.html#using-agreed-upon-casing",
    "title": "Python Modules",
    "section": "Using agreed upon casing",
    "text": "Using agreed upon casing\n\nsnake_casing for functions and variables\nClasses should use CamelCasing\n\ndef this_if_a_function(data_x, data_y):\nclass BookEntry:"
  },
  {
    "objectID": "lecture-3-reveal.html#use-type-annotations-if-possible",
    "href": "lecture-3-reveal.html#use-type-annotations-if-possible",
    "title": "Python Modules",
    "section": "Use type-annotations if possible",
    "text": "Use type-annotations if possible\nType annotations can helper your editor (such as PyCharm) find potential issues in your code. If you use type annotations, the editor can spot types that are not compatible. For example, a string being used with a division.\nhttps://docs.python.org/3/library/typing.html https://realpython.com/python-type-checking/\ndef compute_average(list_of_data: list[int],\n                    exclude: Optional[int] = None) -&gt; float:\n    ..."
  },
  {
    "objectID": "lecture-3-reveal.html#organise-your-imports",
    "href": "lecture-3-reveal.html#organise-your-imports",
    "title": "Python Modules",
    "section": "Organise your imports",
    "text": "Organise your imports\nMake the distinction between standard library imports, externally installed imports, and your own custom imports.\n# internal imports\nimport os\nfrom math import pi\n\n# external imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# custom imports\nfrom src.my_module import DAGs"
  },
  {
    "objectID": "lecture-3-reveal.html#functions-should-do-one-thing-only",
    "href": "lecture-3-reveal.html#functions-should-do-one-thing-only",
    "title": "Python Modules",
    "section": "Functions should do one thing only",
    "text": "Functions should do one thing only\nDo one thing and do it well. Docstrings can help you understand what your function is doing, especially if you use the word ‘and’ in the docstring, you might want to think about breaking your single function into many parts."
  },
  {
    "objectID": "lecture-3-reveal.html#functions-as-re-usability",
    "href": "lecture-3-reveal.html#functions-as-re-usability",
    "title": "Python Modules",
    "section": "Functions as re-usability",
    "text": "Functions as re-usability\nIf you find yourself doing something over and over, a function call help consolidate duplication and potentially reduce the chance of getting things wrong.\n\nprint(\"The result is \", w * x1 + b)\nprint(\"The result is \", w * x2 + b)\nprint(\"The result is \", w * x3 + b)\n\n\ndef compute(var):\n    return w * var + b\n\ndef print_result(res):\n    print(\"The result is \", res)\n\nfor var in [x1, x2, x3]:\n    print_result(compute(var))"
  },
  {
    "objectID": "lecture-3-reveal.html#be-wary-of-god-classes",
    "href": "lecture-3-reveal.html#be-wary-of-god-classes",
    "title": "Python Modules",
    "section": "Be wary of God classes",
    "text": "Be wary of God classes\nGod classes/God object is a class that is doing too many things or ‘knows’ about too much. When designing a class, remember that like a function, in general, it should manage one thing or concept.\n\n\n\nclass Game:\n    def __init__(self):\n        ...\n    def create_character(self):\n        ...\n    def move_character(self):\n        ...\n    def update_score(self):\n        ...\n    def reset_score(self):\n        ...\n    def start_game(self):\n        ...\n    def end_game(self):\n        ...\n    def start_boat(self):\n        ...\n    def stop_boat(self):\n        ...\n    ...\n\n\n\nclass Game:\n    def __init__(self):\n        ...\n    def start_game(self):\n        ...\n    def end_game(self):\n        ...\n\nclass Character:\n    def __init__(self):\n        ...\n    def create_character(self):\n        ...\n    def move_character(self):\n        ...\n\nclass ScoreBoard:\n    ..."
  },
  {
    "objectID": "lecture-3-reveal.html#documentation",
    "href": "lecture-3-reveal.html#documentation",
    "title": "Python Modules",
    "section": "Documentation",
    "text": "Documentation\n\nComments that contradict the code are worse than no comments. Always make a priority of keeping the comments up-to-date when the code changes!\n\nPEP 8 Style Guide\n\nEnsure that comments are correct.\nDon’t over document (i.e. if something is self explanatory, then comments will distract rather than inform). An example from PEP 8:\n\nx = x + 1                 # Increment x\nx = x + 1                 # Compensate for border\n\nDocument what you think will be difficult to understand without some prior knowledge, such as why a particular decision was made to do something a certain way. Don’t explain, educate the reader."
  },
  {
    "objectID": "lecture-3-reveal.html#perform-testing",
    "href": "lecture-3-reveal.html#perform-testing",
    "title": "Python Modules",
    "section": "Perform testing!",
    "text": "Perform testing!\nMake sure to write tests, for example, using unittest (https://docs.python.org/3/library/unittest.html). Writing tests can help find source of bugs/mistakes in your code, and if you change something in the future, you want to make sure that it still works. Writing tests can automate the process of testing your code."
  },
  {
    "objectID": "lecture-3.html",
    "href": "lecture-3.html",
    "title": "Python Modules",
    "section": "",
    "text": "https://xkcd.com/353/\n\n\n\nModules or packages are other scripts or programs that can be imported into other scripts. This definition is very general, but we shall see how flexible importing in Python can be.\nThe basic syntax of importing is:\nimport &lt;package_name&gt;\n\n&lt;package_name&gt;.&lt;function/class/variable/etc&gt;\nIf we import &lt;package_name&gt; using this syntax, we always have to use the dot . syntax to refer to something within this package.\nLet’s take a look at a very basic example.\nimport math\n\nradius = 6.4  # cm\ncircum = 2 * math.pi * radius\nIn this example, we are importing the built-in math package. This package contains a bunch of useful functions and variables. We’re not going to take a look at them here, as we’re focusing on importing, but you can see we’re referring to a variable called pi to calculate the circumference of a circle.\n\n\n\nIf we didn’t always want to specify the package name when we only want to use something specific from a package, we can directly import that something.\nfrom &lt;package_name&gt; import &lt;function/class/variable/etc&gt;\n\n&lt;function/class/variable/etc&gt;\nAs you can see, we’re using the from ... import ... syntax.\nfrom math import pi\n\ncircumference = 2 * pi * radius\n\n\n\nWhen using from ... import ..., there is a wildcard * that we could use. You may sometimes see this style of importing when looking at documentation online:\nfrom &lt;package_name&gt; import *\n\n&lt;function/class/variable/etc&gt;\nHowever, this can create many problems with reading your program code\nWhich module does my_function() originate? Are there are common names between the two? Which would be used?\nfrom my_module import *\nfrom my_second_module import *\n\nmy_function()\n\n\n\nWhen importing, we can optionally create an alias to a symbol. Here we’re creating an alias to the existing pi in math.\nfrom math import pi as decilious_pi\n\ncircumference = 2 * delicious_pi * radius\nThere are some very common conventions of aliasing very highly used packages that we will definitely revisit in another lecture!\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\nlet’s consider a hypothetical local directory:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nIf we wanted to import something from my_module.py we would do:\nfrom src.my_module import MyAwesomeClass\n\nmy_class = MyAwesomeclass()\nHere is another example for increased nesting of directories:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nfrom src.module_1 import cats\nfrom src.module_1.dogs import Dog\n\ncat = cats.Cat()\ndog = Dog()\n\n\n\n\nCreate a directory to store your scripts\nIn this directory, create a file called main.py.\nCreate a sub-directory called src. In src create another file called library.py.\nIn library.py create a class (that doesn’t do anything right now) called Database.\nIn main.py, create an instance of Database.\n\n\n\n\nLet’s say you often import Cat and Dog. We can use a file called __init__.py to help us and make the imports shorter. This fill gets executed when its module is imported.\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- __init__.py\n            |-- cats.py\n            |-- dogs.py\nIn __init__.py:\nfrom cats import Cat\nfrom dogs import Dog\nIn main.py:\nfrom src.module_1 import Cat, Dog\n\n\n\nConsider a file with the following:\nx = 2\ny = 1\nz = x + y\n\nclass MyAwesomeClass:\n...\nIf we import this file in another script, x, y, and z will be computed. In this very simple case this will have very little impact. But what if the computation of these takes a very long time?\nHere we are wrapping any global computations into a appropriate functions. This prevents the global variables being computed as soon as the script is imported.\nNow, if we wanted to compute x, y, and z if this script is run, we could use:\nif __name__ == \"__main__\":\n# do something\nAnything within the scope of the if function will only be run if the current file is the script that is being run directly (i.e. python &lt;the-file&gt;.py). If the script is being imported, the statements within this if scope will not be run.\nSo if we wanted to run compute() if this file is being run directly, we would write:\ndef compute():\n    x = 2\n    y = 1\n    z = x + y\n\nclass MyAwesomeClass:\n    ...\n    \nif __name__ == \"__main__\":\n    compute()\n    # we can of course use MyAwesomeClass as well\n    my_class = MyAwesomeClass()\n    my_class.do_something()"
  },
  {
    "objectID": "lecture-3.html#importing-in-python",
    "href": "lecture-3.html#importing-in-python",
    "title": "Python Modules",
    "section": "",
    "text": "https://xkcd.com/353/"
  },
  {
    "objectID": "lecture-3.html#the-basic-structure-of-importing",
    "href": "lecture-3.html#the-basic-structure-of-importing",
    "title": "Python Modules",
    "section": "",
    "text": "Modules or packages are other scripts or programs that can be imported into other scripts. This definition is very general, but we shall see how flexible importing in Python can be.\nThe basic syntax of importing is:\nimport &lt;package_name&gt;\n\n&lt;package_name&gt;.&lt;function/class/variable/etc&gt;\nIf we import &lt;package_name&gt; using this syntax, we always have to use the dot . syntax to refer to something within this package.\nLet’s take a look at a very basic example.\nimport math\n\nradius = 6.4  # cm\ncircum = 2 * math.pi * radius\nIn this example, we are importing the built-in math package. This package contains a bunch of useful functions and variables. We’re not going to take a look at them here, as we’re focusing on importing, but you can see we’re referring to a variable called pi to calculate the circumference of a circle."
  },
  {
    "objectID": "lecture-3.html#importing-specific-items",
    "href": "lecture-3.html#importing-specific-items",
    "title": "Python Modules",
    "section": "",
    "text": "If we didn’t always want to specify the package name when we only want to use something specific from a package, we can directly import that something.\nfrom &lt;package_name&gt; import &lt;function/class/variable/etc&gt;\n\n&lt;function/class/variable/etc&gt;\nAs you can see, we’re using the from ... import ... syntax.\nfrom math import pi\n\ncircumference = 2 * pi * radius"
  },
  {
    "objectID": "lecture-3.html#dont-do-this",
    "href": "lecture-3.html#dont-do-this",
    "title": "Python Modules",
    "section": "",
    "text": "When using from ... import ..., there is a wildcard * that we could use. You may sometimes see this style of importing when looking at documentation online:\nfrom &lt;package_name&gt; import *\n\n&lt;function/class/variable/etc&gt;\nHowever, this can create many problems with reading your program code\nWhich module does my_function() originate? Are there are common names between the two? Which would be used?\nfrom my_module import *\nfrom my_second_module import *\n\nmy_function()"
  },
  {
    "objectID": "lecture-3.html#alias",
    "href": "lecture-3.html#alias",
    "title": "Python Modules",
    "section": "",
    "text": "When importing, we can optionally create an alias to a symbol. Here we’re creating an alias to the existing pi in math.\nfrom math import pi as decilious_pi\n\ncircumference = 2 * delicious_pi * radius\nThere are some very common conventions of aliasing very highly used packages that we will definitely revisit in another lecture!\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "lecture-3.html#importing-local-libraries",
    "href": "lecture-3.html#importing-local-libraries",
    "title": "Python Modules",
    "section": "",
    "text": "let’s consider a hypothetical local directory:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nIf we wanted to import something from my_module.py we would do:\nfrom src.my_module import MyAwesomeClass\n\nmy_class = MyAwesomeclass()\nHere is another example for increased nesting of directories:\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- cats.py\n            |-- dogs.py\nfrom src.module_1 import cats\nfrom src.module_1.dogs import Dog\n\ncat = cats.Cat()\ndog = Dog()"
  },
  {
    "objectID": "lecture-3.html#quick-exercise-imports",
    "href": "lecture-3.html#quick-exercise-imports",
    "title": "Python Modules",
    "section": "",
    "text": "Create a directory to store your scripts\nIn this directory, create a file called main.py.\nCreate a sub-directory called src. In src create another file called library.py.\nIn library.py create a class (that doesn’t do anything right now) called Database.\nIn main.py, create an instance of Database."
  },
  {
    "objectID": "lecture-3.html#shortcuts-with-__init__.py",
    "href": "lecture-3.html#shortcuts-with-__init__.py",
    "title": "Python Modules",
    "section": "",
    "text": "Let’s say you often import Cat and Dog. We can use a file called __init__.py to help us and make the imports shorter. This fill gets executed when its module is imported.\n    main.py\n    src/\n     |-- my_module.py\n     |-- module_1/\n            |-- __init__.py\n            |-- cats.py\n            |-- dogs.py\nIn __init__.py:\nfrom cats import Cat\nfrom dogs import Dog\nIn main.py:\nfrom src.module_1 import Cat, Dog"
  },
  {
    "objectID": "lecture-3.html#what-is-__main__",
    "href": "lecture-3.html#what-is-__main__",
    "title": "Python Modules",
    "section": "",
    "text": "Consider a file with the following:\nx = 2\ny = 1\nz = x + y\n\nclass MyAwesomeClass:\n...\nIf we import this file in another script, x, y, and z will be computed. In this very simple case this will have very little impact. But what if the computation of these takes a very long time?\nHere we are wrapping any global computations into a appropriate functions. This prevents the global variables being computed as soon as the script is imported.\nNow, if we wanted to compute x, y, and z if this script is run, we could use:\nif __name__ == \"__main__\":\n# do something\nAnything within the scope of the if function will only be run if the current file is the script that is being run directly (i.e. python &lt;the-file&gt;.py). If the script is being imported, the statements within this if scope will not be run.\nSo if we wanted to run compute() if this file is being run directly, we would write:\ndef compute():\n    x = 2\n    y = 1\n    z = x + y\n\nclass MyAwesomeClass:\n    ...\n    \nif __name__ == \"__main__\":\n    compute()\n    # we can of course use MyAwesomeClass as well\n    my_class = MyAwesomeClass()\n    my_class.do_something()"
  },
  {
    "objectID": "lecture-3.html#current-working-directory",
    "href": "lecture-3.html#current-working-directory",
    "title": "Python Modules",
    "section": "Current working directory",
    "text": "Current working directory\nThe folder in which you run Python will be the current working directory (CWD). We can print this value with the os.getcwd() function, or change the directory with os.chdir(...). Its important to know what your CWD is as all relative paths (paths that do not start with a ‘/’) will be relative to your CWD.\nimport os\n\nprint(os.getcwd())\nos.chdir(\"../\")\nprint(os.getcwd())\nos.chdir(\"week-3\")`\nResults: \n# =&gt; [...]/Programming Level-up/week-3\n# =&gt; [...]/Programming Level-up\nI’ve replaced the full path printed by Python with [...] so you can see the differences in the paths!"
  },
  {
    "objectID": "lecture-3.html#listing-directories",
    "href": "lecture-3.html#listing-directories",
    "title": "Python Modules",
    "section": "Listing directories",
    "text": "Listing directories\nContinuing with our usage of the os package, we can use the listdir function to list all files within a directory.\nprint(os.listdir())\nprint(os.listdir(\"images/\"))\nResults: \n# =&gt; ['images', '__pycache__', 'lecture.pdf', 'lecture.tex', 'data', 'test_file_1.py', 'lecture.org', '_minted-lecture', 'test_file_2.py']\n# =&gt; ['legend-2.png', 'fig-size.png', 'basic.png', 'subplots.png', 'python.png', 'pycharm01.png', 'installing-scikit-learn.png', 'pycharm02.png', 'PyCharm_Icon.png', 'axis.png', 'legend.png', 'complex-pycharm.jpg']\nThis returns a list of files and directory relative to your current working directory. Notice how from this list you cannot tell if something is a file or directory (though the filename does provide some hint)."
  },
  {
    "objectID": "lecture-3.html#testing-for-files-or-directories",
    "href": "lecture-3.html#testing-for-files-or-directories",
    "title": "Python Modules",
    "section": "Testing for files or directories",
    "text": "Testing for files or directories\nIn the previous example we saw that the items returned by listdir does not specify if the item is a file or directory. However, os provides an isfile function in the path submodule to test if the argument is a file, else it will be a directory.\nfor path in os.listdir():\n    print(f\"{path} =&gt; is file: {os.path.isfile(path)}\")\nResults: \n# =&gt; images =&gt; is file: False\n# =&gt; __pycache__ =&gt; is file: False\n# =&gt; lecture.pdf =&gt; is file: True\n# =&gt; lecture.tex =&gt; is file: True\n# =&gt; data =&gt; is file: False\n# =&gt; test_file_1.py =&gt; is file: True\n# =&gt; lecture.org =&gt; is file: True\n# =&gt; _minted-lecture =&gt; is file: False\n# =&gt; test_file_2.py =&gt; is file: True"
  },
  {
    "objectID": "lecture-3.html#using-wildcards",
    "href": "lecture-3.html#using-wildcards",
    "title": "Python Modules",
    "section": "Using wildcards",
    "text": "Using wildcards\nIf we wanted to get all files within a directory, we could use the glob function from the glob package. glob allows us to use the * wildcard. E.g. *.png will list all files that end with .png. test-* will list all files that start with test-*.\nfrom glob import glob\n\nfor fn in glob(\"images/*\"):\n    print(fn)\nResults: \n# =&gt; images/legend-2.png\n# =&gt; images/fig-size.png\n# =&gt; images/basic.png\n# =&gt; images/subplots.png\n# =&gt; images/python.png\n# =&gt; images/pycharm01.png\n# =&gt; images/installing-scikit-learn.png\n# =&gt; images/pycharm02.png\n# =&gt; images/PyCharm_Icon.png\n# =&gt; images/axis.png\n# =&gt; images/legend.png\n# =&gt; images/complex-pycharm.jpg"
  },
  {
    "objectID": "lecture-3.html#pathlib-a-newer-way",
    "href": "lecture-3.html#pathlib-a-newer-way",
    "title": "Python Modules",
    "section": "Pathlib – a newer way",
    "text": "Pathlib – a newer way\npathlib is a somewhat recent addition to the Python standard library which makes working with files a little easier. Firstly, we can create a Path object, allowing us to concatenate paths with the /. Instead of using the glob module, a Path object has a glob class method.\nfrom pathlib import Path\n\ndata_dir = Path(\"data\")\nprocessed_data = data_dir / \"processed\"\n\ndata_files = processed_data.glob(\"*.txt\")\n\nfor data_file in data_files:\n    print(data_file)\nResults: \n# =&gt; data/processed/data-2.txt\n# =&gt; data/processed/data.txt"
  },
  {
    "objectID": "lecture-3.html#pathlib-convenient-functions",
    "href": "lecture-3.html#pathlib-convenient-functions",
    "title": "Python Modules",
    "section": "Pathlib – convenient functions",
    "text": "Pathlib – convenient functions\npathlib allows us to easily decompose a path into different components. Take for example getting the filename of a path with .name.\nfrom pathlib import Path\n\nsome_file = Path(\"data/processed/data.txt\")\n\nprint(some_file.parts)  # get component parts\nprint(some_file.parents[0])  # list of parent dirs\nprint(some_file.name)   # only filename\nprint(some_file.suffix) # extension\nResults: \n# =&gt; ('data', 'processed', 'data.txt')\n# =&gt; data/processed\n# =&gt; data.txt\n# =&gt; .txt"
  },
  {
    "objectID": "lecture-3.html#converting-path-into-a-string",
    "href": "lecture-3.html#converting-path-into-a-string",
    "title": "Python Modules",
    "section": "Converting Path into a string",
    "text": "Converting Path into a string\nAs pathlib is a recent addition to Python, some functions/classes are expecting a str representation of the path, not a Path object. Therefore, you may want to use the str function to convert a Path object to a string.\nstr(Path(\"data/\"))\nResults: \n# =&gt; 'data'"
  },
  {
    "objectID": "lecture-3.html#quick-exercise-locating-files",
    "href": "lecture-3.html#quick-exercise-locating-files",
    "title": "Python Modules",
    "section": "Quick exercise – locating files",
    "text": "Quick exercise – locating files\n\nIn the same directory of scripts you created in the last exercise, create another directory called data.\nIn data, create 3 text files, calling them &lt;book_name&gt;.txt.\nThese each text file should contain the information from table below in the format:\nName:  Author:  Release Year: \n\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\nRelease Date\n\n\n\n\n\n\nMoby Dick\n\n\nHerman Melville\n\n\n1851\n\n\n\n\nA Study in Scarlet\n\n\nSir Arthur Conan Doyle\n\n\n1887\n\n\n\n\nFrankenstein\n\n\nMary Shelley\n\n\n1818\n\n\n\n\nHitchhikers Guide to the Galaxy\n\n\nDouglas Adams\n\n\n1979\n\n\n\n\n\n\nFrom main.py, print out all of the text files in the directory."
  },
  {
    "objectID": "lecture-3.html#reading-files",
    "href": "lecture-3.html#reading-files",
    "title": "Python Modules",
    "section": "Reading files",
    "text": "Reading files\nTo read a file, we must first open it with the open function. This returns a file stream to which we can call the read() class method.\nYou should always make sure to call the close() class method on this stream to close the file.\nread() reads the entire contents of the file and places it into a string.\nopen_file = open(str(Path(\"data\") / \"processed\" / \"data.txt\"))\ncontents_of_file = open_file.read()\nopen_file.close()  # should always happen!\nprint(contents_of_file)\nResults: \n# =&gt; this is some data\n# =&gt; on another line"
  },
  {
    "objectID": "lecture-3.html#reading-files-lines-or-entire-file",
    "href": "lecture-3.html#reading-files-lines-or-entire-file",
    "title": "Python Modules",
    "section": "Reading files – lines or entire file?",
    "text": "Reading files – lines or entire file?\nWhile read works for the last example, you may want to read files in different ways. Luckily there are a number of methods you could use.\nopen_file.read()       # read entire file\nopen_file.readline()   # read a single line\nopen_file.readline(5)  # read 5 lines\nopen_file.readlines()  # returns all lines as a list\n\nfor line in open_file:  # read one line at a time\n    do_something(line)"
  },
  {
    "objectID": "lecture-3.html#the-with-keyword",
    "href": "lecture-3.html#the-with-keyword",
    "title": "Python Modules",
    "section": "The with keyword",
    "text": "The with keyword\nIt can be a pain to remember to use the .close() every time you open a file. In Python, we can use open() as a context with the with keyword. This context will handle the closing of the file as soon as the scope is exited.\nThe syntax for opening a file is as follows:\nwith open(\"data/processed/data.txt\", \"r\") as open_file:\n    contents = open_file.read()\n\n# the file is automatically closed at this point\n\n    print(contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line"
  },
  {
    "objectID": "lecture-3.html#writing-files",
    "href": "lecture-3.html#writing-files",
    "title": "Python Modules",
    "section": "Writing files",
    "text": "Writing files\nThe syntax for writing a file is similar to reading a file. The main difference is the use \"w\" instead of \"r\" in the second argument of open. Also, instead of read(), we use write().\ndata = [\"this is some data\", \"on another line\", \"with another line\"]\nnew_filename = \"data/processed/new-data.txt\"\n\nwith open(new_filename, \"w\") as open_file:\n    for line in data:\n        open_file.write(line + \"\\n\")\n\nwith open(new_filename, \"r\") as open_file:\n    new_contents = open_file.read()\n\nprint(new_contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line\n# =&gt; with another line"
  },
  {
    "objectID": "lecture-3.html#appending-to-files",
    "href": "lecture-3.html#appending-to-files",
    "title": "Python Modules",
    "section": "Appending to files",
    "text": "Appending to files\nEvery time we write to a file, the entire contents is deleted and replaced. If we want to just append to the file instead, we use \"a\".\ndata = [\"this is some appended data\"]\nnew_filename = \"data/processed/new-data.txt\"\n\nwith open(new_filename, \"a\") as open_file:\n    for line in data:\n        open_file.write(line + \"\\n\")\n\nwith open(new_filename, \"r\") as open_file:\n    new_contents = open_file.read()\n\nprint(new_contents)\nResults: \n# =&gt; this is some data\n# =&gt; on another line\n# =&gt; with another line\n# =&gt; this is some appended data"
  },
  {
    "objectID": "lecture-3.html#quick-exercise-readingwriting-files",
    "href": "lecture-3.html#quick-exercise-readingwriting-files",
    "title": "Python Modules",
    "section": "Quick exercise – reading/writing files",
    "text": "Quick exercise – reading/writing files\n\nUsing the same text files from the previous exercise, we will want to be able to read each text file, and parse the information contained in the file.\nThe output of reading each of the text files should be a list of dictionaries, like we have seen in previous lectures.\nWe will go through a sample solution together once you’ve had the chance to try it for yourself."
  },
  {
    "objectID": "lecture-3.html#reading-csv-files-builtin",
    "href": "lecture-3.html#reading-csv-files-builtin",
    "title": "Python Modules",
    "section": "Reading CSV files – builtin",
    "text": "Reading CSV files – builtin\nWhen working with common file types, Python has built-in modules to make the process a little easier. Take, for example, reading and writing a CSV file. Here we are importing the csv module and in the context of reading the file, we are creating a CSV reader object. When reading, every line of the CSV file is returned as a list, thus an entire CSV file is a list of lists.\nimport csv  # built-in library\n\ndata_path = \"data/processed/data.csv\"\n\n# read a csv\nwith open(data_path, \"r\") as csv_file:\n    csv_reader = csv.reader(csv_file, delimiter=\",\")\n    for line in csv_reader:\n        print(line)\nResults: \n# =&gt; ['name', 'id', 'age']\n# =&gt; ['jane', '01', '35']\n# =&gt; ['james', '02', '50']"
  },
  {
    "objectID": "lecture-3.html#writing-a-csv-file-builtin",
    "href": "lecture-3.html#writing-a-csv-file-builtin",
    "title": "Python Modules",
    "section": "Writing a CSV file – builtin",
    "text": "Writing a CSV file – builtin\nWriting a CSV file is similar except we are creating a CSV writer object, and are using writerow instead.\n# write a csv file\nnew_data_file = \"data/processed/new-data.csv\"\nnew_data = [[\"name\", \"age\", \"height\"], [\"jane\", \"35\", \"6\"]]\n\nwith open(new_data_file, \"w\") as csv_file:\n  csv_writer = csv.writer(csv_file, delimiter=\",\")\n  for row in new_data:\n      csv_writer.writerow(row)"
  },
  {
    "objectID": "lecture-3.html#quick-exercise-readingwriting-csv-files",
    "href": "lecture-3.html#quick-exercise-readingwriting-csv-files",
    "title": "Python Modules",
    "section": "Quick exercise – reading/writing CSV files",
    "text": "Quick exercise – reading/writing CSV files\n\nGiven the parsed data from the previous exercise, write a new CSV file in the data directory.\nThis CSV file should contain the headings: name, author, releasedata.\nThe data in the CSV file should be the 3 books with data in the correct columns.\nTest that you can read this same CSV file in python."
  },
  {
    "objectID": "lecture-3.html#read-json-files-builtin",
    "href": "lecture-3.html#read-json-files-builtin",
    "title": "Python Modules",
    "section": "Read JSON files – builtin",
    "text": "Read JSON files – builtin\nLike CSV, json is a common format for storing data. Python includes a package called json that enables us to read/write to json files with ease.\nLet’s first tackle the process of reading:\nimport json\n\njson_file_path = \"data/processed/data.json\"\n\n# read a json file\nwith open(json_file_path, \"r\") as json_file:\n    data = json.load(json_file)\n    print(data)\n    print(data.keys())\n    print(data[\"names\"])\nResults: \n# =&gt; {'names': ['jane', 'james'], 'ages': [35, 50]}\n# =&gt; dict_keys(['names', 'ages'])\n# =&gt; ['jane', 'james']"
  },
  {
    "objectID": "lecture-3.html#write-json-files-builtin",
    "href": "lecture-3.html#write-json-files-builtin",
    "title": "Python Modules",
    "section": "Write JSON files – builtin",
    "text": "Write JSON files – builtin\nWhile we used json.load to read the file, we use json.dump to write the data to a json file.\nnew_data = {\"names\": [\"someone-new\"], \"ages\": [\"NA\"]}\n\n# write a json file\nwith open(\"data/processed/new-data.json\", \"w\") as json_file:\n    json.dump(new_data, json_file)\n\nwith open(\"data/processed/new-data.json\", \"r\") as json_file:\n    print(json.load(json_file))`\nResults: \n# =&gt; {'names': ['someone-new'], 'ages': ['NA']}"
  },
  {
    "objectID": "lecture-3.html#virtual-environments",
    "href": "lecture-3.html#virtual-environments",
    "title": "Python Modules",
    "section": "Virtual Environments",
    "text": "Virtual Environments\nWhen installing packages, by default, the packages are going to be installed into the system-level Python. This can be a problem, for example, if you’re working on multiple projects that require different versions of packages.\nVirtual environments are ‘containerised’ versions of Python that can be created for each different project you’re working on.\nWe will take a look at package management and virtual environments in Python."
  },
  {
    "objectID": "lecture-3.html#anaconda",
    "href": "lecture-3.html#anaconda",
    "title": "Python Modules",
    "section": "Anaconda",
    "text": "Anaconda\n\n\n\n\n\n\nDistribution of Python and R designed for scientific computing.\nWe’re going to focus on Conda, a package manager in the Anaconda ecosystem.\nHelps with package management and deployment.\nCreate virtual environments to install packages to avoid conflicts with other projects"
  },
  {
    "objectID": "lecture-3.html#installing-anaconda",
    "href": "lecture-3.html#installing-anaconda",
    "title": "Python Modules",
    "section": "Installing Anaconda",
    "text": "Installing Anaconda\nWe’re going to install miniconda (a minimal installation of anaconda). https://docs.conda.io/en/latest/miniconda.html\nThe steps to install Miniconda are roughly:\n\nDownload Miniconda3 Linux 64-bit\nSave the file to the disk\nOpen up a terminal and run the following commands:\n\n    chmod +x &lt;miniconda-file&gt;.sh\n    ./&lt;miniconda-file&gt;.sh\nFollow the installation instructions (most of the time the defaults are sensible)."
  },
  {
    "objectID": "lecture-3.html#creating-an-environment",
    "href": "lecture-3.html#creating-an-environment",
    "title": "Python Modules",
    "section": "Creating an environment",
    "text": "Creating an environment\nConda is a command line tool to manage environments. We’re going to highlight some of the most used commands. But for the full list of management, you can use the instructions at: https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html\nIf you’re creating a brand new environment, use:\nconda create --name &lt;name-of-env&gt;\nThis will prompt you to confirm you want to create a new environment, whereupon you enter either a y or n. If y your new environment will be created, but start using the environment, you will first have to activate it."
  },
  {
    "objectID": "lecture-3.html#activating-an-environment",
    "href": "lecture-3.html#activating-an-environment",
    "title": "Python Modules",
    "section": "Activating an environment",
    "text": "Activating an environment\nOnce you’ve created a new environment, you can activate it. This is as simple as:\nconda activate &lt;name-of-env&gt;\nYou will notice that your command line prompt has changed from (base) to (&lt;name-of-env&gt;). And whenever you start a new terminal it will always be (base)."
  },
  {
    "objectID": "lecture-3.html#de-activating-an-environment",
    "href": "lecture-3.html#de-activating-an-environment",
    "title": "Python Modules",
    "section": "De-activating an environment",
    "text": "De-activating an environment\nTo deactivate an environment, just use:\nconda deactivate\nor:\nconda activate base"
  },
  {
    "objectID": "lecture-3.html#installing-using-conda",
    "href": "lecture-3.html#installing-using-conda",
    "title": "Python Modules",
    "section": "Installing using conda",
    "text": "Installing using conda\nLet’s say we want to install a package, say scikit-learn (if we’re doing some data processing or machine learning). To install this package in conda, use:\nconda install scikit-learn\nConda will then check what packages are needed for scikit-learn to work, and figure out if anything needs to be upgraded/downgraded to match the required dependencies of other packages.\nWhen Conda has finalised what packages need to change, it will tell you these changes and ask to confirm. If everything seems okay type y, and enter.\nscikit-learn is a package in the anaconda repository. For a list of packages, you can use: https://anaconda.org/anaconda/repo"
  },
  {
    "objectID": "lecture-3.html#package-versions",
    "href": "lecture-3.html#package-versions",
    "title": "Python Modules",
    "section": "Package versions",
    "text": "Package versions\nconda install &lt;package-name&gt;=&lt;version-number&gt;"
  },
  {
    "objectID": "lecture-3.html#installing-a-specific-version-of-python",
    "href": "lecture-3.html#installing-a-specific-version-of-python",
    "title": "Python Modules",
    "section": "Installing a specific version of Python",
    "text": "Installing a specific version of Python\nIf we wanted to, we could also change the python version being used in the virtual environment.\nconda install python=3.9\nThis will try to install Python version 3.9 providing that the packages you already have installed support it."
  },
  {
    "objectID": "lecture-3.html#conda-forge-and-other-repositories",
    "href": "lecture-3.html#conda-forge-and-other-repositories",
    "title": "Python Modules",
    "section": "Conda-forge and other repositories",
    "text": "Conda-forge and other repositories\nLet’s say that the package is not within the basic anaconda repository. You can specify another repository or channel using the -c flag.\nconda install -c &lt;channel&gt; &lt;package&gt;\nFor example, PyTorch (https://pytorch.org/) uses their own channel:\nconda install -c pytorch pytorch"
  },
  {
    "objectID": "lecture-3.html#exporting-an-environment",
    "href": "lecture-3.html#exporting-an-environment",
    "title": "Python Modules",
    "section": "Exporting an environment",
    "text": "Exporting an environment\nWe will want to share our research and work with others. To allow others to use the exact same packages and especially the versions of packages we’re using, we want to export a snapshot of our environment. Conda includes an export command to do just this:\nconda env export --no-builds &gt; environment.yml\nHere we exporting our currently activated environment to a file called environment.yml (common convention) file. I am using the --no-builds flag to improve compatibility with other operating systems such as Mac OS."
  },
  {
    "objectID": "lecture-3.html#reproducing-an-environment",
    "href": "lecture-3.html#reproducing-an-environment",
    "title": "Python Modules",
    "section": "Reproducing an environment",
    "text": "Reproducing an environment\nTo create an environment from an existing environment.yml file, you can use the following command:\nconda env create -f environment.yml\nThis will create an environment with the same name and install the same versions of the packages."
  },
  {
    "objectID": "lecture-3.html#deleting-an-environment",
    "href": "lecture-3.html#deleting-an-environment",
    "title": "Python Modules",
    "section": "Deleting an Environment",
    "text": "Deleting an Environment\nAt later points in our project life-cycle – we have finished our project and we don’t want to have the environment installed anymore (besides we already have the environment.yml to recreate it from if we need to!).\nWe can remove an environment using:\nconda env remove --name &lt;name-of-env&gt;\nThis will remove the environment from Anaconda."
  },
  {
    "objectID": "lecture-3.html#cleaning-up",
    "href": "lecture-3.html#cleaning-up",
    "title": "Python Modules",
    "section": "Cleaning up",
    "text": "Cleaning up\nIf you use Anaconda for a long time, you may start to see that a lot of memory is being used, this is because for every version of the package you install, a download of that package is cached to disk. Having these caches can make reinstalling these packages quicker as you won’t need to download the package again. But if you’re running out of hard drive space, cleaning up these cached downloads is an instant space saver:\nconda clean --all\nThis command will clean up the cache files for all environments, but doesn’t necessarily affect what’s already installed in the environments – so nothing should be broken by running this command."
  },
  {
    "objectID": "lecture-3.html#pip",
    "href": "lecture-3.html#pip",
    "title": "Python Modules",
    "section": "Pip",
    "text": "Pip\nPip is another package installer for python. If you’re reading documentation online about how to install a certain Python package, the documentation will normally refer to pip.\nPip, like conda, uses a package repository to locate packages. For pip it is called Pypi (https://pypi.org)\nWe’re going to take a look at the most commonly used commands with pip."
  },
  {
    "objectID": "lecture-3.html#installing-packages-with-pip",
    "href": "lecture-3.html#installing-packages-with-pip",
    "title": "Python Modules",
    "section": "Installing packages with pip",
    "text": "Installing packages with pip\nIf you want to install a package, its as simple as pip install.\npip install &lt;package-name&gt;"
  },
  {
    "objectID": "lecture-3.html#installing-specific-versions",
    "href": "lecture-3.html#installing-specific-versions",
    "title": "Python Modules",
    "section": "Installing specific versions",
    "text": "Installing specific versions\nSometimes, though, you will want to install a specific package version. For this use ‘==’ after the name of the package.\npip install &lt;package-name&gt;==&lt;version-number&gt;"
  },
  {
    "objectID": "lecture-3.html#upgrade-packages-with-pip",
    "href": "lecture-3.html#upgrade-packages-with-pip",
    "title": "Python Modules",
    "section": "Upgrade packages with pip",
    "text": "Upgrade packages with pip\nIf you want upgrade/install the package to the latest version, use the --upgrade flag.\npip install &lt;package-name&gt; --upgrade"
  },
  {
    "objectID": "lecture-3.html#export-requirements-file",
    "href": "lecture-3.html#export-requirements-file",
    "title": "Python Modules",
    "section": "Export requirements file",
    "text": "Export requirements file\nLike exporting with conda, pip also includes a method to capture the currently installed environment. In pip, this is called freeze.\nThe common convention is to call the file requirements.txt.\npip freeze &gt; requirements.txt"
  },
  {
    "objectID": "lecture-3.html#installing-multiple-packages-from-a-requirements-file",
    "href": "lecture-3.html#installing-multiple-packages-from-a-requirements-file",
    "title": "Python Modules",
    "section": "Installing multiple packages from a requirements file",
    "text": "Installing multiple packages from a requirements file\nIf we want to recreate the environment, we can install multiple packages with specific versions from a requirements file with:\npip install -r requirements.txt"
  },
  {
    "objectID": "lecture-3.html#anaconda-handles-both-conda-and-pip",
    "href": "lecture-3.html#anaconda-handles-both-conda-and-pip",
    "title": "Python Modules",
    "section": "Anaconda handles both conda and pip",
    "text": "Anaconda handles both conda and pip\nConda encompasses pip, which means that when you create a virtual environment with conda, it can also include pip. So I would recommend using conda to create the virtual environment and to install packages when you can. But if the package is only available via pip, then it will be okay to install it using pip as well. When you export the environment with conda, it will specify what is installed with pip and what is installed via conda.\nconda env create -f environment.yml\nWhen the environment is re-created with conda, it will install the packages from the correct places, whether that is conda or pip."
  },
  {
    "objectID": "lecture-3.html#pycharm",
    "href": "lecture-3.html#pycharm",
    "title": "Python Modules",
    "section": "PyCharm",
    "text": "PyCharm\n\n\n\n\n\nSo far we have been using a very basic text editor. This editor is only providing us with syntax highlighting (the colouring of keywords, etc) and helping with indentation.\nPyCharm is not a text editor. PyCharm is an Integrated Development Environment (IDE). An IDE is a fully fledged environment for programming in a specific programming language and offers a suite of features that makes programming in a particular language (Python in this case), a lot easier.\nSome of the features of an IDE are typically:\n\nDebugging support with breakpoints and variable inspection.\nPrompts and auto-completion with documentation support.\nBuild tools to run and test programs in various configurations.\n\nWe will use PyCharm for the rest of this course."
  },
  {
    "objectID": "lecture-3.html#installing-pycharm",
    "href": "lecture-3.html#installing-pycharm",
    "title": "Python Modules",
    "section": "Installing PyCharm",
    "text": "Installing PyCharm\nUsing Ubuntu snaps:\nsnap install pycharm-community --classic\nOr we can download an archive with the executable. The steps to run goes something like:\ntar xvf pycharm-community-&lt;version&gt;.tar.gz\nbash pycharm-community-&lt;version&gt;/bin/pycharm.sh"
  },
  {
    "objectID": "lecture-3.html#using-pycharm",
    "href": "lecture-3.html#using-pycharm",
    "title": "Python Modules",
    "section": "Using PyCharm",
    "text": "Using PyCharm\nWe shall take a look at the following:\n\nCreating a new project.\nSpecifying the conda environment.\nCreating build/run instructions.\nAdding new files/folders.\nDebugging with breakpoints."
  },
  {
    "objectID": "lecture-3.html#jupyter",
    "href": "lecture-3.html#jupyter",
    "title": "Python Modules",
    "section": "Jupyter",
    "text": "Jupyter\n\n\n\n\n\nJupyter notebooks are environments where code is split into cells, where each cell can be executed independently and immediate results can be inspected.\nNotebooks can be very useful for data science projects and exploratory work where the process cannot be clearly defined (and therefore cannot be immediately programmed)."
  },
  {
    "objectID": "lecture-3.html#installing-jupyter",
    "href": "lecture-3.html#installing-jupyter",
    "title": "Python Modules",
    "section": "Installing Jupyter",
    "text": "Installing Jupyter\nWe first need to install Jupyter. In you conda environment type:\nconda install jupyter\n# or pip install jupyter"
  },
  {
    "objectID": "lecture-3.html#starting-the-server",
    "href": "lecture-3.html#starting-the-server",
    "title": "Python Modules",
    "section": "Starting the server",
    "text": "Starting the server\nWith Jupyter installed, we can now start the notebook server using:\njupyter notebook\nA new browser window will appear. This is the Jupyter interface.\nIf you want to stop the server, press Ctrl+c in the terminal window."
  },
  {
    "objectID": "lecture-3.html#using-the-interface",
    "href": "lecture-3.html#using-the-interface",
    "title": "Python Modules",
    "section": "Using the interface",
    "text": "Using the interface\nWe shall take a look at the following:\n\nCreating a new notebook\nDifferent cell types\nExecuting code cells\nMarkdown cells\nExporting to a different format\nHow the notebook gets stored"
  },
  {
    "objectID": "lecture-3.html#markdown-101",
    "href": "lecture-3.html#markdown-101",
    "title": "Python Modules",
    "section": "Markdown 101",
    "text": "Markdown 101\nWe will revisit markdown in a later lecture, but since we’re using notebooks, some of the cells can be of a type markdown. In these cells, we can style the text using markdown syntax.\nhttps://www.markdownguide.org/basic-syntax/"
  },
  {
    "objectID": "lecture-3.html#a-slightly-better-environment-jupyterlab",
    "href": "lecture-3.html#a-slightly-better-environment-jupyterlab",
    "title": "Python Modules",
    "section": "A slightly better environment – jupyterlab",
    "text": "A slightly better environment – jupyterlab\nThe notebook environment is fine, but there exists another package called jupyter-lab that enhances the environment to include a separate file browser, etc.\nconda install jupyterlab -c conda-forge\n\njupyter-lab"
  },
  {
    "objectID": "lecture-3.html#a-sense-of-style",
    "href": "lecture-3.html#a-sense-of-style",
    "title": "Python Modules",
    "section": "A sense of style",
    "text": "A sense of style\nNow that we have looked at syntax you will need to create Python projects, I want to take a minute to talk about the style of writing Python code.\nThis style can help you create projects that can be maintained and understood by others but also yourself.\nPython itself also advocates for an adherence to a particular style of writing Python code with the PEP8 style guide: https://www.python.org/dev/peps/pep-0008/. Though, I will talk through some of the most important ones, in my opinion."
  },
  {
    "objectID": "lecture-3.html#meaningful-names",
    "href": "lecture-3.html#meaningful-names",
    "title": "Python Modules",
    "section": "Meaningful names",
    "text": "Meaningful names\n\n\n\nWhat does this code do?\ndef f(l):\n    x = 0\n    y = 0\n    for i in l:\n        x += i\n        y += 1\n    return x / y\n\na = range(100)\nr = f(a)\n\n\n\nWhat about this one?\ndef compute_average(list_of_data):\n    sum = 0\n    num_elements = 0\n    for element in list_of_data:\n        sum += element\n        num_elements += 1\n    return sum / num_elements\n\ndataset = range(100)\naverage_value = compute_average(dataset)\n\n\n\n\nThey are both the same code, but the second version is a lot more readable and understandable because we have used meaningful names for things!"
  },
  {
    "objectID": "lecture-3.html#use-builtins-where-possible",
    "href": "lecture-3.html#use-builtins-where-possible",
    "title": "Python Modules",
    "section": "Use builtins where possible",
    "text": "Use builtins where possible\nDon’t re-invent the wheel. Try to use Python’s built-in functions/classes if they exist, they will normally be quicker and more accurate than what you could make in Python itself. For example:\ndataset = range(100)\naverage_value = sum(dataset) / len(dataset)\n. . .\nor maybe even:\nimport numpy as np\ndataset = range(100)\naverage_value = np.mean(dataset)"
  },
  {
    "objectID": "lecture-3.html#use-docstrings-and-comments",
    "href": "lecture-3.html#use-docstrings-and-comments",
    "title": "Python Modules",
    "section": "Use docstrings and comments",
    "text": "Use docstrings and comments\ndef compute_average(list_of_data, exclude=None):\n    \"\"\"\n    Compute and return the average value of an iterable list. \n    This average excludes any value if specified by exclude\n\n    params: \n    - list_of_data: data for which the average is computed \n    - exclude: numeric value of values that should not be taken \n        into account\n\n    returns: \n    The computed average, possibly excluding a value.\n    \"\"\"\n    sum = 0\n    num_elements = 0\n    for element in list_of_data:\n        if exclude is not None and element == exclude:\n            continue  # skip this element\n        sum += element\n        num_elements += 1\n    return sum / num_elements"
  },
  {
    "objectID": "lecture-3.html#using-agreed-upon-casing",
    "href": "lecture-3.html#using-agreed-upon-casing",
    "title": "Python Modules",
    "section": "Using agreed upon casing",
    "text": "Using agreed upon casing\n\nsnake_casing for functions and variables\nClasses should use CamelCasing\n\ndef this_if_a_function(data_x, data_y):\nclass BookEntry:"
  },
  {
    "objectID": "lecture-3.html#use-type-annotations-if-possible",
    "href": "lecture-3.html#use-type-annotations-if-possible",
    "title": "Python Modules",
    "section": "Use type-annotations if possible",
    "text": "Use type-annotations if possible\nType annotations can helper your editor (such as PyCharm) find potential issues in your code. If you use type annotations, the editor can spot types that are not compatible. For example, a string being used with a division.\nhttps://docs.python.org/3/library/typing.html https://realpython.com/python-type-checking/\ndef compute_average(list_of_data: list[int],\n                    exclude: Optional[int] = None) -&gt; float:\n    ..."
  },
  {
    "objectID": "lecture-3.html#organise-your-imports",
    "href": "lecture-3.html#organise-your-imports",
    "title": "Python Modules",
    "section": "Organise your imports",
    "text": "Organise your imports\nMake the distinction between standard library imports, externally installed imports, and your own custom imports.\n# internal imports\nimport os\nfrom math import pi\n\n# external imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# custom imports\nfrom src.my_module import DAGs"
  },
  {
    "objectID": "lecture-3.html#functions-should-do-one-thing-only",
    "href": "lecture-3.html#functions-should-do-one-thing-only",
    "title": "Python Modules",
    "section": "Functions should do one thing only",
    "text": "Functions should do one thing only\nDo one thing and do it well. Docstrings can help you understand what your function is doing, especially if you use the word ‘and’ in the docstring, you might want to think about breaking your single function into many parts."
  },
  {
    "objectID": "lecture-3.html#functions-as-re-usability",
    "href": "lecture-3.html#functions-as-re-usability",
    "title": "Python Modules",
    "section": "Functions as re-usability",
    "text": "Functions as re-usability\nIf you find yourself doing something over and over, a function call help consolidate duplication and potentially reduce the chance of getting things wrong.\n\nprint(\"The result is \", w * x1 + b)\nprint(\"The result is \", w * x2 + b)\nprint(\"The result is \", w * x3 + b)\n\n\ndef compute(var):\n    return w * var + b\n\ndef print_result(res):\n    print(\"The result is \", res)\n\nfor var in [x1, x2, x3]:\n    print_result(compute(var))"
  },
  {
    "objectID": "lecture-3.html#be-wary-of-god-classes",
    "href": "lecture-3.html#be-wary-of-god-classes",
    "title": "Python Modules",
    "section": "Be wary of God classes",
    "text": "Be wary of God classes\nGod classes/God object is a class that is doing too many things or ‘knows’ about too much. When designing a class, remember that like a function, in general, it should manage one thing or concept.\n\n\n\nclass Game:\n    def __init__(self):\n        ...\n    def create_character(self):\n        ...\n    def move_character(self):\n        ...\n    def update_score(self):\n        ...\n    def reset_score(self):\n        ...\n    def start_game(self):\n        ...\n    def end_game(self):\n        ...\n    def start_boat(self):\n        ...\n    def stop_boat(self):\n        ...\n    ...\n\n\n\nclass Game:\n    def __init__(self):\n        ...\n    def start_game(self):\n        ...\n    def end_game(self):\n        ...\n\nclass Character:\n    def __init__(self):\n        ...\n    def create_character(self):\n        ...\n    def move_character(self):\n        ...\n\nclass ScoreBoard:\n    ..."
  },
  {
    "objectID": "lecture-3.html#documentation",
    "href": "lecture-3.html#documentation",
    "title": "Python Modules",
    "section": "Documentation",
    "text": "Documentation\n\nComments that contradict the code are worse than no comments. Always make a priority of keeping the comments up-to-date when the code changes!\n\nPEP 8 Style Guide\n\nEnsure that comments are correct.\nDon’t over document (i.e. if something is self explanatory, then comments will distract rather than inform). An example from PEP 8:\n\nx = x + 1                 # Increment x\nx = x + 1                 # Compensate for border\n\nDocument what you think will be difficult to understand without some prior knowledge, such as why a particular decision was made to do something a certain way. Don’t explain, educate the reader."
  },
  {
    "objectID": "lecture-3.html#perform-testing",
    "href": "lecture-3.html#perform-testing",
    "title": "Python Modules",
    "section": "Perform testing!",
    "text": "Perform testing!\nMake sure to write tests, for example, using unittest (https://docs.python.org/3/library/unittest.html). Writing tests can help find source of bugs/mistakes in your code, and if you change something in the future, you want to make sure that it still works. Writing tests can automate the process of testing your code."
  },
  {
    "objectID": "lecture-5-reveal.html#what-is-matplotlib",
    "href": "lecture-5-reveal.html#what-is-matplotlib",
    "title": "Introduction to Matplotlib",
    "section": "What is Matplotlib?",
    "text": "What is Matplotlib?\n\nIn summary:\n\nMatplotlib is one of the defacto plotting libraries for Python. While there are many others and certainly some that are built for specific plot types, Matplotlib continues to pervade scientific plotting.\nYou can create basic plots (such as line or scatter plots) to more complicated plots that include interactivity."
  },
  {
    "objectID": "lecture-5-reveal.html#installing-and-importing-matplotlib",
    "href": "lecture-5-reveal.html#installing-and-importing-matplotlib",
    "title": "Introduction to Matplotlib",
    "section": "Installing and importing Matplotlib",
    "text": "Installing and importing Matplotlib\nMatplotlib can be installed via conda:\nconda install matplotlib\nor with pip:\npip install matplotlib\nRemember! You can install packages in ipython REPL/juypter notebook by inserting a ‘!’ to the beginning of a shell command."
  },
  {
    "objectID": "lecture-5-reveal.html#basic-plotting",
    "href": "lecture-5-reveal.html#basic-plotting",
    "title": "Introduction to Matplotlib",
    "section": "Basic plotting",
    "text": "Basic plotting\nFirst, we will import the matplotlib module. The plotting function is located within the pyplot package within matplotlib. The use of this package is so common that 99% of Python users will alias this import as plt:\nWith this package now imported, we can now use the plot function. To begin with, let’s just plot a simple line chart. In this case, the plot function takes an x and y argument, where x denotes the values along the x-axis and y are the values along the y-axis.\n\n\n\n\n\nIn this example, we have created two vectors. The first x, creates a vector of 100 values from -10 to 10. y is the sin function applied to x. Finally, in the third line, we plot the sin wave using these two vectors."
  },
  {
    "objectID": "lecture-5-reveal.html#different-types-of-plots",
    "href": "lecture-5-reveal.html#different-types-of-plots",
    "title": "Introduction to Matplotlib",
    "section": "Different types of Plots",
    "text": "Different types of Plots\n\nThere are many different types of plots that one can make using matplotlib. These include the most popular:\n\nLine plots\nScatter plots\nBar plots\nHistograms\nBox plots\nImage plots\n\nWe’re going to take a look at how we create each type of plot, examining what type of inputs they require."
  },
  {
    "objectID": "lecture-5-reveal.html#line-plots",
    "href": "lecture-5-reveal.html#line-plots",
    "title": "Introduction to Matplotlib",
    "section": "Line plots",
    "text": "Line plots\nWe’ve already seen one example of a line plot. This plot draws a line between each x,y point. For instance in the previous example, we created a sin wave by ‘sampling’ such wave using 100 samples from -10 to 10. Let’s see what happens when we sample only 10 points:\n\n\n\n\n\nWe see the results are a less than ideal representation of a sin wave as plot will simply draw a straight line from each point."
  },
  {
    "objectID": "lecture-5-reveal.html#scatter-plots",
    "href": "lecture-5-reveal.html#scatter-plots",
    "title": "Introduction to Matplotlib",
    "section": "Scatter plots",
    "text": "Scatter plots\nIf we want to see where each sample of the sin wave is, we could use instead the scatter plot, which will (by default) place a small circle at every x,y value. To create a scatter plot, we use scatter instead of the plot function. The arguments to this function are the same, however.\n\n\n\n\n\nNow we can see the position of each individual sample from the sin wave. If we, once again, sample 100 points from this curve, we will see better results."
  },
  {
    "objectID": "lecture-5-reveal.html#bar-plots",
    "href": "lecture-5-reveal.html#bar-plots",
    "title": "Introduction to Matplotlib",
    "section": "Bar plots",
    "text": "Bar plots\nBar plots are a simple plot that again takes an x and a y, where x is the numerical position of the bar’s centre, and y is the height of the bar."
  },
  {
    "objectID": "lecture-5-reveal.html#histograms",
    "href": "lecture-5-reveal.html#histograms",
    "title": "Introduction to Matplotlib",
    "section": "Histograms",
    "text": "Histograms\nHistograms allow us to visualise the distribution of values. In matplotlib, we can create a histogram of a vector by using the hist function that takes only the vector as its argument."
  },
  {
    "objectID": "lecture-5-reveal.html#box-plots",
    "href": "lecture-5-reveal.html#box-plots",
    "title": "Introduction to Matplotlib",
    "section": "Box plots",
    "text": "Box plots\nBox plots also allow us to visualise the distribution, but the distribution of values within a group. In this example we’re visualising the distribution of 3 groups. Using the boxplot function, we pass a matrix."
  },
  {
    "objectID": "lecture-5-reveal.html#image-plots",
    "href": "lecture-5-reveal.html#image-plots",
    "title": "Introduction to Matplotlib",
    "section": "Image plots",
    "text": "Image plots\nIn matplotlib, we can plot an ‘image’ – that is a 2D matrix – using the imshow function. For example:\n\n\n\n\n\n\nOf course, given the name, we can then use imshow to plot an image as well, as long as we have the image loaded as a 2D array of values."
  },
  {
    "objectID": "lecture-5-reveal.html#dimensional-plots",
    "href": "lecture-5-reveal.html#dimensional-plots",
    "title": "Introduction to Matplotlib",
    "section": "3 dimensional plots",
    "text": "3 dimensional plots\n3 dimensional plots require us to import another module from matplotlib.\nAfter importing this module, we can using the projection=“3d” and carry on plotting as normal."
  },
  {
    "objectID": "lecture-5-reveal.html#other-types-of-plots",
    "href": "lecture-5-reveal.html#other-types-of-plots",
    "title": "Introduction to Matplotlib",
    "section": "Other types of Plots",
    "text": "Other types of Plots\nThere are many more different types of plots you can make using matplotlib. You can find a comprehensive list at:\nhttps://matplotlib.org/stable/plot_types/index.html"
  },
  {
    "objectID": "lecture-5-reveal.html#subplots",
    "href": "lecture-5-reveal.html#subplots",
    "title": "Introduction to Matplotlib",
    "section": "Subplots",
    "text": "Subplots\nWhat if we wanted to create many plots side-by-side? For this we can use the subplots function. This function takes the number of rows, and number of columns to create. It returns two values, the first is the figure (entire figure), and the second value is a list of sub figures. Using this list, we can place a plot of each of them."
  },
  {
    "objectID": "lecture-5-reveal.html#adding-a-legend",
    "href": "lecture-5-reveal.html#adding-a-legend",
    "title": "Introduction to Matplotlib",
    "section": "Adding a legend",
    "text": "Adding a legend\nOr we could put them onto the same plot. Matplotlib will automatically give them a different colour. If we use the label argument to plot, we can also give them a name that will appear when we call legend()."
  },
  {
    "objectID": "lecture-5-reveal.html#position-the-legend-in-different-places",
    "href": "lecture-5-reveal.html#position-the-legend-in-different-places",
    "title": "Introduction to Matplotlib",
    "section": "Position the legend in different places",
    "text": "Position the legend in different places\nWe can change the position of the legend by specifying a different integer value for the loc argument (or string values such as ‘upper left’, ‘upper right’, …). Additionally, we can change the number of columns the legend has with the ncol argument.\n\n\n\n\n\nYou can find the API reference for the different arguments to legend at: https://matplotlib.org/stable/api/legend_api.html?highlight=legend#module-matplotlib.legend"
  },
  {
    "objectID": "lecture-5-reveal.html#modifying-the-xy-axis",
    "href": "lecture-5-reveal.html#modifying-the-xy-axis",
    "title": "Introduction to Matplotlib",
    "section": "Modifying the x/y axis",
    "text": "Modifying the x/y axis\nGood graphs always have their axis’s labelled. To do this in matplotlib, if we have a subplot object, we use set_xlabel, or we can use plt.xlabel(...). Here is an example with an subplot object:"
  },
  {
    "objectID": "lecture-5-reveal.html#changing-figure-size",
    "href": "lecture-5-reveal.html#changing-figure-size",
    "title": "Introduction to Matplotlib",
    "section": "Changing figure size",
    "text": "Changing figure size\nA common change you may want to make to your figure is to change its size or aspect ratio. figure() or subplots() take an optional argument called figsize. This argument expects a tuple representing the width and height of the figure in inches.\n\n\n&lt;Figure size 768x240 with 0 Axes&gt;\n\n\n\n\n\nHere we are creating a figure with 8 inches of width, and 2.5 inches of height.\n\nThis is especially useful when you have many sub-figures, as by default, they will be ‘squashed’ into the default aspect ratio. We can ‘give them more space’ by modifying this figsize argument when creating the many sub-figures."
  },
  {
    "objectID": "lecture-5-reveal.html#line-properties",
    "href": "lecture-5-reveal.html#line-properties",
    "title": "Introduction to Matplotlib",
    "section": "Line properties",
    "text": "Line properties\nWhen creating a plot, there are many different properties you can change. Some of these include:\n\ncolor – the colour of the line\nalpha – the amount of transparency (1.0 is opaque, 0.0 is transparent)\nlinewidth, lw – the width of the stroke width\nlinestyle, ls – the style of the line (i.e. a dotted line)\n\nThere are also some properties for the markers, i.e. the circles in the scatter plot. These properties are:\n\nmarker – the type of marker (you can use different shapes instead of a circle\nmarkersize – the size of the mark\nmarkerfacecolor – colour of the marker\nmarkeredgewidth – outline width of the marker.\n\nIf this example we are modifying some of the line properties that include the color (c), setting it to a string value of “green”. The linewidth (lw) to be thicker, and making the line to be a dotted line by specifying the linestyle (ls) to “=–={”."
  },
  {
    "objectID": "lecture-5-reveal.html#colourmaps",
    "href": "lecture-5-reveal.html#colourmaps",
    "title": "Introduction to Matplotlib",
    "section": "Colourmaps",
    "text": "Colourmaps\nWhen we create a heatmap using imshow, the gradients of colour are automatically set. Yet, we can control the colour gradient using a colour map. First we must import cm from matplotlib:\nThen we can get a colour map with 10 levels using get_cmap:\nYou can find a full list of different colour maps at: https://matplotlib.org/stable/tutorials/colors/colormaps.html\nNow that we have our new colour maps, we can pass it as an cmap argument when we create a plot."
  },
  {
    "objectID": "lecture-5-reveal.html#ticks",
    "href": "lecture-5-reveal.html#ticks",
    "title": "Introduction to Matplotlib",
    "section": "Ticks",
    "text": "Ticks\nIf we want to customise the numbers along each axis, we use the set_xticks for the x-axis and set_yticks for the y-axis. These functions take the list of locations for each ‘tick’, and optionally a list of labels to use instead of the numbers."
  },
  {
    "objectID": "lecture-5-reveal.html#grids",
    "href": "lecture-5-reveal.html#grids",
    "title": "Introduction to Matplotlib",
    "section": "Grids",
    "text": "Grids\nIn all of the previous plots, the background has no grids, they are simply white. If we wanted to add grid lines to the plot we use the .grid() method. This function, by default, adds the major grid lines."
  },
  {
    "objectID": "lecture-5-reveal.html#scale",
    "href": "lecture-5-reveal.html#scale",
    "title": "Introduction to Matplotlib",
    "section": "Scale",
    "text": "Scale\nThe default behaviour of matplotlib is to plot using a linear scale. In certain situations, we want view the plot using a different scale. For this we can use set_yscale."
  },
  {
    "objectID": "lecture-5-reveal.html#setting-the-plot-limits",
    "href": "lecture-5-reveal.html#setting-the-plot-limits",
    "title": "Introduction to Matplotlib",
    "section": "Setting the plot limits",
    "text": "Setting the plot limits\nBy default, matplotlib will calculate the minimum and maximum values of the data, and use those values to set the limits of the plot. Using set_xlim and set_ylim we can change this default behaviour."
  },
  {
    "objectID": "lecture-5-reveal.html#annotations",
    "href": "lecture-5-reveal.html#annotations",
    "title": "Introduction to Matplotlib",
    "section": "Annotations",
    "text": "Annotations\nWe can annotate our plot in a number of way:\n\n.axhline – plot a horizontal line (axvline for vertical lines)/\n.annotate – add text to the plot at a certain position."
  },
  {
    "objectID": "lecture-5-reveal.html#creating-a-twin-axes-plot",
    "href": "lecture-5-reveal.html#creating-a-twin-axes-plot",
    "title": "Introduction to Matplotlib",
    "section": "Creating a twin axes plot",
    "text": "Creating a twin axes plot\nSometimes you will want to display multiple sub-plots on the same plot, but where each have a very different range in values. Instead of having a single y-axis, with twinx() we can create a two y-axis plot."
  },
  {
    "objectID": "lecture-5.html",
    "href": "lecture-5.html",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "In summary:\n\nMatplotlib is one of the defacto plotting libraries for Python. While there are many others and certainly some that are built for specific plot types, Matplotlib continues to pervade scientific plotting.\nYou can create basic plots (such as line or scatter plots) to more complicated plots that include interactivity.\n\n\n\n\nMatplotlib can be installed via conda:\nconda install matplotlib\nor with pip:\npip install matplotlib\nRemember! You can install packages in ipython REPL/juypter notebook by inserting a ‘!’ to the beginning of a shell command.\n\n\n\nFirst, we will import the matplotlib module. The plotting function is located within the pyplot package within matplotlib. The use of this package is so common that 99% of Python users will alias this import as plt:\n\nimport matplotlib.pyplot as plt\n\nWith this package now imported, we can now use the plot function. To begin with, let’s just plot a simple line chart. In this case, the plot function takes an x and y argument, where x denotes the values along the x-axis and y are the values along the y-axis.\n\nimport numpy as np\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.show()\n\n\n\n\nIn this example, we have created two vectors. The first x, creates a vector of 100 values from -10 to 10. y is the sin function applied to x. Finally, in the third line, we plot the sin wave using these two vectors."
  },
  {
    "objectID": "lecture-5.html#what-is-matplotlib",
    "href": "lecture-5.html#what-is-matplotlib",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "In summary:\n\nMatplotlib is one of the defacto plotting libraries for Python. While there are many others and certainly some that are built for specific plot types, Matplotlib continues to pervade scientific plotting.\nYou can create basic plots (such as line or scatter plots) to more complicated plots that include interactivity."
  },
  {
    "objectID": "lecture-5.html#installing-and-importing-matplotlib",
    "href": "lecture-5.html#installing-and-importing-matplotlib",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "Matplotlib can be installed via conda:\nconda install matplotlib\nor with pip:\npip install matplotlib\nRemember! You can install packages in ipython REPL/juypter notebook by inserting a ‘!’ to the beginning of a shell command."
  },
  {
    "objectID": "lecture-5.html#basic-plotting",
    "href": "lecture-5.html#basic-plotting",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "First, we will import the matplotlib module. The plotting function is located within the pyplot package within matplotlib. The use of this package is so common that 99% of Python users will alias this import as plt:\n\nimport matplotlib.pyplot as plt\n\nWith this package now imported, we can now use the plot function. To begin with, let’s just plot a simple line chart. In this case, the plot function takes an x and y argument, where x denotes the values along the x-axis and y are the values along the y-axis.\n\nimport numpy as np\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.show()\n\n\n\n\nIn this example, we have created two vectors. The first x, creates a vector of 100 values from -10 to 10. y is the sin function applied to x. Finally, in the third line, we plot the sin wave using these two vectors."
  },
  {
    "objectID": "lecture-5.html#different-types-of-plots",
    "href": "lecture-5.html#different-types-of-plots",
    "title": "Introduction to Matplotlib",
    "section": "Different types of Plots",
    "text": "Different types of Plots\n\nThere are many different types of plots that one can make using matplotlib. These include the most popular:\n\nLine plots\nScatter plots\nBar plots\nHistograms\nBox plots\nImage plots\n\nWe’re going to take a look at how we create each type of plot, examining what type of inputs they require."
  },
  {
    "objectID": "lecture-5.html#line-plots",
    "href": "lecture-5.html#line-plots",
    "title": "Introduction to Matplotlib",
    "section": "Line plots",
    "text": "Line plots\nWe’ve already seen one example of a line plot. This plot draws a line between each x,y point. For instance in the previous example, we created a sin wave by ‘sampling’ such wave using 100 samples from -10 to 10. Let’s see what happens when we sample only 10 points:\n\nx = np.linspace(-10, 10, 10)\ny = np.sin(x)\nplt.plot(x, y)\nplt.show()\n\n\n\n\nWe see the results are a less than ideal representation of a sin wave as plot will simply draw a straight line from each point."
  },
  {
    "objectID": "lecture-5.html#scatter-plots",
    "href": "lecture-5.html#scatter-plots",
    "title": "Introduction to Matplotlib",
    "section": "Scatter plots",
    "text": "Scatter plots\nIf we want to see where each sample of the sin wave is, we could use instead the scatter plot, which will (by default) place a small circle at every x,y value. To create a scatter plot, we use scatter instead of the plot function. The arguments to this function are the same, however.\n\nx = np.linspace(-10, 10, 10)\ny = np.sin(x)\nplt.scatter(x, y)\nplt.show()\n\n\n\n\nNow we can see the position of each individual sample from the sin wave. If we, once again, sample 100 points from this curve, we will see better results.\n\n\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nplt.scatter(x, y)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#bar-plots",
    "href": "lecture-5.html#bar-plots",
    "title": "Introduction to Matplotlib",
    "section": "Bar plots",
    "text": "Bar plots\nBar plots are a simple plot that again takes an x and a y, where x is the numerical position of the bar’s centre, and y is the height of the bar.\n\nx = np.arange(0, 8)\ny = np.random.uniform(2, 7, len(x))\nplt.bar(x, y)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#histograms",
    "href": "lecture-5.html#histograms",
    "title": "Introduction to Matplotlib",
    "section": "Histograms",
    "text": "Histograms\nHistograms allow us to visualise the distribution of values. In matplotlib, we can create a histogram of a vector by using the hist function that takes only the vector as its argument.\n\nx = np.random.randn(1000)\nplt.hist(x)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#box-plots",
    "href": "lecture-5.html#box-plots",
    "title": "Introduction to Matplotlib",
    "section": "Box plots",
    "text": "Box plots\nBox plots also allow us to visualise the distribution, but the distribution of values within a group. In this example we’re visualising the distribution of 3 groups. Using the boxplot function, we pass a matrix.\n\nx = np.random.randn(10, 3)\nplt.boxplot(x)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#image-plots",
    "href": "lecture-5.html#image-plots",
    "title": "Introduction to Matplotlib",
    "section": "Image plots",
    "text": "Image plots\nIn matplotlib, we can plot an ‘image’ – that is a 2D matrix – using the imshow function. For example:\n\nfig = plt.figure()\nx = np.random.randn(10, 10)\nplt.imshow(x)\nplt.show()\n\n\n\n\n\nOf course, given the name, we can then use imshow to plot an image as well, as long as we have the image loaded as a 2D array of values.\n\nfrom PIL import Image  # using the PIL module to read an image\nimg = np.array(Image.open(\"images/Lenna.png\"))\nplt.imshow(img)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#dimensional-plots",
    "href": "lecture-5.html#dimensional-plots",
    "title": "Introduction to Matplotlib",
    "section": "3 dimensional plots",
    "text": "3 dimensional plots\n3 dimensional plots require us to import another module from matplotlib.\n\nfrom mpl_toolkits import mplot3d\n\nAfter importing this module, we can using the projection=“3d” and carry on plotting as normal.\n\nfig = plt.figure()\n# older matplotlib\n# ax = fig.gca(projection='3d')\n# newest version\nax = fig.add_subplot(projection='3d')\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\nax.plot(x, y, z, label='parametric curve')\nax.legend()\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#other-types-of-plots",
    "href": "lecture-5.html#other-types-of-plots",
    "title": "Introduction to Matplotlib",
    "section": "Other types of Plots",
    "text": "Other types of Plots\nThere are many more different types of plots you can make using matplotlib. You can find a comprehensive list at:\nhttps://matplotlib.org/stable/plot_types/index.html"
  },
  {
    "objectID": "lecture-5.html#subplots",
    "href": "lecture-5.html#subplots",
    "title": "Introduction to Matplotlib",
    "section": "Subplots",
    "text": "Subplots\nWhat if we wanted to create many plots side-by-side? For this we can use the subplots function. This function takes the number of rows, and number of columns to create. It returns two values, the first is the figure (entire figure), and the second value is a list of sub figures. Using this list, we can place a plot of each of them.\n\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.cos(y)\n\nfig, ax = plt.subplots(1, 2)\n# ax is a list of sub figures\nax[0].plot(x, y)\nax[1].plot(x, z)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#adding-a-legend",
    "href": "lecture-5.html#adding-a-legend",
    "title": "Introduction to Matplotlib",
    "section": "Adding a legend",
    "text": "Adding a legend\nOr we could put them onto the same plot. Matplotlib will automatically give them a different colour. If we use the label argument to plot, we can also give them a name that will appear when we call legend().\n\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.tan(y)\nfig, ax = plt.subplots()\nax.plot(x, y, label=\"sin(x)\")\nax.plot(x, z, label=\"tan(x)\")\nax.legend()\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#position-the-legend-in-different-places",
    "href": "lecture-5.html#position-the-legend-in-different-places",
    "title": "Introduction to Matplotlib",
    "section": "Position the legend in different places",
    "text": "Position the legend in different places\nWe can change the position of the legend by specifying a different integer value for the loc argument (or string values such as ‘upper left’, ‘upper right’, …). Additionally, we can change the number of columns the legend has with the ncol argument.\n\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.tan(y)\n\nfig, ax = plt.subplots()\nax.plot(x, y, label=\"sin(x)\")\nax.plot(x, z, label=\"tan(x)\")\nax.legend(loc=1, ncol=2)\nplt.show()\n\n\n\n\nYou can find the API reference for the different arguments to legend at: https://matplotlib.org/stable/api/legend_api.html?highlight=legend#module-matplotlib.legend"
  },
  {
    "objectID": "lecture-5.html#modifying-the-xy-axis",
    "href": "lecture-5.html#modifying-the-xy-axis",
    "title": "Introduction to Matplotlib",
    "section": "Modifying the x/y axis",
    "text": "Modifying the x/y axis\nGood graphs always have their axis’s labelled. To do this in matplotlib, if we have a subplot object, we use set_xlabel, or we can use plt.xlabel(...). Here is an example with an subplot object:\n\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.tan(y)\n\nfig, ax = plt.subplots()\nax.plot(x, y, label=\"sin(x)\")\nax.plot(x, z, label=\"tan(x)\")\nax.legend(loc=1, ncol=2)\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#changing-figure-size",
    "href": "lecture-5.html#changing-figure-size",
    "title": "Introduction to Matplotlib",
    "section": "Changing figure size",
    "text": "Changing figure size\nA common change you may want to make to your figure is to change its size or aspect ratio. figure() or subplots() take an optional argument called figsize. This argument expects a tuple representing the width and height of the figure in inches.\n\nfig = plt.figure(figsize=(8, 2.5))\n\n# or most likely\nfig, ax = plt.subplots(figsize=(8, 2.5))\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.tan(y)\nax.plot(x, y, label=\"sin(x)\")\nax.plot(x, z, label=\"tan(x)\")\nax.legend(loc=1, ncol=2)\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nplt.show()\n\n&lt;Figure size 768x240 with 0 Axes&gt;\n\n\n\n\n\nHere we are creating a figure with 8 inches of width, and 2.5 inches of height.\n\nThis is especially useful when you have many sub-figures, as by default, they will be ‘squashed’ into the default aspect ratio. We can ‘give them more space’ by modifying this figsize argument when creating the many sub-figures.\n\nfig, ax = plt.subplots(1, 2, figsize=(8, 2.5))\nx = np.linspace(-10, 10, 100)\ny = np.sin(x)\nz = np.tan(y)\nax[0].plot(x, y, label=\"sin(x)\")\nax[1].plot(x, z, label=\"tan(x)\")\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#line-properties",
    "href": "lecture-5.html#line-properties",
    "title": "Introduction to Matplotlib",
    "section": "Line properties",
    "text": "Line properties\nWhen creating a plot, there are many different properties you can change. Some of these include:\n\ncolor – the colour of the line\nalpha – the amount of transparency (1.0 is opaque, 0.0 is transparent)\nlinewidth, lw – the width of the stroke width\nlinestyle, ls – the style of the line (i.e. a dotted line)\n\nThere are also some properties for the markers, i.e. the circles in the scatter plot. These properties are:\n\nmarker – the type of marker (you can use different shapes instead of a circle\nmarkersize – the size of the mark\nmarkerfacecolor – colour of the marker\nmarkeredgewidth – outline width of the marker.\n\nIf this example we are modifying some of the line properties that include the color (c), setting it to a string value of “green”. The linewidth (lw) to be thicker, and making the line to be a dotted line by specifying the linestyle (ls) to “=–={”.\n\nfig = plt.figure()\nx = np.linspace(-5, 5, 100)\ny = np.sin(x)\nplt.plot(x, y,\n         c=\"green\", # or color\n         lw=3, # or linewidth\n         ls=\"--\")\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#colourmaps",
    "href": "lecture-5.html#colourmaps",
    "title": "Introduction to Matplotlib",
    "section": "Colourmaps",
    "text": "Colourmaps\nWhen we create a heatmap using imshow, the gradients of colour are automatically set. Yet, we can control the colour gradient using a colour map. First we must import cm from matplotlib:\n\nfrom matplotlib import cm\n\nThen we can get a colour map with 10 levels using get_cmap:\n\nblues = cm.get_cmap(\"Blues\", 10) # 10 levels\nreds = cm.get_cmap(\"Reds\", 2) # 2 levels\n\n/var/folders/fk/z5hmt4c13pv884phdfytrwsh0000gn/T/ipykernel_7449/226750876.py:1: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  blues = cm.get_cmap(\"Blues\", 10) # 10 levels\n/var/folders/fk/z5hmt4c13pv884phdfytrwsh0000gn/T/ipykernel_7449/226750876.py:2: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  reds = cm.get_cmap(\"Reds\", 2) # 2 levels\n\n\nYou can find a full list of different colour maps at: https://matplotlib.org/stable/tutorials/colors/colormaps.html\nNow that we have our new colour maps, we can pass it as an cmap argument when we create a plot.\n\nx = np.random.randn(10, 10)\ny = np.random.randn(10, 10)\nfig, ax = plt.subplots(1, 2, figsize=(8, 3))\np1 = ax[0].imshow(x, cmap=blues)\np2 = ax[1].imshow(y, cmap=reds)\nfig.colorbar(p1, ax=ax[0])\nfig.colorbar(p2, ax=ax[1])\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#ticks",
    "href": "lecture-5.html#ticks",
    "title": "Introduction to Matplotlib",
    "section": "Ticks",
    "text": "Ticks\nIf we want to customise the numbers along each axis, we use the set_xticks for the x-axis and set_yticks for the y-axis. These functions take the list of locations for each ‘tick’, and optionally a list of labels to use instead of the numbers.\n\nx = np.linspace(-2, 2, 100)\ny = np.sin(x)\n\nbx = np.arange(2, 7)\nby = np.random.uniform(2, 7, len(bx))\n\nfig, ax = plt.subplots(1, 2, figsize=(8, 3))\nax[0].plot(x, y)\nax[0].set_xticks([-2, 0, 2])\nax[1].bar(bx, by)\nax[1].set_xticks(bx, [\"a\", \"b\", \"c\", \"d\", \"e\"])\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#grids",
    "href": "lecture-5.html#grids",
    "title": "Introduction to Matplotlib",
    "section": "Grids",
    "text": "Grids\nIn all of the previous plots, the background has no grids, they are simply white. If we wanted to add grid lines to the plot we use the .grid() method. This function, by default, adds the major grid lines.\n\nx = np.linspace(-2, 2, 100)\ny = np.sin(x)\nz = np.tan(x)\nfig, ax = plt.subplots(1, 2, figsize=(8, 3))\nax[0].plot(x, y)\nax[0].grid()\nax[1].plot(x, z)\nax[1].grid(which=\"both\", color=\"r\")\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#scale",
    "href": "lecture-5.html#scale",
    "title": "Introduction to Matplotlib",
    "section": "Scale",
    "text": "Scale\nThe default behaviour of matplotlib is to plot using a linear scale. In certain situations, we want view the plot using a different scale. For this we can use set_yscale.\n\nx = np.linspace(-2, 10, 100)\ny = np.exp(x)\nfig, ax = plt.subplots(1, 2, figsize=(8, 3))\nax[0].plot(x, y)\nax[0].grid()\nax[1].plot(x, y)\nax[1].set_yscale('log')\nax[1].grid()\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#setting-the-plot-limits",
    "href": "lecture-5.html#setting-the-plot-limits",
    "title": "Introduction to Matplotlib",
    "section": "Setting the plot limits",
    "text": "Setting the plot limits\nBy default, matplotlib will calculate the minimum and maximum values of the data, and use those values to set the limits of the plot. Using set_xlim and set_ylim we can change this default behaviour.\n\nx = np.linspace(-2, 2, 100)\ny = np.sin(x)\nfig, ax = plt.subplots(1, 2, figsize=(8,3))\nax[0].plot(x, y)\nax[0].set_ylim(-1, 2)\nax[1].plot(x, y)\nax[1].set_xlim(-3, 3)\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#annotations",
    "href": "lecture-5.html#annotations",
    "title": "Introduction to Matplotlib",
    "section": "Annotations",
    "text": "Annotations\nWe can annotate our plot in a number of way:\n\n.axhline – plot a horizontal line (axvline for vertical lines)/\n.annotate – add text to the plot at a certain position.\n\n\nx = np.linspace(-2, 2, 100)\ny = np.sin(x)\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.axhline(0, c='gray', ls='--')\nax.annotate(\"0th line\", \n            (-2, 0), \n            xytext=(-1.5, 0.25),\n            arrowprops=dict(\n                facecolor='black', \n                shrink=0.05,\n                width=0.5, \n                headwidth=5.0))\nplt.show()"
  },
  {
    "objectID": "lecture-5.html#creating-a-twin-axes-plot",
    "href": "lecture-5.html#creating-a-twin-axes-plot",
    "title": "Introduction to Matplotlib",
    "section": "Creating a twin axes plot",
    "text": "Creating a twin axes plot\nSometimes you will want to display multiple sub-plots on the same plot, but where each have a very different range in values. Instead of having a single y-axis, with twinx() we can create a two y-axis plot.\n\nx = np.arange(10, 100)\ny = np.exp(x)\nz = np.log(x)\n\nfig, ax = plt.subplots(1, 2)\nax[0].plot(x, y, label=\"exp(x)\")\nax[0].plot(x, z, label=\"log(x)\")\nax[0].legend()\n\nax2 = ax[1].twinx()\nax[1].plot(x, y)\nax2.plot(x, z, color=\"orange\")\nax2.tick_params(axis=\"y\", labelcolor=\"orange\")\nplt.show()"
  },
  {
    "objectID": "lecture-7-reveal.html#what-is-linux",
    "href": "lecture-7-reveal.html#what-is-linux",
    "title": "Linux & Supercomputer",
    "section": "What is Linux?",
    "text": "What is Linux?\n\nLinux is a popular operating system (OS) like Windows, or MacOS.\nUnlike these other two OSs, Linux is open source, which means the source code is freely available to look at and modify.\nAs its open source, its very possible for anyone to build their own version of Linux or build on top of Linux to create their own Distribution of Linux."
  },
  {
    "objectID": "lecture-7-reveal.html#whats-a-distribution",
    "href": "lecture-7-reveal.html#whats-a-distribution",
    "title": "Linux & Supercomputer",
    "section": "What’s a Distribution?",
    "text": "What’s a Distribution?\nA distribution can be considered like a flavour or version of Linux. There are many popular flavours that attempt to meet different needs from different users. For example:\n\nUbuntu – typically the first Linux experience people will have. Attempts to be very user friendly.\nFedora – stable and secure distribution while also providing up-to-date packages.\nArch Linux – strong focus on customisability rather than user friendliness with bleeding edge packages."
  },
  {
    "objectID": "lecture-7-reveal.html#defining-traits-of-linux",
    "href": "lecture-7-reveal.html#defining-traits-of-linux",
    "title": "Linux & Supercomputer",
    "section": "Defining Traits of Linux",
    "text": "Defining Traits of Linux\nWhile we have said that Linux is open source, there are many other traits that make it stand out from other operating systems:\n\nComplete control of how the system operates.\nThe level of flexibility and automation that you can get from using the Linux command line.\n\nWhile there are many other traits, these two are going to be what we’re going to focus on."
  },
  {
    "objectID": "lecture-7-reveal.html#whats-a-command",
    "href": "lecture-7-reveal.html#whats-a-command",
    "title": "Linux & Supercomputer",
    "section": "What’s a command?",
    "text": "What’s a command?\nWhile many recent versions of Linux makes things more accessible via GUIs, they will never be a substitute for using the command line. We’re going to learn how to control the system via the command line, via a shell. A shell, like the Python REPL we’ve already seen, is waits for you to input commands, executes the command, and prints the output if there is output to print.\nA Linux command is a call to a program optionally followed by some arguments. For example, if we want list out the files and folders in the directory, we would use the ls (list) command:\nls\nThe ls command comes with a number of optional flags and arguments that we can add onto the call. When calling a command a flag is something that begins with a - , for example -l tells ls to list the directory in a list format.\nls -l\nWe have supplied the -l flag. There are many other flags for ls, like for example, the human readable file systems with -h or show hidden files (files that start with a period) with -a.\nWhen we’re using multiple flags we could write\nls -l -h -a\nOr:\nls -lha\nSometimes commands take optional positional arguments. Going back to our list directory command, where, by default, it will list the current directory. But instead we can tell the command to list a particular directory by supplying the path as an argument\nls images/ -lha\n# or ls -lha images/ works too\nHow do I know how to use a command? Well that’s where another command comes in. It’s called man (short for manual). If you pass another command to the man command, the documentation will be shown in the terminal, e.g.:\nman ls  # display the documentation for ls\nThe documentation should list all the different flags and arguments, describe what they mean, and sometimes give example or most common usage of a command.\nWhen the ‘man page’ is display, you can scroll up and down the page using your arrow keys, and page-up and page-down. When you’re done reading, just hit the ‘q’ character\nI am going to go through some of the most common commands just to make sure that you’re familiar with the typical usage."
  },
  {
    "objectID": "lecture-7-reveal.html#cd",
    "href": "lecture-7-reveal.html#cd",
    "title": "Linux & Supercomputer",
    "section": "cd",
    "text": "cd\nWe’ve already seen ls to list a directory. The command to move to a directory is cd (change directory), that takes an argument of filepath to move to:\ncd ~ # tilde is short-hand for the 'home directory'\ncd ~/Documents/My\\ Files  # go to Documents and then to \"My Files\"\ncd   # no argument, by default goes to the home directory"
  },
  {
    "objectID": "lecture-7-reveal.html#mkdir",
    "href": "lecture-7-reveal.html#mkdir",
    "title": "Linux & Supercomputer",
    "section": "mkdir",
    "text": "mkdir\nSticking with the them of directories, to make a new directory we use mkdir, whose argument takes the name of the directory we want to create:\nmkdir my_new_directory\nYou can create a many level nested directory structure all at once using the -p (parents) flag, that tells mkdir if the parent directory of the target directory doesn’t exist, create it.\nmkdir photos/2020/01/05  # won't work unless photos/2020/01 exist\nmkdir -p photos/2020/01/05  # this will work"
  },
  {
    "objectID": "lecture-7-reveal.html#cp",
    "href": "lecture-7-reveal.html#cp",
    "title": "Linux & Supercomputer",
    "section": "cp",
    "text": "cp\nTo copy a file or directory, we can use the cp command. Here we are copying a file, where the first argument is the filepath of the file you want to copy and the second argument is the filepath where the copy should be placed.\ncp my_old_file my_new_file\nBy default (without a flag), cp will not work with directories, for that you have to use the -r (recursive) flag\ncp -r data/ data-backup"
  },
  {
    "objectID": "lecture-7-reveal.html#mv",
    "href": "lecture-7-reveal.html#mv",
    "title": "Linux & Supercomputer",
    "section": "mv",
    "text": "mv\nThe syntax of moving a file is similar to that of cp:\nmv old_file new_file\nExcept that it works for both files and directories without any flags. mv can also be used to rename files, that’s all renaming is: moving a file to the same directory under a different name."
  },
  {
    "objectID": "lecture-7-reveal.html#rm",
    "href": "lecture-7-reveal.html#rm",
    "title": "Linux & Supercomputer",
    "section": "rm",
    "text": "rm\nTo remove a file us rm:\nrm file_to_delete\nIf you want to delete a directory, use the -r (recursive) flag:\nrm -r directory_to_delete/"
  },
  {
    "objectID": "lecture-7-reveal.html#cat",
    "href": "lecture-7-reveal.html#cat",
    "title": "Linux & Supercomputer",
    "section": "cat",
    "text": "cat\ncat stands for concatenate, i.e. concatenating the contents of two or more files:\ncat file1 file2\nThe result is that the concatenation of these two files will be printed to the screen. If you wanted to put the result into its own file you would redirect the output using &gt;\ncat file1 file2 &gt; newfile\nSince cat reads the file and prints it to screen it is a very handy way to view the contents of a file, even if it was not intended for that."
  },
  {
    "objectID": "lecture-7-reveal.html#pwd",
    "href": "lecture-7-reveal.html#pwd",
    "title": "Linux & Supercomputer",
    "section": "pwd",
    "text": "pwd\nSometimes you may get lost when moving directories. pwd prints the current working directory from the root directory, i.e. the path that is printed is an absolute path.\npwd"
  },
  {
    "objectID": "lecture-7-reveal.html#find",
    "href": "lecture-7-reveal.html#find",
    "title": "Linux & Supercomputer",
    "section": "find",
    "text": "find\nIf we want to list all files of a certain type, we can use the wildcard * that we’ve seen before:\nls *.jpg # list all files that end with .jpg\nHowever, this will only list for the current directory. Perhaps the better way to find files will be using the find command:\nfind . -type f -name *.jpg\nThe first argument is the directory to start the search, then we define the type f being files, and then specify the name. Find will recursively search through directories and sub-directories to find all files that match that name."
  },
  {
    "objectID": "lecture-7-reveal.html#grep",
    "href": "lecture-7-reveal.html#grep",
    "title": "Linux & Supercomputer",
    "section": "grep",
    "text": "grep\nHow about if we want to find files that have a certain contents? For that we can use grep. Grep will read a file and print (by default) the lines that contains your pattern. i.e.:\ngrep 'Linux' lecture.org\nThis will print the lines that contain the word Linux in lecture.org. If we just want the matched value, we use the -o flag.\ngrep -o '[0-9]' lecture.org\nThis prints all occurrences of numbers in lecture.org"
  },
  {
    "objectID": "lecture-7-reveal.html#lessheadtail",
    "href": "lecture-7-reveal.html#lessheadtail",
    "title": "Linux & Supercomputer",
    "section": "less/head/tail",
    "text": "less/head/tail\nIf a file is very long, we may not want to read the file using cat, as it will have to print the entire file. Instead we could use less, which will allow us to navigate through the file, using arrow keys to move and q to quit.\nless filename\nIf we just want to view the first few lines, or the last few lines of a file we can use head/tail, respectively:\nhead filename\ntail -n 20 filename  # last 20 lines\ntail -F filename # constantly read the file"
  },
  {
    "objectID": "lecture-7-reveal.html#wc",
    "href": "lecture-7-reveal.html#wc",
    "title": "Linux & Supercomputer",
    "section": "wc",
    "text": "wc\nOften times we just want to count the number of something. For example, if we want to count the number of files/folders in the directory we can do:\nls -l | wc -l\nWe’re first printing all files and folders in a list format (one per line), then passing (piping_) the result to wc, which with the -l line flag, is counting the number of lines. Therefore we get a count of the number of files and folders. Here is another example where we’re counting how many times the word bash appears in these lecture notes:\ngrep -o 'bash' lecture.org | wc -l"
  },
  {
    "objectID": "lecture-7-reveal.html#piping",
    "href": "lecture-7-reveal.html#piping",
    "title": "Linux & Supercomputer",
    "section": "piping",
    "text": "piping\nThe purpose of piping is to pass data around between commands. We have just seen how we can pass the output of, say, the ls command to the input of wc. This allows use to construct very sophisticated pipelines to do some quite complex things from the combination of very simple commands.\nfind . -name '*.txt' -type f -print0 | xargs -0 grep \"something\""
  },
  {
    "objectID": "lecture-7-reveal.html#overview",
    "href": "lecture-7-reveal.html#overview",
    "title": "Linux & Supercomputer",
    "section": "Overview",
    "text": "Overview\nIn summary we have seen the following commands:\n\nls - List a directory\ncd - Change/move to a directory\nmkdir - Make a new directory\ncat - Concatenate files\ncp - Copy a file/directory\nmv - Move files/folders\nrm - Remove files and folders\npwd - Display the current absolute path\nfind - Find files\ngrep - Find occurrences of a pattern in a file\nless/head/tail - Read a file\nwc - Count"
  },
  {
    "objectID": "lecture-7-reveal.html#your-very-first-bash-script",
    "href": "lecture-7-reveal.html#your-very-first-bash-script",
    "title": "Linux & Supercomputer",
    "section": "Your Very first bash script",
    "text": "Your Very first bash script\nLet’s start with the classic ‘Hello, World’ example. We’ll create a new file called ‘hello.sh’ and enter the following:\n#!/bin/bash\n\necho \"Hello, World!\"\nFirst thing to notice is that the first line contains what we call a ‘shebang’ or ‘hashbang’. It tells Linux which shell interpreter will be used to run the script, in this case: /bin/bash\nThe next (non-empty) line in the file is echo 'Hello, World'. This is exactly the same as the other commands we’ve just seen.\nNow that we’ve created and saved our bash script, we will want to run it. We have two alternative methods to run this script:\nbash hello.sh  # run the script via bash\nThe second, requires that we have executable privileges for the script:\nchmod +x hello.sh  # add executable 'x' privileges\n./hello.sh  # execute it"
  },
  {
    "objectID": "lecture-7-reveal.html#variables",
    "href": "lecture-7-reveal.html#variables",
    "title": "Linux & Supercomputer",
    "section": "Variables",
    "text": "Variables\nThe variables we create in our bash scripts are very much the same as the environment variables we’ve seen before. Take for example:\n#!/bin/bash\nAGE=\"35\"\nPERSON_NAME=\"Jane\"\necho \"$PERSON_NAME is $AGE years old\"\nWe create a variable AGE with the = assignment operator. Note we don’t put spaces either side of the equals sign in bash. To refer to the variable, we use $AGE, using the $ dollar sign."
  },
  {
    "objectID": "lecture-7-reveal.html#interpolation-in-bash-strings",
    "href": "lecture-7-reveal.html#interpolation-in-bash-strings",
    "title": "Linux & Supercomputer",
    "section": "Interpolation in bash strings",
    "text": "Interpolation in bash strings\nYou would have noticed in the previous example that we included the variable directly into the string we’re echoing out. This is something similar to what we’ve seen with f-strings in Python.\nWhen we use double quotes: \"...\" in bash, the variable will be integrated into the resulting string. We can even call bash functions from directly inside the string:\necho \"I am logging in as: $(who)\""
  },
  {
    "objectID": "lecture-7-reveal.html#bash-strings-the-sharp-edges",
    "href": "lecture-7-reveal.html#bash-strings-the-sharp-edges",
    "title": "Linux & Supercomputer",
    "section": "Bash strings – the sharp edges",
    "text": "Bash strings – the sharp edges\nYou might be tempted to use a variable when generating a path:\nTRAIN_PROCESS=\"training\"\nTEST_PROCESS=\"testing\"\n\ntouch \"./data/$TRAIN_PROCESS_error.txt\"\ntouch \"./data/$TEST_PROCESS_error.txt\nBut this will create an error as underscores can be part of the variable name, so bash will be looking for a variable named: $TRAIN_PROCESS_error which has never been created. To get around this, we can wrap our variable in curly braces:\ntouch \"./data/${TRAIN_PROCESS}_error.txt\""
  },
  {
    "objectID": "lecture-7-reveal.html#stopping-interpolation-in-bash-strings",
    "href": "lecture-7-reveal.html#stopping-interpolation-in-bash-strings",
    "title": "Linux & Supercomputer",
    "section": "Stopping interpolation in bash strings",
    "text": "Stopping interpolation in bash strings\nWe can also use single quotes for strings in bash. When we use these strings, the string itself is not interpreted, and thus it will ignore any variables or bash commands:\necho 'I am logging in as: $(who)'"
  },
  {
    "objectID": "lecture-7-reveal.html#inputoutput",
    "href": "lecture-7-reveal.html#inputoutput",
    "title": "Linux & Supercomputer",
    "section": "Input/Output",
    "text": "Input/Output\nIf we want to read the input from keyboard into a variable, we use the read command:\n#!/bin/bash\n\necho \"Enter your name:\"\nread NAME\n\necho \"Hello, $NAME\"\nread in this context will read in the input and create the variable with that value. As we’ve already seen, we can then output this value to the console using the echo command."
  },
  {
    "objectID": "lecture-7-reveal.html#booleans",
    "href": "lecture-7-reveal.html#booleans",
    "title": "Linux & Supercomputer",
    "section": "Booleans",
    "text": "Booleans\nTechnically, bash does not have built in data types for true and false, but Linux has the commands true and false which we could use in place. The implementation of how these commands work is not important.\nFILE_EXISTS=true\n\nif [ \"$FILE_EXISTS\" = true ]; then\necho \"The file exists!\"\nfi"
  },
  {
    "objectID": "lecture-7-reveal.html#conditionals",
    "href": "lecture-7-reveal.html#conditionals",
    "title": "Linux & Supercomputer",
    "section": "Conditionals",
    "text": "Conditionals\nWhen we’re creating if expressions, we use the following syntax:\nif &lt;&lt;conditional&gt;&gt;; then\n   # do something\nelse\n   # do something else\nfi\nWe can also use elif\nif &lt;&lt;conditional&gt;&gt;; then\n   # do something\nelif &lt;&lt;conditional&gt;&gt;; then\n   # do something else\nelse\n   # something else entirely\nfi\nWriting condition expressions can be a little more cumbersome than in Python. These can be many pain points for new bash programmers, take for example:\nFILE_EXISTS=false\n\nif [ $FILE_EXISTS ]; then\necho \"The file exists!\"\nfi\nThis is because we have used the [...] single bracket syntax for the test. But there are others:\n\nNo brackets: we could omit the brackets in which case it would run the false command not print the statement.\nSingle paranthesis (...) creates a sub-shell.\nDouble paranthesis ((...)) for arithmetic operation\nSingle square bracket [...] calls test\nDouble square bracket [[...]]\n\nWhat if we write:\nVAR_1=\"Mr Foo Bar\"\nVAR_2=\"Mr Foo Bar\"\nif [ $VAR_1 = $VAR_2 ]; then\necho \"They are the same\"\nfi\nWe would get an error because test expands the arguments into:\nMr Foo Bar = Mr Foo Bar\nWith the spaces included. To prevent this from happening, we have to wrap the variables in quotation marks.\nVAR_1=\"Mr Foo Bar\"\nVAR_2=\"Mr Foo Bar\"\nif [ \"$VAR_1\" = \"$VAR_2\" ]; then\necho \"They are the same\"\nfi\nIf we use [[ in if statement, then we can do more sophisticated things like pattern matching:\nFILENAME=\"testing.png\"\nif [[ \"$FILENAME\" = *.png ]]; then\necho \"Its a png file\"\nfi"
  },
  {
    "objectID": "lecture-7-reveal.html#loops",
    "href": "lecture-7-reveal.html#loops",
    "title": "Linux & Supercomputer",
    "section": "Loops",
    "text": "Loops\nLike in Python, we can iterate in bash\nfor i in {1..10}; do\necho $i\ndone\nThis iterates with i starting at 1 upto 10 (inclusive). Or we could do:\nfor (( i=1; i &lt;= 10; i++ )); do\necho $i\ndone\nWe can also iterate over a list of files/folders in a directory:\nfor FILE in ./images/*; do\necho $FILE\ndone\nUsing the while form, we can continue looping until our conditional is false. For example, we could loop testing our internet connection, until its been established:\nwhile ! ping -c 1 google.com; do\necho \"No internet yet\"\nsleep 1\ndone\n\necho \"Internet is available!\""
  },
  {
    "objectID": "lecture-7-reveal.html#functions",
    "href": "lecture-7-reveal.html#functions",
    "title": "Linux & Supercomputer",
    "section": "Functions",
    "text": "Functions\nTo create a function, we use the following syntax:\nfunction_name() {\n# do something\n}\nAnd to call the function, you just need to use the function name:\nfunction_name # this called function name\nHere is another example:\nsay_hello() {\necho \"Hello, $1\"\n}\n\nsay_hello \"Jane\"\nNotice that we didn’t need to include any argument list. We just used $1 for the first argument passed to the function.\nsay_hello() {\necho \"$1, $2\"\n}\n\nsay_hello \"Hi\" \"Jane\"\nReturning values is ‘interesting’ as, coming from other languages, you think could do something like this:\nsay_hello() {\nreturn \"hello\"\n}\nRESULT=\"$(say_hello)\"\necho $RESULT\nThis didn’t work like we expected, the value wasn’t returned and assigned to RESULT. So how do we return a value?\nsay_hello() {\necho \"Hello\"\n}\nRESULT=\"$(say_hello)\"\necho \"This is before the printing of result\"\necho $RESULT"
  },
  {
    "objectID": "lecture-7-reveal.html#how-to-login",
    "href": "lecture-7-reveal.html#how-to-login",
    "title": "Linux & Supercomputer",
    "section": "How to login",
    "text": "How to login\nssh &lt;&lt;username&gt;&gt;@sms-ext.lis-lab.fr\nTyping this command can become tiresome very quickly, especially after sending data back and forth. But we can make it a lot easier by updating our ~/.ssh/config file to include something like:\nHost cluster\n HostName sms-ext.lis-lab.fr\n User &lt;&lt;username&gt;&gt;\nThen to login to the cluster, we just need to type:\nssh cluster\nAnd we should be prompted for our password."
  },
  {
    "objectID": "lecture-7-reveal.html#how-to-login-1",
    "href": "lecture-7-reveal.html#how-to-login-1",
    "title": "Linux & Supercomputer",
    "section": "How to login",
    "text": "How to login\nIf you trust the machine your on, you can remove password authentication and move to key-based authentication:\nssh-copy-id cluster\nWhen we next login to the server, we shouldn’t be prompted for a password."
  },
  {
    "objectID": "lecture-7-reveal.html#how-to-copy-files-to-and-from-the-cluster",
    "href": "lecture-7-reveal.html#how-to-copy-files-to-and-from-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "How to copy files to and from the cluster",
    "text": "How to copy files to and from the cluster\nWe have a number of options for transferring files to and from the cluster. Firstly, let’s look at the command scp. It takes two arguments, the first argument is the file you want to send, the second argument is the destination of the sent file.\nscp &lt;&lt;origin&gt;&gt; &lt;&lt;destination&gt;&gt;\nSimilar to commands like cp, scp by default only works for files, not folders. To send folders/directories, we use the -r flag just like cp.\nscp -r &lt;&lt;origin_folder&gt;&gt; &lt;&lt;destination_folder&gt;&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#copying-files-rsync",
    "href": "lecture-7-reveal.html#copying-files-rsync",
    "title": "Linux & Supercomputer",
    "section": "Copying files – rsync",
    "text": "Copying files – rsync\nOne of the downsides about scp is that it will copy every file you give it. Even if the file at the destination is exactly the same. What if we only want to copy files that need to be copied, i.e. that are outdated, thus saving time? For that, we can use rsync. Rsync will copy files from one source to a destination only if the destination needs to be updated. This can save a lot of time by skipping files that already exist at the destination:\nrsync &lt;&lt;source&gt;&gt; &lt;&lt;destination&gt;&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#the-login--and-compute-nodes",
    "href": "lecture-7-reveal.html#the-login--and-compute-nodes",
    "title": "Linux & Supercomputer",
    "section": "The Login- and Compute Nodes",
    "text": "The Login- and Compute Nodes\nWhen you login to the cluster, you are logging into the login node. Note that no computation should be run on this node. If you want to run scripts, you will have to submit a job to the compute nodes.\nOn the login node there is a system installed called ‘SLURM’. SLURM is a job scheduler program that receives your requests for executing scripts, it will queue them and assign them to available compute nodes.\nWe will take a look at how to request and manage jobs using the various commands that SLURM provides."
  },
  {
    "objectID": "lecture-7-reveal.html#how-to-launch-a-job-srun",
    "href": "lecture-7-reveal.html#how-to-launch-a-job-srun",
    "title": "Linux & Supercomputer",
    "section": "How to launch a job – srun",
    "text": "How to launch a job – srun\nThe first command we will look at it is srun. This command will run request a job for execution in ‘real-time’. By real-time, we mean that the shell will wait until the job has been submitted.\nsrun &lt;&lt;compute node options&gt;&gt; &lt;&lt;command to run&gt;&gt;\nLet’s take a look at an example where we want to run an interactive bash shell on the compute shell (similar to ssh’ing into the compute node).\nsrun --time=00:10:00 --pty bash -l\nThis will request a job on any available compute node for 10 minutes. When a node becomes available, bash will execute, dropping you into the shell. You will notice that the shell prompt has changed from sms to the name of the node."
  },
  {
    "objectID": "lecture-7-reveal.html#salloc",
    "href": "lecture-7-reveal.html#salloc",
    "title": "Linux & Supercomputer",
    "section": "salloc",
    "text": "salloc\nThere is another method we can use to create an interactive job. We could use the salloc command to allocate resources for a task. After the resources have been allocated and our job is ready, we can ssh into the node with the allocated resources.\nsalloc --time=10:00:00 &\nssh &lt;name&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#options",
    "href": "lecture-7-reveal.html#options",
    "title": "Linux & Supercomputer",
    "section": "options",
    "text": "options\nIn the previous command, we used the --time option to specify how long the job will run for. But there are other options we can use to be more specific about the jobs we want to run.\n--cpus-per-task can be used to request more than one CPU to be allocated. This is especially helpful when we have a multithreaded process we want to run.\n--mem specifies how much memory should be allocated to the job. For example: --mem=16G tells SLURM to allocate 16 GB of memory."
  },
  {
    "objectID": "lecture-7-reveal.html#gpu-allocation",
    "href": "lecture-7-reveal.html#gpu-allocation",
    "title": "Linux & Supercomputer",
    "section": "GPU allocation",
    "text": "GPU allocation\nIf we need to use a GPU, we need to use a few options. Firstly, we can specify that our job is on a compute node with GPU. There will usually be a group of nodes in a ‘GPU’ group or partition, and thus we can specify to use one of these partitions:\nsrun --time=00:10:00 --partiton=gpu --pty bash -l\nBut you will notice that you still do not have access to a GPU. You’re running on the GPU node, but you haven’t actually requested a GPU be allocated to your job. For that you will use --gres:\nsrun --time=00:10:00 --partition=gpu --gres=gpu:1 --pty bash -l\nHere we are requesting one GPU, but if we use --gres:gpu:2 we are requesting 2 GPUs etc.\nThere are many different types of GPUs available, some older than others. If you wanted to allocate a job with a specific type of GPU you can use the --constraint flag:\nsrun --time=00:10:00 \\\n --partition=gpu \\\n --gres=gpu:1 \\\n --constraint='cuda61' \\\n --pty bash -l\nThis command requests that our job run on the GPU partition, with 1 GPU allocated that has the capability of running CUDA compute 61.\nOr we can specify the type of GPU in the gres option:\nsrun --time=00:10:00 \\\n --partition=gpu \\\n --gres=gpu:2080:1 \\\n --pty bash -l"
  },
  {
    "objectID": "lecture-7-reveal.html#learning-more-about-nodes",
    "href": "lecture-7-reveal.html#learning-more-about-nodes",
    "title": "Linux & Supercomputer",
    "section": "Learning more about nodes",
    "text": "Learning more about nodes\nTo understand what each compute node has we can use the scontrol command.\nscontrol show nodes\nWill list out all nodes and all capabilities of each node. Or just one node:\nscontrol show node lisnode2"
  },
  {
    "objectID": "lecture-7-reveal.html#sbatch",
    "href": "lecture-7-reveal.html#sbatch",
    "title": "Linux & Supercomputer",
    "section": "sbatch",
    "text": "sbatch\nIt can be quite inconvenient to launch an interactive job to run some compute, and wait for the job to be allocated. If, instead, you have a long running experiment that you want to run without any intervention from you, you can use sbatch.\nSbatch will require us to write a small bash script that specifies how to run a job and what to do once its allocated.\n#!/bin/bash\n\n#SBATCH --time=00:01:00\n#SBATCH --job-name=my_new_job\n#SBATCH --output=my_new_job.out\n#SBATCH --error=my_new_job.err\n\necho $HOSTNAME\nAnd run it:\nsbatch my_job.sh\nNotice that instead of supplying options to sbatch, we can instead record them directly into the script using the #SBATCH. SLURM will examine this file, looking for lines starting with this comment, and infer that the rest of the line contains the options.\nThere are a few other options we’ve included that are very useful when running non-interactive jobs. Firstly, we’ve given the job a name (my_new_job). This is so we can different between many jobs that we might run at the same time. To list out the jobs we currently have running we use squeue.\nsqueue\nBy default, squeue will list all of the active jobs, even other peoples. To specify only your jobs user the --user option:\nsqueue --user=jay.morgan\nThe other two options, --output and --error specify where the printed output and printed errors will be stored. Since the job is being run on a different node, by a non-interactive process, if you didn’t include these lines, you wouldn’t be able to see what was being printed by echo or by any other process such as print in Python."
  },
  {
    "objectID": "lecture-7-reveal.html#squeue",
    "href": "lecture-7-reveal.html#squeue",
    "title": "Linux & Supercomputer",
    "section": "squeue",
    "text": "squeue\nWhen we list the jobs using squeue it will give us multiple columns of information, such as:\n\nJOBID – the referable id of the job.\nPARTITION – the partition on which the job has been requested for.\nNAME – the name of the job.\nUSER – the user who submitted the job.\nST – the status, is the job currently running, waiting, or exiting?\nTIME – how long the job has been running for.\nNODES – how many nodes have been allocated to the job."
  },
  {
    "objectID": "lecture-7-reveal.html#scontrol",
    "href": "lecture-7-reveal.html#scontrol",
    "title": "Linux & Supercomputer",
    "section": "scontrol",
    "text": "scontrol\nscontrol allows us to modify an existing job. For example, let us say that we have a job which we need to extend the time limit. Given that we know the job id (we could use squeue to find this), we can ask SLURM to update the time limit using:\nscontrol update jobid=&lt;job_id&gt; TimeLimit=&lt;new_timelimit&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#scancel",
    "href": "lecture-7-reveal.html#scancel",
    "title": "Linux & Supercomputer",
    "section": "scancel",
    "text": "scancel\nLet’s say that we’ve submitted a job, but we’ve noticed that there was an error in the code, and want to stop the job. For that, we use scancel and specify the id of the job we wish to cancel:\nscancel 158590\nAfter running this command, we should see, using squeue, that either the job is finishing, or that its disappeared from our list (meaning that its completely stopped)."
  },
  {
    "objectID": "lecture-7-reveal.html#sacct",
    "href": "lecture-7-reveal.html#sacct",
    "title": "Linux & Supercomputer",
    "section": "sacct",
    "text": "sacct\nIf our job has finished, or exited and is no longer in squeue, we can use sacct to get a history of the jobs.\nsacct will list all of your jobs within some default window of time. If we want to change this window we can use the --starttime and --endtime options.\nValid time formats are:\n\nHH:MM[:SS][AM|PM]\nMMDD[YY][-HH:MM[:SS]]\nMM.DD[.YY][-HH:MM[:SS]]\nMM/DD[/YY][-HH:MM[:SS]]\nYYYY-MM-DD[THH:MM[:SS]]\ntoday, midnight, noon, fika (3 PM), teatime (4 PM)\nnow[{+|-}count[seconds(default)|minutes|hours|days|weeks]]"
  },
  {
    "objectID": "lecture-7-reveal.html#job-task-arrays-motivation",
    "href": "lecture-7-reveal.html#job-task-arrays-motivation",
    "title": "Linux & Supercomputer",
    "section": "Job Task Arrays – motivation",
    "text": "Job Task Arrays – motivation\nTask arrays allow you to submit many jobs of the same type. Why might this be useful? Suppose you have a list of files that take a long time to process:\n\nfile_0.txt\nfile_1.txt\nfile_2.txt\n\nOr you have some computation script, such as deep learning training script, that takes uses a hyperparameter which can be tuned to achieve different performance results:\npython train.py --learning-rate 0.001\nInstead of a creating a sbatch script for each value of hyperparameter, or sequentially enumerating the values, you can use a job task array to spawn multiple jobs with slightly different values."
  },
  {
    "objectID": "lecture-7-reveal.html#job-task-arrays-how-to",
    "href": "lecture-7-reveal.html#job-task-arrays-how-to",
    "title": "Linux & Supercomputer",
    "section": "Job Task Arrays – how to",
    "text": "Job Task Arrays – how to\nFirst, we will look at how to actually submit an array of tasks. To create an task array, you will need to add the --array options to your sbatch script:\n#!/bin/bash\n\n#SBATCH --job-name=my_task_array\n#SBATCH --array=1-5\n\n...\nHere we are creating an array of tasks numbered from 1-5. When you submit this script, you will see five tasks submitted to the queue.\nNow that we know how to create an array of tasks, we will want to do something useful with it. When you create an array, each individual task will have a unique variable called SLURM_ARRAY_TASK_ID. So for example, if we launch an array of 5 tasks, the first task will have the value 1. Why is this useful? Well, we can use this variable to alter the program slightly. Take for example our list of files we need to process:\n#!/bin/bash\n#SBATCH --job-name=my_task_array\n#SBATCH --array=0-4\n#SBATCH --time=00:10:00\n\nFILENAME=\"file_${SLURM_ARRAY_TASK_ID}.txt\"\npython process.py $FILENAME\nThis will create a new bash variable called FILENAME by concatenating file_ the current task’s (i.e. 0, for the first task, 1 for the second task, etc) and .txt.\nIf we run the previous example, we will see that we have five jobs named exactly the same thing my_task_array. This is okay, but we can be a little bit more clear as to which task is running, i.e. which task is processing which file?\nWe can use some special variables in our bash script to make this more clear. These are %A that is the main job id, and %a that is the task array id.\n#!/bin/bash\n\n#SBATCH --error=my_task_array.%A_%a.out\n#SBATCH --output=my_task_array.%A_%a.out\n...\nNow, every task in our array will have a slightly different name because of the %a and therefore we will be able to determine which job is processing which file.\nLet’s move on to the second example, where we have a Deep Learning training program and we want to try different parameters. In this case, we can again use a task array.\n#!/bin/bash\n\n#SBATCH --array=1-10\nWe could either pass the SLURM_ARRAY_TASK_ID as a command line argument to the script:\npython training.py --learning-rate $SLURM_ARRAY_TASK_ID\nBut in this case, we could have to properly calculate the correct learning rate from the SLURM_ARRAY_TASK_ID value (remember that in my sbatch script I set --array=1-5). But bash only performs integer arithmetic, therefore we will need to calculate the correct learning rate in something else.\nInstead of passing the learning rate via a command line argument. We can get the value directly from our python script and calculate the value.\nimport os\n\ntask_id = int(os.environ[\"SLURM_ARRAY_TASK_ID\"])\nlearning_rate = task_id / 100\nHere we are using the builtin os module in Python, getting the environment variable from the dictionary environ and parsing the value as an integer. Then we can calculate the appropriate learning rate using this value. So for example, if SLURM_ARRAY_TASK_ID is set to 1. Our learning rate would be 0.01 for this task.\nIf you’re creating a job task array, you may want to create hundreds of jobs. And of course, you don’t want to use up the entire cluster leaving no resources for anybody else! Therefore, you will only want a maximum number of tasks to run at any one time.\n#!/bin/bash\n\n#SBATCH --array=1-100%5\nThis will create a job task array of 100 jobs numbered from 1 to 100. But we have added an additional argument %5 which means that only 5 jobs can run at any one time for this task array. If you have five tasks running, the other 95 tasks will wait.\nIf, at any point, you want to change how many jobs can run simultaineously, you can update this ‘throttle’ value using scontrol:\nscontrol update ArrayTaskThrottle=&lt;count&gt; JobId=&lt;jobID&gt;\nSo if we’ve already launched a job task array with the job id of 50602 that has a throttle value of 5 (only 5 tasks will run at once), we can change it to 10 using:\nscontrol update ArrayTaskThrottle=10 JobId=50602"
  },
  {
    "objectID": "lecture-7-reveal.html#a-guided-walk-through-environment",
    "href": "lecture-7-reveal.html#a-guided-walk-through-environment",
    "title": "Linux & Supercomputer",
    "section": "A guided walk through – environment",
    "text": "A guided walk through – environment\nIn this section we’re going to give an example walk through of working with the HPC cluster. In this example, we’re going to write our scripts locally, including the slurm submission script, and when they’re ready, we’ll send them to the cluster to perform the actual computation.\nLet’s imagine we’re starting a new project, and are programming our scripts in Python. Now is a good time to create a new conda environment to install our packages we’re going to use for our research. We’ll create this environment with (replacing &lt;env-name&gt; with whatever we want to call this environment):\nconda create --name &lt;env-name&gt;\nand then activate it:\nconda activate &lt;env-name&gt;\nconda install python=3.9"
  },
  {
    "objectID": "lecture-7-reveal.html#writing-our-scripts",
    "href": "lecture-7-reveal.html#writing-our-scripts",
    "title": "Linux & Supercomputer",
    "section": "Writing our scripts",
    "text": "Writing our scripts\nLet us also image we’ve just wrote the following script to create a lorenz attractor: lorenz.py\nThe specific implementation of this script is not particularly important for this walk through. Just know that we’re importing a few packages such as numpy and matplotlib. Then, we’re performing some computation, and saving the results to analyse later. As this script uses external libraries, we need to install them:\nconda install numpy matplotlib"
  },
  {
    "objectID": "lecture-7-reveal.html#writing-our-job-submission-script",
    "href": "lecture-7-reveal.html#writing-our-job-submission-script",
    "title": "Linux & Supercomputer",
    "section": "Writing our job submission script",
    "text": "Writing our job submission script\nSince we want our calculations to be performed on the cluster, we will need to also write a job submission script (let’s call this submit-job.sh) in bash to pass to SLURM.\n#!/bin/bash\n\n#SBATCH --job-name=lorenz_attractor\n#SBATCH --output=lorenz_attractor.log\n#SBATCH --error=lorenz_attractor.log\n#SBATCH --time=00:10:00\n\npython lorenz.py"
  },
  {
    "objectID": "lecture-7-reveal.html#replicating-our-environment-on-the-cluster",
    "href": "lecture-7-reveal.html#replicating-our-environment-on-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Replicating our environment on the cluster",
    "text": "Replicating our environment on the cluster\nAs we’ve installed external packages in our local development environment, we will want to ensure that when we run the calculations on the cluster, it will be using the same versions of packages. Conda makes this a lot easier. First, we export our environment to a recipe file:\nconda env export --no-builds &gt; environment.yml"
  },
  {
    "objectID": "lecture-7-reveal.html#sending-our-scripts-to-the-cluster",
    "href": "lecture-7-reveal.html#sending-our-scripts-to-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Sending our scripts to the cluster",
    "text": "Sending our scripts to the cluster\nAll of our scripts are ready! We can now transfer them from our personal computer, to the cluster. The files we need to transfer are:\n\nlorenz.py\nenvironment.yml\nsubmit-job.sh\n\nWhile we can send a folder (and the containing files), let’s send them one at a time:\nscp lorenz.py &lt;hostname&gt;:&lt;destination-path&gt;\nscp environment.yml &lt;hostname&gt;:&lt;destination-path&gt;\nscp submit-job.sh &lt;hostname&gt;:&lt;destination-path&gt;\nwhere &lt;hostname&gt; is the hostname/IP address that you’ve used to connect to the login node on the cluster before. &lt;destination-path&gt; is the path to where you want to save the files."
  },
  {
    "objectID": "lecture-7-reveal.html#logging-into-the-cluster",
    "href": "lecture-7-reveal.html#logging-into-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Logging into the cluster",
    "text": "Logging into the cluster\nNow that our files are on the cluster, we can login:\nssh &lt;username&gt;@&lt;hostname&gt;\nAt which point, we’ve logged into the login node, and then we need to change directory to where we saved the files:\ncd &lt;destination-path&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#re-creating-our-development-environment",
    "href": "lecture-7-reveal.html#re-creating-our-development-environment",
    "title": "Linux & Supercomputer",
    "section": "Re-creating our development environment",
    "text": "Re-creating our development environment\nNow that we’re in the same folder as our scripts, we’re almost ready to submit our job. First, we need to recreate our development environment from our environment.yml file.\nconda env create -f environment.yml\nAnd activate our newly created environment:\nconda activate &lt;env-name&gt;"
  },
  {
    "objectID": "lecture-7-reveal.html#submitting-our-job",
    "href": "lecture-7-reveal.html#submitting-our-job",
    "title": "Linux & Supercomputer",
    "section": "Submitting our job",
    "text": "Submitting our job\nNow we can submit our job:\nsbatch submit-job.sh\nWe can check the progress of our job with squeue, or its already completed, look at the job history with sacct."
  },
  {
    "objectID": "lecture-7-reveal.html#downloading-the-results",
    "href": "lecture-7-reveal.html#downloading-the-results",
    "title": "Linux & Supercomputer",
    "section": "Downloading the results",
    "text": "Downloading the results\nIf our job runs successfully, a data.pkl file will be created. Back on our local computers, we will need to run the following to download it:\nscp &lt;hostname&gt;:&lt;destination-path&gt;/data.pkl ./\nThis will download the file into the current directory."
  },
  {
    "objectID": "lecture-7-reveal.html#analysing-the-results",
    "href": "lecture-7-reveal.html#analysing-the-results",
    "title": "Linux & Supercomputer",
    "section": "Analysing the results",
    "text": "Analysing the results\nWith the data.pkl file downloaded, we can visualise the results using plot_lorenz.py: https://pageperso.lis-lab.fr/jay.morgan/resources/2021-programming-level-up/lectures/week-5/plot-lorenz.py\nIf everything has been run correctly, you should see a plot of the lorenz attractor."
  },
  {
    "objectID": "lecture-7-reveal.html#useful-features-x11-forwarding",
    "href": "lecture-7-reveal.html#useful-features-x11-forwarding",
    "title": "Linux & Supercomputer",
    "section": "Useful features – X11 Forwarding",
    "text": "Useful features – X11 Forwarding\nIf we’re performing analysis interactively using the cluster, we’ll often want to visualise the results, using matplotlib for example. To see our plots display like they would on our local machine when we call plt.plot or plt.show(), we will need to ensure that we’re using something called X11 Forwarding. To enable X11 Forwarding, we use the -X option when ssh‘ing into the cluster and compute nodes (i.e. it will need to be enabled on every ’hop’ so to speak).\nssh -X &lt;&lt;remote-host&gt;&gt;\nIf want to enable it by default, we can enable it in our ssh config file:\nHost cluster\n HostName sms-ext.lis-lab.fr\n FowardX11 yes\n User &lt;&lt;username&gt;&gt;\nAfter setting up X11 Forwarding correctly, and when logged into the remote host, we should be able to echo a variable called $DISPLAY.\necho $DISPLAY\nIf $DISPLAY has a value, we know that X11 Forwarding has been setup correctly, and we’re ready to do some plotting!"
  },
  {
    "objectID": "lecture-7-reveal.html#useful-features-jupyter-notebooks",
    "href": "lecture-7-reveal.html#useful-features-jupyter-notebooks",
    "title": "Linux & Supercomputer",
    "section": "Useful features – Jupyter Notebooks",
    "text": "Useful features – Jupyter Notebooks\nWe’ve talked about how good jupyter notebooks are for performing analysis and exploration. But often times, we will need a lot of compute resources (more than our local computers can handle) to do this analysis. This is where using jupyter notebook on the supercomputers comes in handy. However, it is not as simple as starting the jupyter notebook server and opening up your web browser. First, we will need to setup a ‘reverse ssh tunnel’.\nIn a nut-shell, a reverse ssh tunnel allows you to redirect data on a remote port to a local port.\nTherefore, we can, using a reverse ssh tunnel, start a jupyter notebook on the supercomputer and access it using the web browser on our local computer!\nTo begin, we can create an interactive job on the cluster:\nsrun --time=01:00:00 --pty bash -l\nAnd start our jupyter notebook, specifying a port that will not be in use:\njupyter notebook --port 30333\nWith our notebook server now started on the 30333 port, we will want to create an ssh tunnel from our local computer, to the cluster’s login node, and then a tunnel from the login node to the specific compute node where the job is running:\nssh -L 30333:localhost:30333 &lt;&lt;cluster-login-node&gt;&gt; ssh -L 30333:localhost:30333 &lt;&lt;cluster-compute-node&gt;&gt;\nIf everything goes well, we should now be able to open up our web browser, navigate to localhost:30333 and see our jupyter notebooks."
  },
  {
    "objectID": "lecture-7.html",
    "href": "lecture-7.html",
    "title": "Linux & Supercomputer",
    "section": "",
    "text": "Linux is a popular operating system (OS) like Windows, or MacOS.\nUnlike these other two OSs, Linux is open source, which means the source code is freely available to look at and modify.\nAs its open source, its very possible for anyone to build their own version of Linux or build on top of Linux to create their own Distribution of Linux.\n\n\n\n\nA distribution can be considered like a flavour or version of Linux. There are many popular flavours that attempt to meet different needs from different users. For example:\n\nUbuntu – typically the first Linux experience people will have. Attempts to be very user friendly.\nFedora – stable and secure distribution while also providing up-to-date packages.\nArch Linux – strong focus on customisability rather than user friendliness with bleeding edge packages.\n\n\n\n\n\nWhile we have said that Linux is open source, there are many other traits that make it stand out from other operating systems:\n\nComplete control of how the system operates.\nThe level of flexibility and automation that you can get from using the Linux command line.\n\nWhile there are many other traits, these two are going to be what we’re going to focus on."
  },
  {
    "objectID": "lecture-7.html#what-is-linux",
    "href": "lecture-7.html#what-is-linux",
    "title": "Linux & Supercomputer",
    "section": "",
    "text": "Linux is a popular operating system (OS) like Windows, or MacOS.\nUnlike these other two OSs, Linux is open source, which means the source code is freely available to look at and modify.\nAs its open source, its very possible for anyone to build their own version of Linux or build on top of Linux to create their own Distribution of Linux."
  },
  {
    "objectID": "lecture-7.html#whats-a-distribution",
    "href": "lecture-7.html#whats-a-distribution",
    "title": "Linux & Supercomputer",
    "section": "",
    "text": "A distribution can be considered like a flavour or version of Linux. There are many popular flavours that attempt to meet different needs from different users. For example:\n\nUbuntu – typically the first Linux experience people will have. Attempts to be very user friendly.\nFedora – stable and secure distribution while also providing up-to-date packages.\nArch Linux – strong focus on customisability rather than user friendliness with bleeding edge packages."
  },
  {
    "objectID": "lecture-7.html#defining-traits-of-linux",
    "href": "lecture-7.html#defining-traits-of-linux",
    "title": "Linux & Supercomputer",
    "section": "",
    "text": "While we have said that Linux is open source, there are many other traits that make it stand out from other operating systems:\n\nComplete control of how the system operates.\nThe level of flexibility and automation that you can get from using the Linux command line.\n\nWhile there are many other traits, these two are going to be what we’re going to focus on."
  },
  {
    "objectID": "lecture-7.html#whats-a-command",
    "href": "lecture-7.html#whats-a-command",
    "title": "Linux & Supercomputer",
    "section": "What’s a command?",
    "text": "What’s a command?\nWhile many recent versions of Linux makes things more accessible via GUIs, they will never be a substitute for using the command line. We’re going to learn how to control the system via the command line, via a shell. A shell, like the Python REPL we’ve already seen, is waits for you to input commands, executes the command, and prints the output if there is output to print.\nA Linux command is a call to a program optionally followed by some arguments. For example, if we want list out the files and folders in the directory, we would use the ls (list) command:\nls\nThe ls command comes with a number of optional flags and arguments that we can add onto the call. When calling a command a flag is something that begins with a - , for example -l tells ls to list the directory in a list format.\nls -l\nWe have supplied the -l flag. There are many other flags for ls, like for example, the human readable file systems with -h or show hidden files (files that start with a period) with -a.\nWhen we’re using multiple flags we could write\nls -l -h -a\nOr:\nls -lha\nSometimes commands take optional positional arguments. Going back to our list directory command, where, by default, it will list the current directory. But instead we can tell the command to list a particular directory by supplying the path as an argument\nls images/ -lha\n# or ls -lha images/ works too\nHow do I know how to use a command? Well that’s where another command comes in. It’s called man (short for manual). If you pass another command to the man command, the documentation will be shown in the terminal, e.g.:\nman ls  # display the documentation for ls\nThe documentation should list all the different flags and arguments, describe what they mean, and sometimes give example or most common usage of a command.\nWhen the ‘man page’ is display, you can scroll up and down the page using your arrow keys, and page-up and page-down. When you’re done reading, just hit the ‘q’ character\nI am going to go through some of the most common commands just to make sure that you’re familiar with the typical usage."
  },
  {
    "objectID": "lecture-7.html#cd",
    "href": "lecture-7.html#cd",
    "title": "Linux & Supercomputer",
    "section": "cd",
    "text": "cd\nWe’ve already seen ls to list a directory. The command to move to a directory is cd (change directory), that takes an argument of filepath to move to:\ncd ~ # tilde is short-hand for the 'home directory'\ncd ~/Documents/My\\ Files  # go to Documents and then to \"My Files\"\ncd   # no argument, by default goes to the home directory"
  },
  {
    "objectID": "lecture-7.html#mkdir",
    "href": "lecture-7.html#mkdir",
    "title": "Linux & Supercomputer",
    "section": "mkdir",
    "text": "mkdir\nSticking with the them of directories, to make a new directory we use mkdir, whose argument takes the name of the directory we want to create:\nmkdir my_new_directory\nYou can create a many level nested directory structure all at once using the -p (parents) flag, that tells mkdir if the parent directory of the target directory doesn’t exist, create it.\nmkdir photos/2020/01/05  # won't work unless photos/2020/01 exist\nmkdir -p photos/2020/01/05  # this will work"
  },
  {
    "objectID": "lecture-7.html#cp",
    "href": "lecture-7.html#cp",
    "title": "Linux & Supercomputer",
    "section": "cp",
    "text": "cp\nTo copy a file or directory, we can use the cp command. Here we are copying a file, where the first argument is the filepath of the file you want to copy and the second argument is the filepath where the copy should be placed.\ncp my_old_file my_new_file\nBy default (without a flag), cp will not work with directories, for that you have to use the -r (recursive) flag\ncp -r data/ data-backup"
  },
  {
    "objectID": "lecture-7.html#mv",
    "href": "lecture-7.html#mv",
    "title": "Linux & Supercomputer",
    "section": "mv",
    "text": "mv\nThe syntax of moving a file is similar to that of cp:\nmv old_file new_file\nExcept that it works for both files and directories without any flags. mv can also be used to rename files, that’s all renaming is: moving a file to the same directory under a different name."
  },
  {
    "objectID": "lecture-7.html#rm",
    "href": "lecture-7.html#rm",
    "title": "Linux & Supercomputer",
    "section": "rm",
    "text": "rm\nTo remove a file us rm:\nrm file_to_delete\nIf you want to delete a directory, use the -r (recursive) flag:\nrm -r directory_to_delete/"
  },
  {
    "objectID": "lecture-7.html#cat",
    "href": "lecture-7.html#cat",
    "title": "Linux & Supercomputer",
    "section": "cat",
    "text": "cat\ncat stands for concatenate, i.e. concatenating the contents of two or more files:\ncat file1 file2\nThe result is that the concatenation of these two files will be printed to the screen. If you wanted to put the result into its own file you would redirect the output using &gt;\ncat file1 file2 &gt; newfile\nSince cat reads the file and prints it to screen it is a very handy way to view the contents of a file, even if it was not intended for that."
  },
  {
    "objectID": "lecture-7.html#pwd",
    "href": "lecture-7.html#pwd",
    "title": "Linux & Supercomputer",
    "section": "pwd",
    "text": "pwd\nSometimes you may get lost when moving directories. pwd prints the current working directory from the root directory, i.e. the path that is printed is an absolute path.\npwd"
  },
  {
    "objectID": "lecture-7.html#find",
    "href": "lecture-7.html#find",
    "title": "Linux & Supercomputer",
    "section": "find",
    "text": "find\nIf we want to list all files of a certain type, we can use the wildcard * that we’ve seen before:\nls *.jpg # list all files that end with .jpg\nHowever, this will only list for the current directory. Perhaps the better way to find files will be using the find command:\nfind . -type f -name *.jpg\nThe first argument is the directory to start the search, then we define the type f being files, and then specify the name. Find will recursively search through directories and sub-directories to find all files that match that name."
  },
  {
    "objectID": "lecture-7.html#grep",
    "href": "lecture-7.html#grep",
    "title": "Linux & Supercomputer",
    "section": "grep",
    "text": "grep\nHow about if we want to find files that have a certain contents? For that we can use grep. Grep will read a file and print (by default) the lines that contains your pattern. i.e.:\ngrep 'Linux' lecture.org\nThis will print the lines that contain the word Linux in lecture.org. If we just want the matched value, we use the -o flag.\ngrep -o '[0-9]' lecture.org\nThis prints all occurrences of numbers in lecture.org"
  },
  {
    "objectID": "lecture-7.html#lessheadtail",
    "href": "lecture-7.html#lessheadtail",
    "title": "Linux & Supercomputer",
    "section": "less/head/tail",
    "text": "less/head/tail\nIf a file is very long, we may not want to read the file using cat, as it will have to print the entire file. Instead we could use less, which will allow us to navigate through the file, using arrow keys to move and q to quit.\nless filename\nIf we just want to view the first few lines, or the last few lines of a file we can use head/tail, respectively:\nhead filename\ntail -n 20 filename  # last 20 lines\ntail -F filename # constantly read the file"
  },
  {
    "objectID": "lecture-7.html#wc",
    "href": "lecture-7.html#wc",
    "title": "Linux & Supercomputer",
    "section": "wc",
    "text": "wc\nOften times we just want to count the number of something. For example, if we want to count the number of files/folders in the directory we can do:\nls -l | wc -l\nWe’re first printing all files and folders in a list format (one per line), then passing (piping_) the result to wc, which with the -l line flag, is counting the number of lines. Therefore we get a count of the number of files and folders. Here is another example where we’re counting how many times the word bash appears in these lecture notes:\ngrep -o 'bash' lecture.org | wc -l"
  },
  {
    "objectID": "lecture-7.html#piping",
    "href": "lecture-7.html#piping",
    "title": "Linux & Supercomputer",
    "section": "piping",
    "text": "piping\nThe purpose of piping is to pass data around between commands. We have just seen how we can pass the output of, say, the ls command to the input of wc. This allows use to construct very sophisticated pipelines to do some quite complex things from the combination of very simple commands.\nfind . -name '*.txt' -type f -print0 | xargs -0 grep \"something\""
  },
  {
    "objectID": "lecture-7.html#overview",
    "href": "lecture-7.html#overview",
    "title": "Linux & Supercomputer",
    "section": "Overview",
    "text": "Overview\nIn summary we have seen the following commands:\n\nls - List a directory\ncd - Change/move to a directory\nmkdir - Make a new directory\ncat - Concatenate files\ncp - Copy a file/directory\nmv - Move files/folders\nrm - Remove files and folders\npwd - Display the current absolute path\nfind - Find files\ngrep - Find occurrences of a pattern in a file\nless/head/tail - Read a file\nwc - Count"
  },
  {
    "objectID": "lecture-7.html#your-very-first-bash-script",
    "href": "lecture-7.html#your-very-first-bash-script",
    "title": "Linux & Supercomputer",
    "section": "Your Very first bash script",
    "text": "Your Very first bash script\nLet’s start with the classic ‘Hello, World’ example. We’ll create a new file called ‘hello.sh’ and enter the following:\n#!/bin/bash\n\necho \"Hello, World!\"\nFirst thing to notice is that the first line contains what we call a ‘shebang’ or ‘hashbang’. It tells Linux which shell interpreter will be used to run the script, in this case: /bin/bash\nThe next (non-empty) line in the file is echo 'Hello, World'. This is exactly the same as the other commands we’ve just seen.\nNow that we’ve created and saved our bash script, we will want to run it. We have two alternative methods to run this script:\nbash hello.sh  # run the script via bash\nThe second, requires that we have executable privileges for the script:\nchmod +x hello.sh  # add executable 'x' privileges\n./hello.sh  # execute it"
  },
  {
    "objectID": "lecture-7.html#variables",
    "href": "lecture-7.html#variables",
    "title": "Linux & Supercomputer",
    "section": "Variables",
    "text": "Variables\nThe variables we create in our bash scripts are very much the same as the environment variables we’ve seen before. Take for example:\n#!/bin/bash\nAGE=\"35\"\nPERSON_NAME=\"Jane\"\necho \"$PERSON_NAME is $AGE years old\"\nWe create a variable AGE with the = assignment operator. Note we don’t put spaces either side of the equals sign in bash. To refer to the variable, we use $AGE, using the $ dollar sign."
  },
  {
    "objectID": "lecture-7.html#interpolation-in-bash-strings",
    "href": "lecture-7.html#interpolation-in-bash-strings",
    "title": "Linux & Supercomputer",
    "section": "Interpolation in bash strings",
    "text": "Interpolation in bash strings\nYou would have noticed in the previous example that we included the variable directly into the string we’re echoing out. This is something similar to what we’ve seen with f-strings in Python.\nWhen we use double quotes: \"...\" in bash, the variable will be integrated into the resulting string. We can even call bash functions from directly inside the string:\necho \"I am logging in as: $(who)\""
  },
  {
    "objectID": "lecture-7.html#bash-strings-the-sharp-edges",
    "href": "lecture-7.html#bash-strings-the-sharp-edges",
    "title": "Linux & Supercomputer",
    "section": "Bash strings – the sharp edges",
    "text": "Bash strings – the sharp edges\nYou might be tempted to use a variable when generating a path:\nTRAIN_PROCESS=\"training\"\nTEST_PROCESS=\"testing\"\n\ntouch \"./data/$TRAIN_PROCESS_error.txt\"\ntouch \"./data/$TEST_PROCESS_error.txt\nBut this will create an error as underscores can be part of the variable name, so bash will be looking for a variable named: $TRAIN_PROCESS_error which has never been created. To get around this, we can wrap our variable in curly braces:\ntouch \"./data/${TRAIN_PROCESS}_error.txt\""
  },
  {
    "objectID": "lecture-7.html#stopping-interpolation-in-bash-strings",
    "href": "lecture-7.html#stopping-interpolation-in-bash-strings",
    "title": "Linux & Supercomputer",
    "section": "Stopping interpolation in bash strings",
    "text": "Stopping interpolation in bash strings\nWe can also use single quotes for strings in bash. When we use these strings, the string itself is not interpreted, and thus it will ignore any variables or bash commands:\necho 'I am logging in as: $(who)'"
  },
  {
    "objectID": "lecture-7.html#inputoutput",
    "href": "lecture-7.html#inputoutput",
    "title": "Linux & Supercomputer",
    "section": "Input/Output",
    "text": "Input/Output\nIf we want to read the input from keyboard into a variable, we use the read command:\n#!/bin/bash\n\necho \"Enter your name:\"\nread NAME\n\necho \"Hello, $NAME\"\nread in this context will read in the input and create the variable with that value. As we’ve already seen, we can then output this value to the console using the echo command."
  },
  {
    "objectID": "lecture-7.html#booleans",
    "href": "lecture-7.html#booleans",
    "title": "Linux & Supercomputer",
    "section": "Booleans",
    "text": "Booleans\nTechnically, bash does not have built in data types for true and false, but Linux has the commands true and false which we could use in place. The implementation of how these commands work is not important.\nFILE_EXISTS=true\n\nif [ \"$FILE_EXISTS\" = true ]; then\necho \"The file exists!\"\nfi"
  },
  {
    "objectID": "lecture-7.html#conditionals",
    "href": "lecture-7.html#conditionals",
    "title": "Linux & Supercomputer",
    "section": "Conditionals",
    "text": "Conditionals\nWhen we’re creating if expressions, we use the following syntax:\nif &lt;&lt;conditional&gt;&gt;; then\n   # do something\nelse\n   # do something else\nfi\nWe can also use elif\nif &lt;&lt;conditional&gt;&gt;; then\n   # do something\nelif &lt;&lt;conditional&gt;&gt;; then\n   # do something else\nelse\n   # something else entirely\nfi\nWriting condition expressions can be a little more cumbersome than in Python. These can be many pain points for new bash programmers, take for example:\nFILE_EXISTS=false\n\nif [ $FILE_EXISTS ]; then\necho \"The file exists!\"\nfi\nThis is because we have used the [...] single bracket syntax for the test. But there are others:\n\nNo brackets: we could omit the brackets in which case it would run the false command not print the statement.\nSingle paranthesis (...) creates a sub-shell.\nDouble paranthesis ((...)) for arithmetic operation\nSingle square bracket [...] calls test\nDouble square bracket [[...]]\n\nWhat if we write:\nVAR_1=\"Mr Foo Bar\"\nVAR_2=\"Mr Foo Bar\"\nif [ $VAR_1 = $VAR_2 ]; then\necho \"They are the same\"\nfi\nWe would get an error because test expands the arguments into:\nMr Foo Bar = Mr Foo Bar\nWith the spaces included. To prevent this from happening, we have to wrap the variables in quotation marks.\nVAR_1=\"Mr Foo Bar\"\nVAR_2=\"Mr Foo Bar\"\nif [ \"$VAR_1\" = \"$VAR_2\" ]; then\necho \"They are the same\"\nfi\nIf we use [[ in if statement, then we can do more sophisticated things like pattern matching:\nFILENAME=\"testing.png\"\nif [[ \"$FILENAME\" = *.png ]]; then\necho \"Its a png file\"\nfi"
  },
  {
    "objectID": "lecture-7.html#loops",
    "href": "lecture-7.html#loops",
    "title": "Linux & Supercomputer",
    "section": "Loops",
    "text": "Loops\nLike in Python, we can iterate in bash\nfor i in {1..10}; do\necho $i\ndone\nThis iterates with i starting at 1 upto 10 (inclusive). Or we could do:\nfor (( i=1; i &lt;= 10; i++ )); do\necho $i\ndone\nWe can also iterate over a list of files/folders in a directory:\nfor FILE in ./images/*; do\necho $FILE\ndone\nUsing the while form, we can continue looping until our conditional is false. For example, we could loop testing our internet connection, until its been established:\nwhile ! ping -c 1 google.com; do\necho \"No internet yet\"\nsleep 1\ndone\n\necho \"Internet is available!\""
  },
  {
    "objectID": "lecture-7.html#functions",
    "href": "lecture-7.html#functions",
    "title": "Linux & Supercomputer",
    "section": "Functions",
    "text": "Functions\nTo create a function, we use the following syntax:\nfunction_name() {\n# do something\n}\nAnd to call the function, you just need to use the function name:\nfunction_name # this called function name\nHere is another example:\nsay_hello() {\necho \"Hello, $1\"\n}\n\nsay_hello \"Jane\"\nNotice that we didn’t need to include any argument list. We just used $1 for the first argument passed to the function.\nsay_hello() {\necho \"$1, $2\"\n}\n\nsay_hello \"Hi\" \"Jane\"\nReturning values is ‘interesting’ as, coming from other languages, you think could do something like this:\nsay_hello() {\nreturn \"hello\"\n}\nRESULT=\"$(say_hello)\"\necho $RESULT\nThis didn’t work like we expected, the value wasn’t returned and assigned to RESULT. So how do we return a value?\nsay_hello() {\necho \"Hello\"\n}\nRESULT=\"$(say_hello)\"\necho \"This is before the printing of result\"\necho $RESULT"
  },
  {
    "objectID": "lecture-7.html#how-to-login",
    "href": "lecture-7.html#how-to-login",
    "title": "Linux & Supercomputer",
    "section": "How to login",
    "text": "How to login\nssh &lt;&lt;username&gt;&gt;@sms-ext.lis-lab.fr\nTyping this command can become tiresome very quickly, especially after sending data back and forth. But we can make it a lot easier by updating our ~/.ssh/config file to include something like:\nHost cluster\n HostName sms-ext.lis-lab.fr\n User &lt;&lt;username&gt;&gt;\nThen to login to the cluster, we just need to type:\nssh cluster\nAnd we should be prompted for our password."
  },
  {
    "objectID": "lecture-7.html#how-to-login-1",
    "href": "lecture-7.html#how-to-login-1",
    "title": "Linux & Supercomputer",
    "section": "How to login",
    "text": "How to login\nIf you trust the machine your on, you can remove password authentication and move to key-based authentication:\nssh-copy-id cluster\nWhen we next login to the server, we shouldn’t be prompted for a password."
  },
  {
    "objectID": "lecture-7.html#how-to-copy-files-to-and-from-the-cluster",
    "href": "lecture-7.html#how-to-copy-files-to-and-from-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "How to copy files to and from the cluster",
    "text": "How to copy files to and from the cluster\nWe have a number of options for transferring files to and from the cluster. Firstly, let’s look at the command scp. It takes two arguments, the first argument is the file you want to send, the second argument is the destination of the sent file.\nscp &lt;&lt;origin&gt;&gt; &lt;&lt;destination&gt;&gt;\nSimilar to commands like cp, scp by default only works for files, not folders. To send folders/directories, we use the -r flag just like cp.\nscp -r &lt;&lt;origin_folder&gt;&gt; &lt;&lt;destination_folder&gt;&gt;"
  },
  {
    "objectID": "lecture-7.html#copying-files-rsync",
    "href": "lecture-7.html#copying-files-rsync",
    "title": "Linux & Supercomputer",
    "section": "Copying files – rsync",
    "text": "Copying files – rsync\nOne of the downsides about scp is that it will copy every file you give it. Even if the file at the destination is exactly the same. What if we only want to copy files that need to be copied, i.e. that are outdated, thus saving time? For that, we can use rsync. Rsync will copy files from one source to a destination only if the destination needs to be updated. This can save a lot of time by skipping files that already exist at the destination:\nrsync &lt;&lt;source&gt;&gt; &lt;&lt;destination&gt;&gt;"
  },
  {
    "objectID": "lecture-7.html#the-login--and-compute-nodes",
    "href": "lecture-7.html#the-login--and-compute-nodes",
    "title": "Linux & Supercomputer",
    "section": "The Login- and Compute Nodes",
    "text": "The Login- and Compute Nodes\nWhen you login to the cluster, you are logging into the login node. Note that no computation should be run on this node. If you want to run scripts, you will have to submit a job to the compute nodes.\nOn the login node there is a system installed called ‘SLURM’. SLURM is a job scheduler program that receives your requests for executing scripts, it will queue them and assign them to available compute nodes.\nWe will take a look at how to request and manage jobs using the various commands that SLURM provides."
  },
  {
    "objectID": "lecture-7.html#how-to-launch-a-job-srun",
    "href": "lecture-7.html#how-to-launch-a-job-srun",
    "title": "Linux & Supercomputer",
    "section": "How to launch a job – srun",
    "text": "How to launch a job – srun\nThe first command we will look at it is srun. This command will run request a job for execution in ‘real-time’. By real-time, we mean that the shell will wait until the job has been submitted.\nsrun &lt;&lt;compute node options&gt;&gt; &lt;&lt;command to run&gt;&gt;\nLet’s take a look at an example where we want to run an interactive bash shell on the compute shell (similar to ssh’ing into the compute node).\nsrun --time=00:10:00 --pty bash -l\nThis will request a job on any available compute node for 10 minutes. When a node becomes available, bash will execute, dropping you into the shell. You will notice that the shell prompt has changed from sms to the name of the node."
  },
  {
    "objectID": "lecture-7.html#salloc",
    "href": "lecture-7.html#salloc",
    "title": "Linux & Supercomputer",
    "section": "salloc",
    "text": "salloc\nThere is another method we can use to create an interactive job. We could use the salloc command to allocate resources for a task. After the resources have been allocated and our job is ready, we can ssh into the node with the allocated resources.\nsalloc --time=10:00:00 &\nssh &lt;name&gt;"
  },
  {
    "objectID": "lecture-7.html#options",
    "href": "lecture-7.html#options",
    "title": "Linux & Supercomputer",
    "section": "options",
    "text": "options\nIn the previous command, we used the --time option to specify how long the job will run for. But there are other options we can use to be more specific about the jobs we want to run.\n--cpus-per-task can be used to request more than one CPU to be allocated. This is especially helpful when we have a multithreaded process we want to run.\n--mem specifies how much memory should be allocated to the job. For example: --mem=16G tells SLURM to allocate 16 GB of memory."
  },
  {
    "objectID": "lecture-7.html#gpu-allocation",
    "href": "lecture-7.html#gpu-allocation",
    "title": "Linux & Supercomputer",
    "section": "GPU allocation",
    "text": "GPU allocation\nIf we need to use a GPU, we need to use a few options. Firstly, we can specify that our job is on a compute node with GPU. There will usually be a group of nodes in a ‘GPU’ group or partition, and thus we can specify to use one of these partitions:\nsrun --time=00:10:00 --partiton=gpu --pty bash -l\nBut you will notice that you still do not have access to a GPU. You’re running on the GPU node, but you haven’t actually requested a GPU be allocated to your job. For that you will use --gres:\nsrun --time=00:10:00 --partition=gpu --gres=gpu:1 --pty bash -l\nHere we are requesting one GPU, but if we use --gres:gpu:2 we are requesting 2 GPUs etc.\nThere are many different types of GPUs available, some older than others. If you wanted to allocate a job with a specific type of GPU you can use the --constraint flag:\nsrun --time=00:10:00 \\\n --partition=gpu \\\n --gres=gpu:1 \\\n --constraint='cuda61' \\\n --pty bash -l\nThis command requests that our job run on the GPU partition, with 1 GPU allocated that has the capability of running CUDA compute 61.\nOr we can specify the type of GPU in the gres option:\nsrun --time=00:10:00 \\\n --partition=gpu \\\n --gres=gpu:2080:1 \\\n --pty bash -l"
  },
  {
    "objectID": "lecture-7.html#learning-more-about-nodes",
    "href": "lecture-7.html#learning-more-about-nodes",
    "title": "Linux & Supercomputer",
    "section": "Learning more about nodes",
    "text": "Learning more about nodes\nTo understand what each compute node has we can use the scontrol command.\nscontrol show nodes\nWill list out all nodes and all capabilities of each node. Or just one node:\nscontrol show node lisnode2"
  },
  {
    "objectID": "lecture-7.html#sbatch",
    "href": "lecture-7.html#sbatch",
    "title": "Linux & Supercomputer",
    "section": "sbatch",
    "text": "sbatch\nIt can be quite inconvenient to launch an interactive job to run some compute, and wait for the job to be allocated. If, instead, you have a long running experiment that you want to run without any intervention from you, you can use sbatch.\nSbatch will require us to write a small bash script that specifies how to run a job and what to do once its allocated.\n#!/bin/bash\n\n#SBATCH --time=00:01:00\n#SBATCH --job-name=my_new_job\n#SBATCH --output=my_new_job.out\n#SBATCH --error=my_new_job.err\n\necho $HOSTNAME\nAnd run it:\nsbatch my_job.sh\nNotice that instead of supplying options to sbatch, we can instead record them directly into the script using the #SBATCH. SLURM will examine this file, looking for lines starting with this comment, and infer that the rest of the line contains the options.\nThere are a few other options we’ve included that are very useful when running non-interactive jobs. Firstly, we’ve given the job a name (my_new_job). This is so we can different between many jobs that we might run at the same time. To list out the jobs we currently have running we use squeue.\nsqueue\nBy default, squeue will list all of the active jobs, even other peoples. To specify only your jobs user the --user option:\nsqueue --user=jay.morgan\nThe other two options, --output and --error specify where the printed output and printed errors will be stored. Since the job is being run on a different node, by a non-interactive process, if you didn’t include these lines, you wouldn’t be able to see what was being printed by echo or by any other process such as print in Python."
  },
  {
    "objectID": "lecture-7.html#squeue",
    "href": "lecture-7.html#squeue",
    "title": "Linux & Supercomputer",
    "section": "squeue",
    "text": "squeue\nWhen we list the jobs using squeue it will give us multiple columns of information, such as:\n\nJOBID – the referable id of the job.\nPARTITION – the partition on which the job has been requested for.\nNAME – the name of the job.\nUSER – the user who submitted the job.\nST – the status, is the job currently running, waiting, or exiting?\nTIME – how long the job has been running for.\nNODES – how many nodes have been allocated to the job."
  },
  {
    "objectID": "lecture-7.html#scontrol",
    "href": "lecture-7.html#scontrol",
    "title": "Linux & Supercomputer",
    "section": "scontrol",
    "text": "scontrol\nscontrol allows us to modify an existing job. For example, let us say that we have a job which we need to extend the time limit. Given that we know the job id (we could use squeue to find this), we can ask SLURM to update the time limit using:\nscontrol update jobid=&lt;job_id&gt; TimeLimit=&lt;new_timelimit&gt;"
  },
  {
    "objectID": "lecture-7.html#scancel",
    "href": "lecture-7.html#scancel",
    "title": "Linux & Supercomputer",
    "section": "scancel",
    "text": "scancel\nLet’s say that we’ve submitted a job, but we’ve noticed that there was an error in the code, and want to stop the job. For that, we use scancel and specify the id of the job we wish to cancel:\nscancel 158590\nAfter running this command, we should see, using squeue, that either the job is finishing, or that its disappeared from our list (meaning that its completely stopped)."
  },
  {
    "objectID": "lecture-7.html#sacct",
    "href": "lecture-7.html#sacct",
    "title": "Linux & Supercomputer",
    "section": "sacct",
    "text": "sacct\nIf our job has finished, or exited and is no longer in squeue, we can use sacct to get a history of the jobs.\nsacct will list all of your jobs within some default window of time. If we want to change this window we can use the --starttime and --endtime options.\nValid time formats are:\n\nHH:MM[:SS][AM|PM]\nMMDD[YY][-HH:MM[:SS]]\nMM.DD[.YY][-HH:MM[:SS]]\nMM/DD[/YY][-HH:MM[:SS]]\nYYYY-MM-DD[THH:MM[:SS]]\ntoday, midnight, noon, fika (3 PM), teatime (4 PM)\nnow[{+|-}count[seconds(default)|minutes|hours|days|weeks]]"
  },
  {
    "objectID": "lecture-7.html#job-task-arrays-motivation",
    "href": "lecture-7.html#job-task-arrays-motivation",
    "title": "Linux & Supercomputer",
    "section": "Job Task Arrays – motivation",
    "text": "Job Task Arrays – motivation\nTask arrays allow you to submit many jobs of the same type. Why might this be useful? Suppose you have a list of files that take a long time to process:\n\nfile_0.txt\nfile_1.txt\nfile_2.txt\n\nOr you have some computation script, such as deep learning training script, that takes uses a hyperparameter which can be tuned to achieve different performance results:\npython train.py --learning-rate 0.001\nInstead of a creating a sbatch script for each value of hyperparameter, or sequentially enumerating the values, you can use a job task array to spawn multiple jobs with slightly different values."
  },
  {
    "objectID": "lecture-7.html#job-task-arrays-how-to",
    "href": "lecture-7.html#job-task-arrays-how-to",
    "title": "Linux & Supercomputer",
    "section": "Job Task Arrays – how to",
    "text": "Job Task Arrays – how to\nFirst, we will look at how to actually submit an array of tasks. To create an task array, you will need to add the --array options to your sbatch script:\n#!/bin/bash\n\n#SBATCH --job-name=my_task_array\n#SBATCH --array=1-5\n\n...\nHere we are creating an array of tasks numbered from 1-5. When you submit this script, you will see five tasks submitted to the queue.\nNow that we know how to create an array of tasks, we will want to do something useful with it. When you create an array, each individual task will have a unique variable called SLURM_ARRAY_TASK_ID. So for example, if we launch an array of 5 tasks, the first task will have the value 1. Why is this useful? Well, we can use this variable to alter the program slightly. Take for example our list of files we need to process:\n#!/bin/bash\n#SBATCH --job-name=my_task_array\n#SBATCH --array=0-4\n#SBATCH --time=00:10:00\n\nFILENAME=\"file_${SLURM_ARRAY_TASK_ID}.txt\"\npython process.py $FILENAME\nThis will create a new bash variable called FILENAME by concatenating file_ the current task’s (i.e. 0, for the first task, 1 for the second task, etc) and .txt.\nIf we run the previous example, we will see that we have five jobs named exactly the same thing my_task_array. This is okay, but we can be a little bit more clear as to which task is running, i.e. which task is processing which file?\nWe can use some special variables in our bash script to make this more clear. These are %A that is the main job id, and %a that is the task array id.\n#!/bin/bash\n\n#SBATCH --error=my_task_array.%A_%a.out\n#SBATCH --output=my_task_array.%A_%a.out\n...\nNow, every task in our array will have a slightly different name because of the %a and therefore we will be able to determine which job is processing which file.\nLet’s move on to the second example, where we have a Deep Learning training program and we want to try different parameters. In this case, we can again use a task array.\n#!/bin/bash\n\n#SBATCH --array=1-10\nWe could either pass the SLURM_ARRAY_TASK_ID as a command line argument to the script:\npython training.py --learning-rate $SLURM_ARRAY_TASK_ID\nBut in this case, we could have to properly calculate the correct learning rate from the SLURM_ARRAY_TASK_ID value (remember that in my sbatch script I set --array=1-5). But bash only performs integer arithmetic, therefore we will need to calculate the correct learning rate in something else.\nInstead of passing the learning rate via a command line argument. We can get the value directly from our python script and calculate the value.\nimport os\n\ntask_id = int(os.environ[\"SLURM_ARRAY_TASK_ID\"])\nlearning_rate = task_id / 100\nHere we are using the builtin os module in Python, getting the environment variable from the dictionary environ and parsing the value as an integer. Then we can calculate the appropriate learning rate using this value. So for example, if SLURM_ARRAY_TASK_ID is set to 1. Our learning rate would be 0.01 for this task.\nIf you’re creating a job task array, you may want to create hundreds of jobs. And of course, you don’t want to use up the entire cluster leaving no resources for anybody else! Therefore, you will only want a maximum number of tasks to run at any one time.\n#!/bin/bash\n\n#SBATCH --array=1-100%5\nThis will create a job task array of 100 jobs numbered from 1 to 100. But we have added an additional argument %5 which means that only 5 jobs can run at any one time for this task array. If you have five tasks running, the other 95 tasks will wait.\nIf, at any point, you want to change how many jobs can run simultaineously, you can update this ‘throttle’ value using scontrol:\nscontrol update ArrayTaskThrottle=&lt;count&gt; JobId=&lt;jobID&gt;\nSo if we’ve already launched a job task array with the job id of 50602 that has a throttle value of 5 (only 5 tasks will run at once), we can change it to 10 using:\nscontrol update ArrayTaskThrottle=10 JobId=50602"
  },
  {
    "objectID": "lecture-7.html#a-guided-walk-through-environment",
    "href": "lecture-7.html#a-guided-walk-through-environment",
    "title": "Linux & Supercomputer",
    "section": "A guided walk through – environment",
    "text": "A guided walk through – environment\nIn this section we’re going to give an example walk through of working with the HPC cluster. In this example, we’re going to write our scripts locally, including the slurm submission script, and when they’re ready, we’ll send them to the cluster to perform the actual computation.\nLet’s imagine we’re starting a new project, and are programming our scripts in Python. Now is a good time to create a new conda environment to install our packages we’re going to use for our research. We’ll create this environment with (replacing &lt;env-name&gt; with whatever we want to call this environment):\nconda create --name &lt;env-name&gt;\nand then activate it:\nconda activate &lt;env-name&gt;\nconda install python=3.9"
  },
  {
    "objectID": "lecture-7.html#writing-our-scripts",
    "href": "lecture-7.html#writing-our-scripts",
    "title": "Linux & Supercomputer",
    "section": "Writing our scripts",
    "text": "Writing our scripts\nLet us also image we’ve just wrote the following script to create a lorenz attractor: lorenz.py\nThe specific implementation of this script is not particularly important for this walk through. Just know that we’re importing a few packages such as numpy and matplotlib. Then, we’re performing some computation, and saving the results to analyse later. As this script uses external libraries, we need to install them:\nconda install numpy matplotlib"
  },
  {
    "objectID": "lecture-7.html#writing-our-job-submission-script",
    "href": "lecture-7.html#writing-our-job-submission-script",
    "title": "Linux & Supercomputer",
    "section": "Writing our job submission script",
    "text": "Writing our job submission script\nSince we want our calculations to be performed on the cluster, we will need to also write a job submission script (let’s call this submit-job.sh) in bash to pass to SLURM.\n#!/bin/bash\n\n#SBATCH --job-name=lorenz_attractor\n#SBATCH --output=lorenz_attractor.log\n#SBATCH --error=lorenz_attractor.log\n#SBATCH --time=00:10:00\n\npython lorenz.py"
  },
  {
    "objectID": "lecture-7.html#replicating-our-environment-on-the-cluster",
    "href": "lecture-7.html#replicating-our-environment-on-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Replicating our environment on the cluster",
    "text": "Replicating our environment on the cluster\nAs we’ve installed external packages in our local development environment, we will want to ensure that when we run the calculations on the cluster, it will be using the same versions of packages. Conda makes this a lot easier. First, we export our environment to a recipe file:\nconda env export --no-builds &gt; environment.yml"
  },
  {
    "objectID": "lecture-7.html#sending-our-scripts-to-the-cluster",
    "href": "lecture-7.html#sending-our-scripts-to-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Sending our scripts to the cluster",
    "text": "Sending our scripts to the cluster\nAll of our scripts are ready! We can now transfer them from our personal computer, to the cluster. The files we need to transfer are:\n\nlorenz.py\nenvironment.yml\nsubmit-job.sh\n\nWhile we can send a folder (and the containing files), let’s send them one at a time:\nscp lorenz.py &lt;hostname&gt;:&lt;destination-path&gt;\nscp environment.yml &lt;hostname&gt;:&lt;destination-path&gt;\nscp submit-job.sh &lt;hostname&gt;:&lt;destination-path&gt;\nwhere &lt;hostname&gt; is the hostname/IP address that you’ve used to connect to the login node on the cluster before. &lt;destination-path&gt; is the path to where you want to save the files."
  },
  {
    "objectID": "lecture-7.html#logging-into-the-cluster",
    "href": "lecture-7.html#logging-into-the-cluster",
    "title": "Linux & Supercomputer",
    "section": "Logging into the cluster",
    "text": "Logging into the cluster\nNow that our files are on the cluster, we can login:\nssh &lt;username&gt;@&lt;hostname&gt;\nAt which point, we’ve logged into the login node, and then we need to change directory to where we saved the files:\ncd &lt;destination-path&gt;"
  },
  {
    "objectID": "lecture-7.html#re-creating-our-development-environment",
    "href": "lecture-7.html#re-creating-our-development-environment",
    "title": "Linux & Supercomputer",
    "section": "Re-creating our development environment",
    "text": "Re-creating our development environment\nNow that we’re in the same folder as our scripts, we’re almost ready to submit our job. First, we need to recreate our development environment from our environment.yml file.\nconda env create -f environment.yml\nAnd activate our newly created environment:\nconda activate &lt;env-name&gt;"
  },
  {
    "objectID": "lecture-7.html#submitting-our-job",
    "href": "lecture-7.html#submitting-our-job",
    "title": "Linux & Supercomputer",
    "section": "Submitting our job",
    "text": "Submitting our job\nNow we can submit our job:\nsbatch submit-job.sh\nWe can check the progress of our job with squeue, or its already completed, look at the job history with sacct."
  },
  {
    "objectID": "lecture-7.html#downloading-the-results",
    "href": "lecture-7.html#downloading-the-results",
    "title": "Linux & Supercomputer",
    "section": "Downloading the results",
    "text": "Downloading the results\nIf our job runs successfully, a data.pkl file will be created. Back on our local computers, we will need to run the following to download it:\nscp &lt;hostname&gt;:&lt;destination-path&gt;/data.pkl ./\nThis will download the file into the current directory."
  },
  {
    "objectID": "lecture-7.html#analysing-the-results",
    "href": "lecture-7.html#analysing-the-results",
    "title": "Linux & Supercomputer",
    "section": "Analysing the results",
    "text": "Analysing the results\nWith the data.pkl file downloaded, we can visualise the results using plot_lorenz.py: https://pageperso.lis-lab.fr/jay.morgan/resources/2021-programming-level-up/lectures/week-5/plot-lorenz.py\nIf everything has been run correctly, you should see a plot of the lorenz attractor."
  },
  {
    "objectID": "lecture-7.html#useful-features-x11-forwarding",
    "href": "lecture-7.html#useful-features-x11-forwarding",
    "title": "Linux & Supercomputer",
    "section": "Useful features – X11 Forwarding",
    "text": "Useful features – X11 Forwarding\nIf we’re performing analysis interactively using the cluster, we’ll often want to visualise the results, using matplotlib for example. To see our plots display like they would on our local machine when we call plt.plot or plt.show(), we will need to ensure that we’re using something called X11 Forwarding. To enable X11 Forwarding, we use the -X option when ssh‘ing into the cluster and compute nodes (i.e. it will need to be enabled on every ’hop’ so to speak).\nssh -X &lt;&lt;remote-host&gt;&gt;\nIf want to enable it by default, we can enable it in our ssh config file:\nHost cluster\n HostName sms-ext.lis-lab.fr\n FowardX11 yes\n User &lt;&lt;username&gt;&gt;\nAfter setting up X11 Forwarding correctly, and when logged into the remote host, we should be able to echo a variable called $DISPLAY.\necho $DISPLAY\nIf $DISPLAY has a value, we know that X11 Forwarding has been setup correctly, and we’re ready to do some plotting!"
  },
  {
    "objectID": "lecture-7.html#useful-features-jupyter-notebooks",
    "href": "lecture-7.html#useful-features-jupyter-notebooks",
    "title": "Linux & Supercomputer",
    "section": "Useful features – Jupyter Notebooks",
    "text": "Useful features – Jupyter Notebooks\nWe’ve talked about how good jupyter notebooks are for performing analysis and exploration. But often times, we will need a lot of compute resources (more than our local computers can handle) to do this analysis. This is where using jupyter notebook on the supercomputers comes in handy. However, it is not as simple as starting the jupyter notebook server and opening up your web browser. First, we will need to setup a ‘reverse ssh tunnel’.\nIn a nut-shell, a reverse ssh tunnel allows you to redirect data on a remote port to a local port.\nTherefore, we can, using a reverse ssh tunnel, start a jupyter notebook on the supercomputer and access it using the web browser on our local computer!\nTo begin, we can create an interactive job on the cluster:\nsrun --time=01:00:00 --pty bash -l\nAnd start our jupyter notebook, specifying a port that will not be in use:\njupyter notebook --port 30333\nWith our notebook server now started on the 30333 port, we will want to create an ssh tunnel from our local computer, to the cluster’s login node, and then a tunnel from the login node to the specific compute node where the job is running:\nssh -L 30333:localhost:30333 &lt;&lt;cluster-login-node&gt;&gt; ssh -L 30333:localhost:30333 &lt;&lt;cluster-compute-node&gt;&gt;\nIf everything goes well, we should now be able to open up our web browser, navigate to localhost:30333 and see our jupyter notebooks."
  }
]