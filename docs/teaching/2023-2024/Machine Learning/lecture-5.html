<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jay Paul Morgan">

<title>K-Nearest Neighbour &amp; K-Means – Jay Paul Morgan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-184a39e1e80efe4759ac8f701513bda8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/academicons-1.9.2/all.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/academicons-1.9.2/size.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q1SQLS91HT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Q1SQLS91HT', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="K-Nearest Neighbour &amp; K-Means – Jay Paul Morgan">
<meta property="og:description" content="Lecture 5">
<meta property="og:image" content="https://morganwastaken.com/teaching/2023-2024/Machine Learning/images/knn-problem-statement.png">
<meta property="og:site_name" content="Jay Paul Morgan">
<meta property="og:image:height" content="934">
<meta property="og:image:width" content="1193">
<link rel="canonical" href="https://morganwastaken.com/teaching/2023-2024/Machine Learning/lecture-5.html">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Jay Paul Morgan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../artwork.html"> 
<span class="menu-text">Artwork</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resume.html"> 
<span class="menu-text">Résumé</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#knn-introduction" id="toc-knn-introduction" class="nav-link active" data-scroll-target="#knn-introduction">kNN Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link" data-scroll-target="#problem-statement">Problem statement</a></li>
  <li><a href="#example-solution" id="toc-example-solution" class="nav-link" data-scroll-target="#example-solution">Example solution</a></li>
  <li><a href="#the-effect-of-k" id="toc-the-effect-of-k" class="nav-link" data-scroll-target="#the-effect-of-k">The effect of <span class="math inline">\(K\)</span></a></li>
  <li><a href="#accounting-for-tiesdraws" id="toc-accounting-for-tiesdraws" class="nav-link" data-scroll-target="#accounting-for-tiesdraws">Accounting for ‘ties’/‘draws’</a></li>
  </ul></li>
  <li><a href="#k-means-introduction" id="toc-k-means-introduction" class="nav-link" data-scroll-target="#k-means-introduction">K-Means Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-statement-1" id="toc-problem-statement-1" class="nav-link" data-scroll-target="#problem-statement-1">Problem statement</a></li>
  <li><a href="#k-means-clustering" id="toc-k-means-clustering" class="nav-link" data-scroll-target="#k-means-clustering">K-Means clustering</a></li>
  <li><a href="#starting-point" id="toc-starting-point" class="nav-link" data-scroll-target="#starting-point">Starting point</a></li>
  <li><a href="#iterative-process" id="toc-iterative-process" class="nav-link" data-scroll-target="#iterative-process">Iterative process</a></li>
  <li><a href="#assigning-centroids" id="toc-assigning-centroids" class="nav-link" data-scroll-target="#assigning-centroids">Assigning centroids</a></li>
  </ul></li>
  <li><a href="#k-means-algorithm-detail" id="toc-k-means-algorithm-detail" class="nav-link" data-scroll-target="#k-means-algorithm-detail">K-Means Algorithm Detail</a>
  <ul class="collapse">
  <li><a href="#initialisation" id="toc-initialisation" class="nav-link" data-scroll-target="#initialisation">Initialisation</a></li>
  <li><a href="#iteration" id="toc-iteration" class="nav-link" data-scroll-target="#iteration">Iteration</a></li>
  <li><a href="#classification" id="toc-classification" class="nav-link" data-scroll-target="#classification">Classification</a></li>
  <li><a href="#evaluation-of-k-means" id="toc-evaluation-of-k-means" class="nav-link" data-scroll-target="#evaluation-of-k-means">Evaluation of K-means</a></li>
  <li><a href="#inter-cluster-distance" id="toc-inter-cluster-distance" class="nav-link" data-scroll-target="#inter-cluster-distance">Inter-cluster distance</a></li>
  <li><a href="#the-effect-of-k-1" id="toc-the-effect-of-k-1" class="nav-link" data-scroll-target="#the-effect-of-k-1">The effect of <span class="math inline">\(K\)</span></a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/jaypmorgan/morganwastaken.com/blob/main/teaching/2023-2024/Machine Learning/lecture-5.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/jaypmorgan/morganwastaken.com/edit/main/teaching/2023-2024/Machine Learning/lecture-5.qmd" class="toc-action"><i class="bi empty"></i>Edit this page</a></li><li><a href="https://github.com/jaypmorgan/morganwastaken.com/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="lecture-5-revealjs.html"><i class="bi bi-file-slides"></i>RevealJS</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">K-Nearest Neighbour &amp; K-Means</h1>
<p class="subtitle lead">Lecture 5</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jay Paul Morgan </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="knn-introduction" class="level1">
<h1>kNN Introduction</h1>
<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem statement</h2>
<p>The first algorithm we’re going to see today is a very simple one. Let’s image we have a feature space with labelled data points, such as this:</p>
<p><img src="images/knn-problem-statement.png" class="img-fluid"></p>
<p>We want to use these labelled data points as our training data to be able to predict the classification of new data points (such as those from our testing set).</p>
<p>The algorithm we’re going to use to do this classification is called K-nearest neighbour, or kNN for short. This algorithm isn’t mathematically derived as some others we’ve seen, but rather based on intuition.</p>
</section>
<section id="example-solution" class="level2">
<h2 class="anchored" data-anchor-id="example-solution">Example solution</h2>
<p>kNN is a classification algorithm where, we as the user, get to set <span class="math inline">\(K\)</span> ourselves. <span class="math inline">\(K\)</span> is the number of neighbours that will be considered for the model’s classification.</p>
<p>Neighbour’s of a new data point can be determined using the euclidean distance, and selecting <span class="math inline">\(K\)</span> closest points.</p>
<p><img src="images/knn-3-classification.png" class="img-fluid"></p>
<p>Let’s say we set <span class="math inline">\(K=3\)</span>, this means that when we have a new data point we want to classify, we’re going to find out where this new data point falls in the feature space, and find 3 of it’s closest neighbours. Using these closet neighbours, we will assign this new data point the same class as the class majority of it’s neighbours.</p>
</section>
<section id="the-effect-of-k" class="level2">
<h2 class="anchored" data-anchor-id="the-effect-of-k">The effect of <span class="math inline">\(K\)</span></h2>
<p><span class="math inline">\(K\)</span> in the kNN algorithm is user defined, and the larger the number, the more neighbours will be used. One fun example of the effect of <span class="math inline">\(K\)</span> is that if we were to set <span class="math inline">\(K=N\)</span> where <span class="math inline">\(N\)</span> is the number of data points in our training set, then we will always assign new data points the majority class.</p>
<p><img src="images/knn-all-classification.png" class="img-fluid"></p>
</section>
<section id="accounting-for-tiesdraws" class="level2">
<h2 class="anchored" data-anchor-id="accounting-for-tiesdraws">Accounting for ‘ties’/‘draws’</h2>
<p>What if, when using <span class="math inline">\(K=4\)</span>, two neighbours are of class 1, while the other two neighbours are of class 2. Which class is assigned to our new data point? Well, since the k-NN algorithm is not a mathematically derived algorithm, but based on the intuition that with similar coordinates in a feature space should be similar classes, then it’s up to you to decide how to deal with ‘ties’. One example, would be to avoid them all together and only use an odd <span class="math inline">\(K\)</span>. Another option would be to weight the neighbours by the distance to the new point to be classified. So that closer points have a higher weight. In summary here are some options:</p>
<ol type="1">
<li>Only use odd valued <span class="math inline">\(K\)</span>.</li>
<li>Decrease <span class="math inline">\(K\)</span> until the tie is broken.</li>
<li>Weight neighbours by the distance.</li>
</ol>
</section>
</section>
<section id="k-means-introduction" class="level1">
<h1>K-Means Introduction</h1>
<section id="problem-statement-1" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement-1">Problem statement</h2>
<p>Say we had a set of data, un-labelled data, and we wanted to separate them into groups or classes. Below we have an example where, as humans, we can see 3 distinct groups of data points. In today’s lecture, we’re going to look at an algorithm that can identify these same clusters or groups systematically.</p>
<p><img src="images/k-means-problem-statement.png" class="img-fluid"></p>
</section>
<section id="k-means-clustering" class="level2">
<h2 class="anchored" data-anchor-id="k-means-clustering">K-Means clustering</h2>
<p>This algorithm is called K-means. In essence, it is an algorithm that finds <span class="math inline">\(K\)</span> different clusters or groups of points, where <span class="math inline">\(K\)</span> is defined by the user.</p>
<p><img src="images/k-means-classified.png" class="img-fluid"></p>
<p>Of course, we have to, ourselves, pick a value of for <span class="math inline">\(K\)</span>. For data that has more than 3-dimensions, we might not know how many groups there are inherently in the data.</p>
<p><img src="images/k-means-classified-2.png" class="img-fluid"></p>
</section>
<section id="starting-point" class="level2">
<h2 class="anchored" data-anchor-id="starting-point">Starting point</h2>
<p>K-means is an iterative algorithm, which means that the <strong>centroids</strong> of the clusters will be randomly assigned in the feature space. Let’s say that we initialise a K-means algorithm with <span class="math inline">\(K = 3\)</span>. We might have something that looks like:</p>
<p><img src="images/k-means-classified-3.png" class="img-fluid"></p>
</section>
<section id="iterative-process" class="level2">
<h2 class="anchored" data-anchor-id="iterative-process">Iterative process</h2>
<p>As mentioned, K-means is an iterative process of assigning the position of the cluster’s centroid. Therefore, after randomly assigning each centroid to a different point in the feature space, the algorithm will iteratively move the centroid to better <em>match</em> the true clustering of data points. We’ll get back to how this is mathematically done later in the lecture, but for now we want to understand this intuition.</p>
<p><img src="images/k-means-updated.png" class="img-fluid"></p>
</section>
<section id="assigning-centroids" class="level2">
<h2 class="anchored" data-anchor-id="assigning-centroids">Assigning centroids</h2>
<p>After the algorithm has converged or stopped, we will have 3 centroids, that will, hopefully, match the true clustering of data points.</p>
<p>After we have these positioned centroids, they can be used to label new data points by determining to which cluster do the new data points fall under, or are closet to.</p>
<p><img src="images/k-means-new-classification.png" class="img-fluid"></p>
</section>
</section>
<section id="k-means-algorithm-detail" class="level1">
<h1>K-Means Algorithm Detail</h1>
<section id="initialisation" class="level2">
<h2 class="anchored" data-anchor-id="initialisation">Initialisation</h2>
<p>Let <span class="math inline">\(C\)</span> be the set of cluster centroids:</p>
<p><span class="math display">\[C = \{c_1, c_2, ..., c_K\}\]</span></p>
<p>And let <span class="math inline">\(S(c_i)\)</span> be the set of all points <span class="math inline">\(x_i\)</span> that are located within the cluster <span class="math inline">\(c_i\)</span>. The intersection of all <span class="math inline">\(S\)</span> will be the null set (each point will be assigned to only one cluster):</p>
<p><span class="math display">\[ \bigcap_{i=1}^{K} S(c_i) = \emptyset \]</span></p>
<p>To initialise the K-means algorithm, we randomly select <span class="math inline">\(K\)</span> data points as the location of the centroids, i.e.&nbsp;<span class="math inline">\(x_i = c_i\)</span>.</p>
<p>After, we compute <span class="math inline">\(S(c_i)\)</span> by the minimum euclidean distance to each centroid. I.e., to determine whether a new point falls within the cluster of <span class="math inline">\(c_i\)</span>, we can use the euclidean distance between <span class="math inline">\(x_i\)</span> and <span class="math inline">\(c_i\)</span>:</p>
<p><span class="math display">\[ \arg \min_{c_i \in C} || x_i - c_i ||^2 \]</span></p>
<p>So we select the cluster to which our new <span class="math inline">\(x_i\)</span> data point is closest to.</p>
<p>The position of each centroid <span class="math inline">\(c_i\)</span> is the geometric mean of the data points contained within the cluster:</p>
<p><span class="math display">\[ c_i = \frac{1}{|S(c_i)|} \sum_{x_j \in S(c_i)} x_j \]</span></p>
</section>
<section id="iteration" class="level2">
<h2 class="anchored" data-anchor-id="iteration">Iteration</h2>
<p>Classic optimisation problem:</p>
<p><span class="math display">\[ \arg \min_c \sum_{c_i \in C} \sum_{x_j \in S(c_i)} || x_j - c_i ||^2 \]</span></p>
<p>There are 3 criterions for stopping the iterative process:</p>
<ol type="1">
<li>There are no more changes in clusters by moving the centroids.</li>
<li>Points remain within the same cluster as before.</li>
<li>A maximum number of steps/iterations has been reached.</li>
</ol>
</section>
<section id="classification" class="level2">
<h2 class="anchored" data-anchor-id="classification">Classification</h2>
<p>To determine whether a new point falls within the cluster of <span class="math inline">\(c_i\)</span>, we can use the euclidean distance between <span class="math inline">\(x_i\)</span> and <span class="math inline">\(c_i\)</span>:</p>
<p><span class="math display">\[ \arg \min_{c_i \in C} || x_i - c_i ||^2 \]</span></p>
<p>So we select the cluster to which our new <span class="math inline">\(x_i\)</span> data point is closest to.</p>
</section>
<section id="evaluation-of-k-means" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-of-k-means">Evaluation of K-means</h2>
<p>Since we don’t have true labels with which to evaluate the k-means algorithm against, we must take a different tactic for evaluating the classifications or group of points it has clustered together. This works by evaluating the <em>structure</em> of the clusters.</p>
<p><strong>intra-cluster distance</strong> – the average distance between all data points in the same cluster.</p>
<p><img src="images/k-means-intra-2.png" class="img-fluid"></p>
<p><strong>intra-cluster diameter</strong> – the distance between the two most remote objects in a cluster.</p>
<p><img src="images/k-means-intra.png" class="img-fluid"></p>
</section>
<section id="inter-cluster-distance" class="level2">
<h2 class="anchored" data-anchor-id="inter-cluster-distance">Inter-cluster distance</h2>
<p><img src="images/k-means-inter.png" class="img-fluid"></p>
<p><strong>inter-cluster distance</strong> – average smallest distance to a different cluster.</p>
<p><strong>silhouette score</strong> – <span class="math inline">\(\frac{\text{intra} - \text{inter}}{\max(\text{intra}, \text{inter})}\)</span></p>
</section>
<section id="the-effect-of-k-1" class="level2">
<h2 class="anchored" data-anchor-id="the-effect-of-k-1">The effect of <span class="math inline">\(K\)</span></h2>
<p>The <span class="math inline">\(K\)</span> in k-means clustering determines how many clusters the algorithm will try to find. But if our data is un-labelled, how do we know what to set <span class="math inline">\(K\)</span> equal to? The answer is that we don’t necessarily. So we might create several different clustering algorithms where we vary the value for <span class="math inline">\(K\)</span> and evaluate the resulting model.</p>
<p>This may give us some indication as to how many clusters to use.</p>
<p>Other times the value for <span class="math inline">\(K\)</span> will be inherent to the problem you’re trying to solve. For example, if we’re trying to cluster and label the calls of different birds, we may know the number of different bird species that were recorded, thus providing some grounds for setting <span class="math inline">\(K\)</span>.</p>
</section>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>In today’s lecture, we’ve had a look at two different classification algorithms:</p>
<ol type="1">
<li><strong>K-Nearest Neighbour</strong> where we classify data points by looking at the existing classification of the existing <span class="math inline">\(K\)</span> neighbours.</li>
<li><strong>K-Means</strong> where, for un-labelled data, the algorithm finds the centroid of <span class="math inline">\(K\)</span> clusters, which we can use in future to classify new data points depending on which cluster they fall within.</li>
</ol>
<p>For each of these algorithms, we’ve first try understand, intuitively, what the algorithm is attempting to achieve. After this point, we’ve taken a look at the mathematics behind the algorithm so that we can gain a deeper understanding and appreciation for it’s mechanics.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/morganwastaken\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © 2026 Jay Paul Morgan
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/jaypmorgan/morganwastaken.com/blob/main/teaching/2023-2024/Machine Learning/lecture-5.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/jaypmorgan/morganwastaken.com/edit/main/teaching/2023-2024/Machine Learning/lecture-5.qmd" class="toc-action"><i class="bi empty"></i>Edit this page</a></li><li><a href="https://github.com/jaypmorgan/morganwastaken.com/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jaypmorgan">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jay-p-morgan/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://scholar.google.com/citations?user=AO1az5YAAAAJ&amp;hl=en">
<p><i class="ai  ai-google-scholar-square ai-lg"></i></p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://www.researchgate.net/profile/Jay-Morgan">
<p><i class="ai  ai-researchgate-square ai-lg"></i></p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://orcid.org/my-orcid?orcid=0000-0003-3719-362X">
<p><i class="ai  ai-orcid ai-lg"></i></p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>