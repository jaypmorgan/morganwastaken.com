<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jay Paul Morgan">

<title>Machine Learning - K-Nearest Neighbour &amp; K-Means</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lecture-1.html">Lectures</a></li><li class="breadcrumb-item"><a href="./lecture-5.html">K-Nearest Neighbour &amp; K-Means</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Machine Learning</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Lectures</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture-1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture-2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linear Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture-3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Performance</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture-4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Support Vector Machines</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture-5.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">K-Nearest Neighbour &amp; K-Means</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Labs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab-1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linear Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab-2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Evaluation of Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab-3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">K-Nereast Neighbours</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#knn-introduction" id="toc-knn-introduction" class="nav-link active" data-scroll-target="#knn-introduction">kNN Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link" data-scroll-target="#problem-statement">Problem statement</a></li>
  <li><a href="#example-solution" id="toc-example-solution" class="nav-link" data-scroll-target="#example-solution">Example solution</a></li>
  <li><a href="#the-effect-of-k" id="toc-the-effect-of-k" class="nav-link" data-scroll-target="#the-effect-of-k">The effect of <span class="math inline">\(K\)</span></a></li>
  <li><a href="#accounting-for-tiesdraws" id="toc-accounting-for-tiesdraws" class="nav-link" data-scroll-target="#accounting-for-tiesdraws">Accounting for ‘ties’/‘draws’</a></li>
  </ul></li>
  <li><a href="#k-means-introduction" id="toc-k-means-introduction" class="nav-link" data-scroll-target="#k-means-introduction">K-Means Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-statement-1" id="toc-problem-statement-1" class="nav-link" data-scroll-target="#problem-statement-1">Problem statement</a></li>
  <li><a href="#k-means-clustering" id="toc-k-means-clustering" class="nav-link" data-scroll-target="#k-means-clustering">K-Means clustering</a></li>
  <li><a href="#starting-point" id="toc-starting-point" class="nav-link" data-scroll-target="#starting-point">Starting point</a></li>
  <li><a href="#iterative-process" id="toc-iterative-process" class="nav-link" data-scroll-target="#iterative-process">Iterative process</a></li>
  <li><a href="#assigning-centroids" id="toc-assigning-centroids" class="nav-link" data-scroll-target="#assigning-centroids">Assigning centroids</a></li>
  </ul></li>
  <li><a href="#k-means-algorithm-detail" id="toc-k-means-algorithm-detail" class="nav-link" data-scroll-target="#k-means-algorithm-detail">K-Means Algorithm Detail</a>
  <ul class="collapse">
  <li><a href="#initialisation" id="toc-initialisation" class="nav-link" data-scroll-target="#initialisation">Initialisation</a></li>
  <li><a href="#iteration" id="toc-iteration" class="nav-link" data-scroll-target="#iteration">Iteration</a></li>
  <li><a href="#classification" id="toc-classification" class="nav-link" data-scroll-target="#classification">Classification</a></li>
  <li><a href="#evaluation-of-k-means" id="toc-evaluation-of-k-means" class="nav-link" data-scroll-target="#evaluation-of-k-means">Evaluation of K-means</a></li>
  <li><a href="#inter-cluster-distance" id="toc-inter-cluster-distance" class="nav-link" data-scroll-target="#inter-cluster-distance">Inter-cluster distance</a></li>
  <li><a href="#the-effect-of-k-1" id="toc-the-effect-of-k-1" class="nav-link" data-scroll-target="#the-effect-of-k-1">The effect of <span class="math inline">\(K\)</span></a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="lecture-5-revealjs.html"><i class="bi bi-file-slides"></i>RevealJS</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">K-Nearest Neighbour &amp; K-Means</h1>
<p class="subtitle lead">Lecture 5</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jay Paul Morgan </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="knn-introduction" class="level1">
<h1>kNN Introduction</h1>
<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem statement</h2>
<p>The first algorithm we’re going to see today is a very simple one. Let’s image we have a feature space with labelled data points, such as this:</p>
<p><img src="images/knn-problem-statement.png" class="img-fluid"></p>
<p>We want to use these labelled data points as our training data to be able to predict the classification of new data points (such as those from our testing set).</p>
<p>The algorithm we’re going to use to do this classification is called K-nearest neighbour, or kNN for short. This algorithm isn’t mathematically derived as some others we’ve seen, but rather based on intuition.</p>
</section>
<section id="example-solution" class="level2">
<h2 class="anchored" data-anchor-id="example-solution">Example solution</h2>
<p>kNN is a classification algorithm where, we as the user, get to set <span class="math inline">\(K\)</span> ourselves. <span class="math inline">\(K\)</span> is the number of neighbours that will be considered for the model’s classification.</p>
<p>Neighbour’s of a new data point can be determined using the euclidean distance, and selecting <span class="math inline">\(K\)</span> closest points.</p>
<p><img src="images/knn-3-classification.png" class="img-fluid"></p>
<p>Let’s say we set <span class="math inline">\(K=3\)</span>, this means that when we have a new data point we want to classify, we’re going to find out where this new data point falls in the feature space, and find 3 of it’s closest neighbours. Using these closet neighbours, we will assign this new data point the same class as the class majority of it’s neighbours.</p>
</section>
<section id="the-effect-of-k" class="level2">
<h2 class="anchored" data-anchor-id="the-effect-of-k">The effect of <span class="math inline">\(K\)</span></h2>
<p><span class="math inline">\(K\)</span> in the kNN algorithm is user defined, and the larger the number, the more neighbours will be used. One fun example of the effect of <span class="math inline">\(K\)</span> is that if we were to set <span class="math inline">\(K=N\)</span> where <span class="math inline">\(N\)</span> is the number of data points in our training set, then we will always assign new data points the majority class.</p>
<p><img src="images/knn-all-classification.png" class="img-fluid"></p>
</section>
<section id="accounting-for-tiesdraws" class="level2">
<h2 class="anchored" data-anchor-id="accounting-for-tiesdraws">Accounting for ‘ties’/‘draws’</h2>
<p>What if, when using <span class="math inline">\(K=4\)</span>, two neighbours are of class 1, while the other two neighbours are of class 2. Which class is assigned to our new data point? Well, since the k-NN algorithm is not a mathematically derived algorithm, but based on the intuition that with similar coordinates in a feature space should be similar classes, then it’s up to you to decide how to deal with ‘ties’. One example, would be to avoid them all together and only use an odd <span class="math inline">\(K\)</span>. Another option would be to weight the neighbours by the distance to the new point to be classified. So that closer points have a higher weight. In summary here are some options:</p>
<ol type="1">
<li>Only use odd valued <span class="math inline">\(K\)</span>.</li>
<li>Decrease <span class="math inline">\(K\)</span> until the tie is broken.</li>
<li>Weight neighbours by the distance.</li>
</ol>
</section>
</section>
<section id="k-means-introduction" class="level1">
<h1>K-Means Introduction</h1>
<section id="problem-statement-1" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement-1">Problem statement</h2>
<p>Say we had a set of data, un-labelled data, and we wanted to separate them into groups or classes. Below we have an example where, as humans, we can see 3 distinct groups of data points. In today’s lecture, we’re going to look at an algorithm that can identify these same clusters or groups systematically.</p>
<p><img src="images/k-means-problem-statement.png" class="img-fluid"></p>
</section>
<section id="k-means-clustering" class="level2">
<h2 class="anchored" data-anchor-id="k-means-clustering">K-Means clustering</h2>
<p>This algorithm is called K-means. In essence, it is an algorithm that finds <span class="math inline">\(K\)</span> different clusters or groups of points, where <span class="math inline">\(K\)</span> is defined by the user.</p>
<p><img src="images/k-means-classified.png" class="img-fluid"></p>
<p>Of course, we have to, ourselves, pick a value of for <span class="math inline">\(K\)</span>. For data that has more than 3-dimensions, we might not know how many groups there are inherently in the data.</p>
<p><img src="images/k-means-classified-2.png" class="img-fluid"></p>
</section>
<section id="starting-point" class="level2">
<h2 class="anchored" data-anchor-id="starting-point">Starting point</h2>
<p>K-means is an iterative algorithm, which means that the <strong>centroids</strong> of the clusters will be randomly assigned in the feature space. Let’s say that we initialise a K-means algorithm with <span class="math inline">\(K = 3\)</span>. We might have something that looks like:</p>
<p><img src="images/k-means-classified-3.png" class="img-fluid"></p>
</section>
<section id="iterative-process" class="level2">
<h2 class="anchored" data-anchor-id="iterative-process">Iterative process</h2>
<p>As mentioned, K-means is an iterative process of assigning the position of the cluster’s centroid. Therefore, after randomly assigning each centroid to a different point in the feature space, the algorithm will iteratively move the centroid to better <em>match</em> the true clustering of data points. We’ll get back to how this is mathematically done later in the lecture, but for now we want to understand this intuition.</p>
<p><img src="images/k-means-updated.png" class="img-fluid"></p>
</section>
<section id="assigning-centroids" class="level2">
<h2 class="anchored" data-anchor-id="assigning-centroids">Assigning centroids</h2>
<p>After the algorithm has converged or stopped, we will have 3 centroids, that will, hopefully, match the true clustering of data points.</p>
<p>After we have these positioned centroids, they can be used to label new data points by determining to which cluster do the new data points fall under, or are closet to.</p>
<p><img src="images/k-means-new-classification.png" class="img-fluid"></p>
</section>
</section>
<section id="k-means-algorithm-detail" class="level1">
<h1>K-Means Algorithm Detail</h1>
<section id="initialisation" class="level2">
<h2 class="anchored" data-anchor-id="initialisation">Initialisation</h2>
<p>Let <span class="math inline">\(C\)</span> be the set of cluster centroids:</p>
<p><span class="math display">\[C = \{c_1, c_2, ..., c_K\}\]</span></p>
<p>And let <span class="math inline">\(S(c_i)\)</span> be the set of all points <span class="math inline">\(x_i\)</span> that are located within the cluster <span class="math inline">\(c_i\)</span>. The intersection of all <span class="math inline">\(S\)</span> will be the null set (each point will be assigned to only one cluster):</p>
<p><span class="math display">\[ \bigcap_{i=1}^{K} S(c_i) = \emptyset \]</span></p>
<p>To initialise the K-means algorithm, we randomly select <span class="math inline">\(K\)</span> data points as the location of the centroids, i.e.&nbsp;<span class="math inline">\(x_i = c_i\)</span>.</p>
<p>After, we compute <span class="math inline">\(S(c_i)\)</span> by the minimum euclidean distance to each centroid. I.e., to determine whether a new point falls within the cluster of <span class="math inline">\(c_i\)</span>, we can use the euclidean distance between <span class="math inline">\(x_i\)</span> and <span class="math inline">\(c_i\)</span>:</p>
<p><span class="math display">\[ \arg \min_{c_i \in C} || x_i - c_i ||^2 \]</span></p>
<p>So we select the cluster to which our new <span class="math inline">\(x_i\)</span> data point is closest to.</p>
<p>The position of each centroid <span class="math inline">\(c_i\)</span> is the geometric mean of the data points contained within the cluster:</p>
<p><span class="math display">\[ c_i = \frac{1}{|S(c_i)|} \sum_{x_j \in S(c_i)} x_j \]</span></p>
</section>
<section id="iteration" class="level2">
<h2 class="anchored" data-anchor-id="iteration">Iteration</h2>
<p>Classic optimisation problem:</p>
<p><span class="math display">\[ \arg \min_c \sum_{c_i \in C} \sum_{x_j \in S(c_i)} || x_j - c_i ||^2 \]</span></p>
<p>There are 3 criterions for stopping the iterative process:</p>
<ol type="1">
<li>There are no more changes in clusters by moving the centroids.</li>
<li>Points remain within the same cluster as before.</li>
<li>A maximum number of steps/iterations has been reached.</li>
</ol>
</section>
<section id="classification" class="level2">
<h2 class="anchored" data-anchor-id="classification">Classification</h2>
<p>To determine whether a new point falls within the cluster of <span class="math inline">\(c_i\)</span>, we can use the euclidean distance between <span class="math inline">\(x_i\)</span> and <span class="math inline">\(c_i\)</span>:</p>
<p><span class="math display">\[ \arg \min_{c_i \in C} || x_i - c_i ||^2 \]</span></p>
<p>So we select the cluster to which our new <span class="math inline">\(x_i\)</span> data point is closest to.</p>
</section>
<section id="evaluation-of-k-means" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-of-k-means">Evaluation of K-means</h2>
<p>Since we don’t have true labels with which to evaluate the k-means algorithm against, we must take a different tactic for evaluating the classifications or group of points it has clustered together. This works by evaluating the <em>structure</em> of the clusters.</p>
<p><strong>intra-cluster distance</strong> – the average distance between all data points in the same cluster.</p>
<p><img src="images/k-means-intra-2.png" class="img-fluid"></p>
<p><strong>intra-cluster diameter</strong> – the distance between the two most remote objects in a cluster.</p>
<p><img src="images/k-means-intra.png" class="img-fluid"></p>
</section>
<section id="inter-cluster-distance" class="level2">
<h2 class="anchored" data-anchor-id="inter-cluster-distance">Inter-cluster distance</h2>
<p><img src="images/k-means-inter.png" class="img-fluid"></p>
<p><strong>inter-cluster distance</strong> – average smallest distance to a different cluster.</p>
<p><strong>silhouette score</strong> – <span class="math inline">\(\frac{\text{intra} - \text{inter}}{\max(\text{intra}, \text{inter})}\)</span></p>
</section>
<section id="the-effect-of-k-1" class="level2">
<h2 class="anchored" data-anchor-id="the-effect-of-k-1">The effect of <span class="math inline">\(K\)</span></h2>
<p>The <span class="math inline">\(K\)</span> in k-means clustering determines how many clusters the algorithm will try to find. But if our data is un-labelled, how do we know what to set <span class="math inline">\(K\)</span> equal to? The answer is that we don’t necessarily. So we might create several different clustering algorithms where we vary the value for <span class="math inline">\(K\)</span> and evaluate the resulting model.</p>
<p>This may give us some indication as to how many clusters to use.</p>
<p>Other times the value for <span class="math inline">\(K\)</span> will be inherent to the problem you’re trying to solve. For example, if we’re trying to cluster and label the calls of different birds, we may know the number of different bird species that were recorded, thus providing some grounds for setting <span class="math inline">\(K\)</span>.</p>
</section>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>In today’s lecture, we’ve had a look at two different classification algorithms:</p>
<ol type="1">
<li><strong>K-Nearest Neighbour</strong> where we classify data points by looking at the existing classification of the existing <span class="math inline">\(K\)</span> neighbours.</li>
<li><strong>K-Means</strong> where, for un-labelled data, the algorithm finds the centroid of <span class="math inline">\(K\)</span> clusters, which we can use in future to classify new data points depending on which cluster they fall within.</li>
</ol>
<p>For each of these algorithms, we’ve first try understand, intuitively, what the algorithm is attempting to achieve. After this point, we’ve taken a look at the mathematics behind the algorithm so that we can gain a deeper understanding and appreciation for it’s mechanics.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>